---
description: Installing K8sTA
---

# Installing K8sTA

## Basic installation

Installing K8sTA with default configuration is quick and easy.

You will need:

* [Helm](https://helm.sh/docs/): These instructions were tested with v3.10.0.
* A Kubernetes cluster with [Argo CD](https://argo-cd.readthedocs.io)
  pre-installed. These instructions were tested with:
    * Kubernetes: v1.25.2
    * Argo CD: v2.4.12

:::note
A single Argo CD control plane is capable of managing multiple Kubernetes
clusters. If you are running Argo CD with this sort of topology, K8sTA is
intended to be installed into the same cluster as the Argo CD control plane and
_not_ into the individual clusters that Argo CD is managing.
:::

:::info
The Helm charts for K8sTA, much like K8sTA's container images, are hosted in the
GitHub Container Registry and are currently accessible only by Akuity employees.
This means you will need to log into the `ghcr.io` registry to proceed, exactly
as if you were going to pull a private image from there.

When K8sTA is eventually made public, this step will no longer be necessary.
:::

Use the command `docker login ghcr.io` and follow the prompts. Use your GitHub
handle for the username and, for the password, use a
[personal access token](https://github.com/settings/tokens) with adequate
permissions to pull packages, then:

```shell
helm install k8sta \
  oci://ghcr.io/akuityio/k8sta-chart/k8sta \
  --version v0.1.0-alpha.1 \
  --create-namespace \
  --namespace k8sta \
  --wait
```

## Production-grade installation

:::caution
K8sTA isn't actually production-ready at this time.
:::

The instructions in the previous section are not suited for a production-grade
installation of K8sTA. Installing K8sTA for production use requires some
tweaking of the default configuration.

1. Extract the default configuration from the Helm chart and save it to a
   convenient location. In the example below, we save it to
   `~/k8sta-values.yaml`

   ```shell
   helm inspect values \
     oci://ghcr.io/akuityio/k8sta-chart/k8sta \
     --version v0.1.0-alpha.1 > ~/k8sta-values.yaml
   ```

1. Edit the saved configuration. The following settings are of particular
   interest for a production-grade deployment:

   __Bookkeeper settings__ 

    * `bookkeeper.server.host`: If you plan to expose the Bookkeeper server for
      standalone use, change the value of this setting to match the DNS name you
      intend to use. The Helm chart will use this setting in a number of places,
      so it is best if it is correct.

    * `bookkeeper.server.service.type`: If you plan to expose the Bookkeeper
      server for standalone use _and do not plan to do so using an ingress
      controller_, change the value of this setting to `LoadBalancer`.

    * `bookkeeper.server.tls.enabled`: Requests to Bookkeeper often include
      sensitive values, so Bookkeeper traffic should always be encrypted
      end-to-end. Leave the value of this setting as `true` _unless_ you are
      using a service mesh to guarantee mTLS within your cluster.

    * `bookkeeper.server.tls.generateSelfSignedCert`: By default, the Bookkeeper
      server has TLS enabled and uses a self-signed cert that is generated by
      the Helm chart. Self-signed certificates are not trusted by clients, so
      unless you are using a service mesh to guarantee mTLS within your cluster,
      you should change the value of this setting to `false` and provide your
      own certificate instead.

      Two options exist for providing your own certificate. You may:

      * Base64 encode certificate and key material and add them to
        `bookkeeper.server.tls.cert` and `bookkeeper.server.tls.key`,
        respectively.

      * Provide a
        [TLS secret](https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets)
        named `k8sta-bookkeeper-server-cert` in the same namespace as K8sTA.
        This secret could be created either manually or by means of a
        certificate manager.

    * `bookkeeper.server.ingress.enabled`: If you plan to expose the Bookkeeper
      server for standalone use _and plan to do so using an ingress controller_,
      change the value of this setting to `true`.

    * `bookkeeper.server.ingress.tls.generateSelfSignedCert`: If enabled, the
      Bookkeeper server's `Ingress` resource has TLS enabled by default and uses
      a self-signed cert that is generated by the Helm chart. Self-signed
      certificates are not trusted by clients, so if you plan to expose the
      Bookkeeper server for standalone use _and plan to do so using an ingress
      controller_, you should change the value of this setting to `false` and
      provide your own certificate instead.

      Two options exist for providing your own certificate. You may:

      * Base64 encode certificate and key material and add them to
        `bookkeeper.server.ingress.tls.cert` and
        `bookkeeper.server.ingress.tls.key`,
        respectively.

      * Provide a
        [TLS secret](https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets)
        named `k8sta-bookkeeper-server-ingress-cert` in the same namespace as
        K8sTA. This secret could be created either manually or by means of a
        certificate manager.

   __Server settings__

    * `server.host`: If you plan to expose the K8sTA server for receiving
      webhooks, change the value of this setting to match the DNS name you
      intend to use. The Helm chart will use this setting in a number of places,
      so it is best if it is correct.

    * `server.service.type`: If you plan to expose the K8sTA server for
      receiving webhooks _and do not plan to do so using an ingress controller_,
      change the value of this setting to `LoadBalancer`.

    * `server.tls.enabled`: Webhooks received by the K8sTA server _may_ include
      sensitive values, so K8sTA server traffic should always be encrypted
      end-to-end. Leave the value of this setting as `true` _unless_ you are
      using a service mesh to guarantee mTLS within your cluster.

    * `server.tls.generateSelfSignedCert`: By default, the K8sTA server has TLS
      enabled and uses a self-signed cert that is generated by the Helm chart.
      Self-signed certificates are not trusted by clients, so unless you are
      using a service mesh to guarantee mTLS within your cluster, you should
      change the value of this setting to `false` and provide your own
      certificate instead.

      Two options exist for providing your own certificate. You may:

      * Base64 encode certificate and key material and add them to
        `server.tls.cert` and `server.tls.key`, respectively.

      * Provide a
        [TLS secret](https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets)
        named `k8sta-server-cert` in the same namespace as K8sTA.
        This secret could be created either manually or by means of a
        certificate manager.

    * `server.ingress.enabled`: If you plan to expose the K8sTA
      server for receiving webhooks _and plan to do so using an ingress
      controller_, change the value of this setting to `true`.

    * `server.ingress.tls.generateSelfSignedCert`: If enabled, the K8sTA
      server's `Ingress` resource has TLS enabled by default and uses a
      self-signed cert that is generated by the Helm chart. Self-signed
      certificates are not trusted by clients, so if you plan to expose the
      K8sTA server for receiving webhooks _and plan to do so using an ingress
      controller_, you should change the value of this setting to `false` and
      provide your own certificate instead.

      Two options exist for providing your own certificate. You may:

      * Base64 encode certificate and key material and add them to
        `server.ingress.tls.cert` and `server.ingress.tls.key`, respectively.

      * Provide a
        [TLS secret](https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets)
        named `k8sta-server-ingress-cert` in the same namespace as
        K8sTA. This secret could be created either manually or by means of a
        certificate manager.

    * `dockerhub.tokens`: If you intend to receive webhooks from Docker Hub, add
      one or more tokens (shared secrets) to this section as key/value pairs.
      Keys are ignored by the server and only serve as recognizable token
      identifiers for human operators. Values should be lengthy and
      hard-to-guess. If you are in the habit of using a password manager, it's
      advised to use that for generating the tokens. It is also suggested to
      restrict the value to Base64 characters only to avoid the complication of
      needing to URL-encode the token when configuring webhooks on Docker Hub.

   __Controller settings__

    * `controller.bookkeeper.tls.ignoreCertWarnings`: By default, the Bookkeeper
      server uses TLS with self-signed certificates, so the K8sTA controller is,
      by default, configured to tolerate certificate errors when communicating
      with the Bookkeeper server. If you are now using a trusted certificate for
      the Bookkeeper server, change the value of this setting to `false`.

   __Other settings__

   Although weâ€™ve covered the most critical settings, consider perusing
   `~/k8sta-values.yaml` further to discover other settings you may wish to fine
   tune. The file itself is liberally commented with detailed instructions.

1. Proceed with installation:

   ```shell
   helm install k8sta \
     oci://ghcr.io/akuityio/k8sta-chart/k8sta \
     --version v0.1.0-alpha.1 \
     --create-namespace \
     --namespace k8sta \
     --values ~/k8sta-values.yaml \
     --wait
   ```
