// This file was autogenerated by go-to-protobuf. Do not edit it manually!

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file v1alpha1/generated.proto (package github.com.akuity.kargo.api.v1alpha1, syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2 } from "@bufbuild/protobuf";
import { ListMeta, ObjectMeta, Time } from "../k8s.io/apimachinery/pkg/apis/meta/v1/generated_pb.js";

/**
 * ArgoCDAppCheck describes a health check to perform on an Argo CD Application
 * resource.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDAppCheck
 */
export class ArgoCDAppCheck extends Message<ArgoCDAppCheck> {
  /**
   * AppName specifies the name of the Argo CD Application resource.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string appName = 1;
   */
  appName?: string;

  /**
   * AppNamespace specifies the namespace of the Argo CD Application resource.
   * If left unspecified, the namespace of this Application resource is
   * defaulted to be the same as that of the Environment.
   *
   * +kubebuilder:validation:Optional
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string appNamespace = 2;
   */
  appNamespace?: string;

  constructor(data?: PartialMessage<ArgoCDAppCheck>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDAppCheck";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "appName", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "appNamespace", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDAppCheck {
    return new ArgoCDAppCheck().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDAppCheck {
    return new ArgoCDAppCheck().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDAppCheck {
    return new ArgoCDAppCheck().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDAppCheck | PlainMessage<ArgoCDAppCheck> | undefined, b: ArgoCDAppCheck | PlainMessage<ArgoCDAppCheck> | undefined): boolean {
    return proto2.util.equals(ArgoCDAppCheck, a, b);
  }
}

/**
 * ArgoCDAppUpdate describes updates that should be applied to an Argo CD
 * Application resources to incorporate newly observed materials into an
 * Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDAppUpdate
 */
export class ArgoCDAppUpdate extends Message<ArgoCDAppUpdate> {
  /**
   * AppName specifies the name of an Argo CD Application resource to be
   * updated.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string appName = 1;
   */
  appName?: string;

  /**
   * AppNamespace specifies the namespace of an Argo CD Application resource to
   * be updated. If left unspecified, the namespace of this Application resource
   * is defaulted to that of the Environment.
   *
   * +kubebuilder:validation:Optional
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string appNamespace = 2;
   */
  appNamespace?: string;

  /**
   * SourceUpdates describes updates to be applied to various sources of the
   * specified Argo CD Application resource.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDSourceUpdate sourceUpdates = 3;
   */
  sourceUpdates: ArgoCDSourceUpdate[] = [];

  constructor(data?: PartialMessage<ArgoCDAppUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDAppUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "appName", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "appNamespace", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "sourceUpdates", kind: "message", T: ArgoCDSourceUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDAppUpdate {
    return new ArgoCDAppUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDAppUpdate {
    return new ArgoCDAppUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDAppUpdate {
    return new ArgoCDAppUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDAppUpdate | PlainMessage<ArgoCDAppUpdate> | undefined, b: ArgoCDAppUpdate | PlainMessage<ArgoCDAppUpdate> | undefined): boolean {
    return proto2.util.equals(ArgoCDAppUpdate, a, b);
  }
}

/**
 * ArgoCDHelm describes updates to an Argo CD Application source's Helm-specific
 * attributes to incorporate newly observed materials into an Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDHelm
 */
export class ArgoCDHelm extends Message<ArgoCDHelm> {
  /**
   * Images describes how specific image versions can be incorporated into an
   * Argo CD Application's Helm parameters.
   *
   * +kubebuilder:validation:MinItems=1
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDHelmImageUpdate images = 1;
   */
  images: ArgoCDHelmImageUpdate[] = [];

  constructor(data?: PartialMessage<ArgoCDHelm>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDHelm";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "message", T: ArgoCDHelmImageUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDHelm {
    return new ArgoCDHelm().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDHelm {
    return new ArgoCDHelm().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDHelm {
    return new ArgoCDHelm().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDHelm | PlainMessage<ArgoCDHelm> | undefined, b: ArgoCDHelm | PlainMessage<ArgoCDHelm> | undefined): boolean {
    return proto2.util.equals(ArgoCDHelm, a, b);
  }
}

/**
 * ArgoCDHelmImageUpdate describes how a specific image version can be
 * incorporated into an Argo CD Application's Helm parameters.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDHelmImageUpdate
 */
export class ArgoCDHelmImageUpdate extends Message<ArgoCDHelmImageUpdate> {
  /**
   * Image specifies a container image (without tag). This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string image = 1;
   */
  image?: string;

  /**
   * Key specifies a key within an Argo CD Application's Helm parameters that is
   * to be updated. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string key = 2;
   */
  key?: string;

  /**
   * Value specifies the new value for the specified key in the Argo CD
   * Application's Helm parameters. Valid values are "Image", which replaces the
   * value of the specified key with the entire <image name>:<tag>, or "Tag"
   * which replaces the value of the specified with just the new tag. This is a
   * required field.
   *
   * @generated from field: optional string value = 3;
   */
  value?: string;

  constructor(data?: PartialMessage<ArgoCDHelmImageUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDHelmImageUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDHelmImageUpdate {
    return new ArgoCDHelmImageUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDHelmImageUpdate {
    return new ArgoCDHelmImageUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDHelmImageUpdate {
    return new ArgoCDHelmImageUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDHelmImageUpdate | PlainMessage<ArgoCDHelmImageUpdate> | undefined, b: ArgoCDHelmImageUpdate | PlainMessage<ArgoCDHelmImageUpdate> | undefined): boolean {
    return proto2.util.equals(ArgoCDHelmImageUpdate, a, b);
  }
}

/**
 * ArgoCDKustomize describes updates to an Argo CD Application source's
 * Kustomize-specific attributes to incorporate newly observed materials into an
 * Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomize
 */
export class ArgoCDKustomize extends Message<ArgoCDKustomize> {
  /**
   * Images describes how specific image versions can be incorporated into an
   * Argo CD Application's Kustomize parameters.
   *
   * +kubebuilder:validation:MinItems=1
   *
   * @generated from field: repeated string images = 1;
   */
  images: string[] = [];

  constructor(data?: PartialMessage<ArgoCDKustomize>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomize";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDKustomize {
    return new ArgoCDKustomize().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDKustomize {
    return new ArgoCDKustomize().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDKustomize {
    return new ArgoCDKustomize().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDKustomize | PlainMessage<ArgoCDKustomize> | undefined, b: ArgoCDKustomize | PlainMessage<ArgoCDKustomize> | undefined): boolean {
    return proto2.util.equals(ArgoCDKustomize, a, b);
  }
}

/**
 * ArgoCDSourceUpdate describes updates that should be applied to one of an Argo
 * CD Application resource's sources.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDSourceUpdate
 */
export class ArgoCDSourceUpdate extends Message<ArgoCDSourceUpdate> {
  /**
   * RepoURL identifies which of the Argo CD Application's sources this update
   * is intended for. Note: As of Argo CD 2.6, Application's can use multiple
   * sources.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Chart specifies a chart within a Helm chart registry if RepoURL points to a
   * Helm chart registry. Application sources that point directly at a chart do
   * so through a combination of their own RepoURL (registry) and Chart fields,
   * so BOTH of those are used as criteria in selecting an Application source to
   * update. This field MUST always be used when RepoURL points at a Helm chart
   * registry. This field MUST never be used when RepoURL points at a Git
   * repository.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string chart = 2;
   */
  chart?: string;

  /**
   * UpdateTargetRevision is a bool indicating whether the source should be
   * updated such that its TargetRevision field points at the most recently git
   * commit (if RepoURL references a git repository) or chart version (if
   * RepoURL references a chart repository).
   *
   * @generated from field: optional bool updateTargetRevision = 3;
   */
  updateTargetRevision?: boolean;

  /**
   * Kustomize describes updates to the source's Kustomize-specific attributes.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomize kustomize = 4;
   */
  kustomize?: ArgoCDKustomize;

  /**
   * Helm describes updates to the source's Helm-specific attributes.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ArgoCDHelm helm = 5;
   */
  helm?: ArgoCDHelm;

  constructor(data?: PartialMessage<ArgoCDSourceUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDSourceUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "chart", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "updateTargetRevision", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "kustomize", kind: "message", T: ArgoCDKustomize, opt: true },
    { no: 5, name: "helm", kind: "message", T: ArgoCDHelm, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDSourceUpdate {
    return new ArgoCDSourceUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDSourceUpdate {
    return new ArgoCDSourceUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDSourceUpdate {
    return new ArgoCDSourceUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDSourceUpdate | PlainMessage<ArgoCDSourceUpdate> | undefined, b: ArgoCDSourceUpdate | PlainMessage<ArgoCDSourceUpdate> | undefined): boolean {
    return proto2.util.equals(ArgoCDSourceUpdate, a, b);
  }
}

/**
 * AuthorizedPromoter identifies a single subject that is authorized to create
 * Promotion resources referencing a particular Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.AuthorizedPromoter
 */
export class AuthorizedPromoter extends Message<AuthorizedPromoter> {
  /**
   * SubjectType identifies the type of subject being authorized to create
   * Promotion resources referencing a particular Environment.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional string subjectType = 1;
   */
  subjectType?: string;

  /**
   * Name is the name of a subject authorized to create Promotion
   * resources referencing a particular Environment. This could be a username,
   * group name, ServiceAccount name, or Role name.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  constructor(data?: PartialMessage<AuthorizedPromoter>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.AuthorizedPromoter";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "subjectType", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthorizedPromoter {
    return new AuthorizedPromoter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthorizedPromoter {
    return new AuthorizedPromoter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthorizedPromoter {
    return new AuthorizedPromoter().fromJsonString(jsonString, options);
  }

  static equals(a: AuthorizedPromoter | PlainMessage<AuthorizedPromoter> | undefined, b: AuthorizedPromoter | PlainMessage<AuthorizedPromoter> | undefined): boolean {
    return proto2.util.equals(AuthorizedPromoter, a, b);
  }
}

/**
 * BookkeeperPromotionMechanism describes how to use Bookkeeper to incorporate
 * newly observed materials into an Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.BookkeeperPromotionMechanism
 */
export class BookkeeperPromotionMechanism extends Message<BookkeeperPromotionMechanism> {
  constructor(data?: PartialMessage<BookkeeperPromotionMechanism>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.BookkeeperPromotionMechanism";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BookkeeperPromotionMechanism {
    return new BookkeeperPromotionMechanism().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BookkeeperPromotionMechanism {
    return new BookkeeperPromotionMechanism().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BookkeeperPromotionMechanism {
    return new BookkeeperPromotionMechanism().fromJsonString(jsonString, options);
  }

  static equals(a: BookkeeperPromotionMechanism | PlainMessage<BookkeeperPromotionMechanism> | undefined, b: BookkeeperPromotionMechanism | PlainMessage<BookkeeperPromotionMechanism> | undefined): boolean {
    return proto2.util.equals(BookkeeperPromotionMechanism, a, b);
  }
}

/**
 * Chart describes a specific version of a Helm chart.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Chart
 */
export class Chart extends Message<Chart> {
  /**
   * RepoURL specifies the remote registry in which this chart is located.
   *
   * @generated from field: optional string registryURL = 1;
   */
  registryURL?: string;

  /**
   * Name specifies the name of the chart.
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * Version specifies a particular version of the chart.
   *
   * @generated from field: optional string version = 3;
   */
  version?: string;

  constructor(data?: PartialMessage<Chart>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Chart";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "registryURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Chart {
    return new Chart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Chart {
    return new Chart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Chart {
    return new Chart().fromJsonString(jsonString, options);
  }

  static equals(a: Chart | PlainMessage<Chart> | undefined, b: Chart | PlainMessage<Chart> | undefined): boolean {
    return proto2.util.equals(Chart, a, b);
  }
}

/**
 * ChartSubscription defines a subscription to a Helm chart repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ChartSubscription
 */
export class ChartSubscription extends Message<ChartSubscription> {
  /**
   * RegistryURL specifies the URL of a Helm chart registry. It may be a classic
   * chart registry (using HTTP/S) OR an OCI registry. This field is required.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^(((https?)|(oci))://)([\w\d\.]+)(:[\d]+)?(/.*)*$`
   *
   * @generated from field: optional string registryURL = 1;
   */
  registryURL?: string;

  /**
   * Name specifies a Helm chart to subscribe to within the Helm chart registry
   * specified by the RegistryURL field. This field is required.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * SemverConstraint specifies constraints on what new chart versions are
   * permissible. This field is optional. When left unspecified, there will be
   * no constraints, which means the latest version of the chart will always be
   * used. Care should be taken with leaving this field unspecified, as it can
   * lead to the unanticipated rollout of breaking changes.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string semverConstraint = 3;
   */
  semverConstraint?: string;

  constructor(data?: PartialMessage<ChartSubscription>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ChartSubscription";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "registryURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "semverConstraint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChartSubscription {
    return new ChartSubscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChartSubscription {
    return new ChartSubscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChartSubscription {
    return new ChartSubscription().fromJsonString(jsonString, options);
  }

  static equals(a: ChartSubscription | PlainMessage<ChartSubscription> | undefined, b: ChartSubscription | PlainMessage<ChartSubscription> | undefined): boolean {
    return proto2.util.equals(ChartSubscription, a, b);
  }
}

/**
 * Environment is the Kargo API's main type.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Environment
 */
export class Environment extends Message<Environment> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec describes the sources of material used by the Environment and how
   * to incorporate newly observed materials into the Environment.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.EnvironmentSpec spec = 2;
   */
  spec?: EnvironmentSpec;

  /**
   * Status describes the most recently observed versions of this Environment's
   * sources of material as well as the environment's current and recent states.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.EnvironmentStatus status = 3;
   */
  status?: EnvironmentStatus;

  constructor(data?: PartialMessage<Environment>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Environment";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ObjectMeta, opt: true },
    { no: 2, name: "spec", kind: "message", T: EnvironmentSpec, opt: true },
    { no: 3, name: "status", kind: "message", T: EnvironmentStatus, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Environment {
    return new Environment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Environment {
    return new Environment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Environment {
    return new Environment().fromJsonString(jsonString, options);
  }

  static equals(a: Environment | PlainMessage<Environment> | undefined, b: Environment | PlainMessage<Environment> | undefined): boolean {
    return proto2.util.equals(Environment, a, b);
  }
}

/**
 * EnvironmentList is a list of Environment resources.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.EnvironmentList
 */
export class EnvironmentList extends Message<EnvironmentList> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Environment items = 2;
   */
  items: Environment[] = [];

  constructor(data?: PartialMessage<EnvironmentList>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.EnvironmentList";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ListMeta, opt: true },
    { no: 2, name: "items", kind: "message", T: Environment, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvironmentList {
    return new EnvironmentList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvironmentList {
    return new EnvironmentList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvironmentList {
    return new EnvironmentList().fromJsonString(jsonString, options);
  }

  static equals(a: EnvironmentList | PlainMessage<EnvironmentList> | undefined, b: EnvironmentList | PlainMessage<EnvironmentList> | undefined): boolean {
    return proto2.util.equals(EnvironmentList, a, b);
  }
}

/**
 * EnvironmentSpec describes the sources of material used by an Environment and
 * how to incorporate newly observed materials into the Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.EnvironmentSpec
 */
export class EnvironmentSpec extends Message<EnvironmentSpec> {
  /**
   * Subscriptions describes the Environment's sources of material. This is a
   * required field.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.Subscriptions subscriptions = 1;
   */
  subscriptions?: Subscriptions;

  /**
   * PromotionMechanisms describes how to incorporate newly observed materials
   * into the Environment. This is a required field.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionMechanisms promotionMechanisms = 2;
   */
  promotionMechanisms?: PromotionMechanisms;

  /**
   * HealthChecks describes how the health of the Environment can be assessed on
   * an ongoing basis. This is a required field.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.HealthChecks healthChecks = 3;
   */
  healthChecks?: HealthChecks;

  constructor(data?: PartialMessage<EnvironmentSpec>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.EnvironmentSpec";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "subscriptions", kind: "message", T: Subscriptions, opt: true },
    { no: 2, name: "promotionMechanisms", kind: "message", T: PromotionMechanisms, opt: true },
    { no: 3, name: "healthChecks", kind: "message", T: HealthChecks, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvironmentSpec {
    return new EnvironmentSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvironmentSpec {
    return new EnvironmentSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvironmentSpec {
    return new EnvironmentSpec().fromJsonString(jsonString, options);
  }

  static equals(a: EnvironmentSpec | PlainMessage<EnvironmentSpec> | undefined, b: EnvironmentSpec | PlainMessage<EnvironmentSpec> | undefined): boolean {
    return proto2.util.equals(EnvironmentSpec, a, b);
  }
}

/**
 * EnvironmentState is a "bill of materials" describing what was deployed to an
 * Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.EnvironmentState
 */
export class EnvironmentState extends Message<EnvironmentState> {
  /**
   * ID is a unique, system-assigned identifier for this state.
   *
   * @generated from field: optional string id = 1;
   */
  id?: string;

  /**
   * FirstSeen represents the date/time when this EnvironmentState first entered
   * the system. This is useful and important information because it enables the
   * controller to block auto-promotion of EnvironmentStates that are older than
   * an Environment's current state, which is a case that can arise if an
   * Environment has ROLLED BACK to an older state whilst a downstream
   * Environment is already on to a newer state.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time firstSeen = 2;
   */
  firstSeen?: Time;

  /**
   * Provenance describes the proximate source of this EnvironmentState. i.e.
   * Did it come directly from upstream repositories? Or an upstream
   * environment.
   *
   * @generated from field: optional string provenance = 3;
   */
  provenance?: string;

  /**
   * Commits describes specific Git repository commits that were used in this
   * state.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.GitCommit commits = 4;
   */
  commits: GitCommit[] = [];

  /**
   * Images describes container images and versions thereof that were used
   * in this state.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Image images = 5;
   */
  images: Image[] = [];

  /**
   * Charts describes Helm charts that were used in this state.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Chart charts = 6;
   */
  charts: Chart[] = [];

  /**
   * Health is the state's last observed health. If this state is the
   * Environment's current state, this will be continuously re-assessed and
   * updated. If this state is a past state of the Environment, this field will
   * denote the last observed health state before transitioning into a different
   * state.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.Health health = 7;
   */
  health?: Health;

  constructor(data?: PartialMessage<EnvironmentState>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.EnvironmentState";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "firstSeen", kind: "message", T: Time, opt: true },
    { no: 3, name: "provenance", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "commits", kind: "message", T: GitCommit, repeated: true },
    { no: 5, name: "images", kind: "message", T: Image, repeated: true },
    { no: 6, name: "charts", kind: "message", T: Chart, repeated: true },
    { no: 7, name: "health", kind: "message", T: Health, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvironmentState {
    return new EnvironmentState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvironmentState {
    return new EnvironmentState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvironmentState {
    return new EnvironmentState().fromJsonString(jsonString, options);
  }

  static equals(a: EnvironmentState | PlainMessage<EnvironmentState> | undefined, b: EnvironmentState | PlainMessage<EnvironmentState> | undefined): boolean {
    return proto2.util.equals(EnvironmentState, a, b);
  }
}

/**
 * EnvironmentStatus describes the most recently observed versions of an
 * Environment's sources of material as well as its current and recent states.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.EnvironmentStatus
 */
export class EnvironmentStatus extends Message<EnvironmentStatus> {
  /**
   * AvailableStates is a stack of available Environment states, where each
   * state is essentially a "bill of materials" describing what can be
   * automatically or manually deployed to the Environment.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.EnvironmentState availableStates = 1;
   */
  availableStates: EnvironmentState[] = [];

  /**
   * CurrentState is the Environment's current state -- a "bill of materials"
   * describing what is currently deployed to the Environment.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.EnvironmentState currentState = 2;
   */
  currentState?: EnvironmentState;

  /**
   * History is a stack of recent Environment states, where each state is
   * essentially a "bill of materials" describing what was deployed to the
   * Environment. By default, the last ten states are stored.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.EnvironmentState history = 3;
   */
  history: EnvironmentState[] = [];

  /**
   * Error describes any errors that are preventing the Environment controller
   * from assessing Environment health, polling repositories or upstream
   * environments to discover new states, or promoting the environment to a new
   * state.
   *
   * @generated from field: optional string error = 4;
   */
  error?: string;

  constructor(data?: PartialMessage<EnvironmentStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.EnvironmentStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "availableStates", kind: "message", T: EnvironmentState, repeated: true },
    { no: 2, name: "currentState", kind: "message", T: EnvironmentState, opt: true },
    { no: 3, name: "history", kind: "message", T: EnvironmentState, repeated: true },
    { no: 4, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvironmentStatus {
    return new EnvironmentStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvironmentStatus {
    return new EnvironmentStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvironmentStatus {
    return new EnvironmentStatus().fromJsonString(jsonString, options);
  }

  static equals(a: EnvironmentStatus | PlainMessage<EnvironmentStatus> | undefined, b: EnvironmentStatus | PlainMessage<EnvironmentStatus> | undefined): boolean {
    return proto2.util.equals(EnvironmentStatus, a, b);
  }
}

/**
 * EnvironmentSubscription defines a subscription to states from another
 * Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.EnvironmentSubscription
 */
export class EnvironmentSubscription extends Message<EnvironmentSubscription> {
  /**
   * Name specifies the name of an Environment.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * Namespace specifies the namespace of the Environment. If left unspecified,
   * the namespace of the upstream repository will be defaulted to that of this
   * Environment.
   *
   * +kubebuilder:validation:Optional
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string namespace = 2;
   */
  namespace?: string;

  constructor(data?: PartialMessage<EnvironmentSubscription>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.EnvironmentSubscription";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvironmentSubscription {
    return new EnvironmentSubscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvironmentSubscription {
    return new EnvironmentSubscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvironmentSubscription {
    return new EnvironmentSubscription().fromJsonString(jsonString, options);
  }

  static equals(a: EnvironmentSubscription | PlainMessage<EnvironmentSubscription> | undefined, b: EnvironmentSubscription | PlainMessage<EnvironmentSubscription> | undefined): boolean {
    return proto2.util.equals(EnvironmentSubscription, a, b);
  }
}

/**
 * GitCommit describes a specific commit from a specific Git repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitCommit
 */
export class GitCommit extends Message<GitCommit> {
  /**
   * RepoURL is the URL of a Git repository.
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * ID is the ID of a specific commit in the Git repository specified by
   * RepoURL.
   *
   * @generated from field: optional string id = 2;
   */
  id?: string;

  /**
   * Branch denotes the branch of the repository where this commit was found.
   *
   * @generated from field: optional string branch = 3;
   */
  branch?: string;

  /**
   * HealthCheckCommit is the ID of a specific commit. When specified,
   * assessments of Environment health will used this value (instead of ID) when
   * determining if applicable sources of Argo CD Application resources
   * associated with the environment are or are not synced to this commit. Note
   * that there are cases (as in that of Bookkeeper being utilized as a
   * promotion mechanism) wherein the value of this field may differ from the
   * commit ID found in the ID field.
   *
   * @generated from field: optional string healthCheckCommit = 4;
   */
  healthCheckCommit?: string;

  constructor(data?: PartialMessage<GitCommit>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitCommit";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "branch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "healthCheckCommit", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitCommit {
    return new GitCommit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitCommit {
    return new GitCommit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitCommit {
    return new GitCommit().fromJsonString(jsonString, options);
  }

  static equals(a: GitCommit | PlainMessage<GitCommit> | undefined, b: GitCommit | PlainMessage<GitCommit> | undefined): boolean {
    return proto2.util.equals(GitCommit, a, b);
  }
}

/**
 * GitRepoUpdate describes updates that should be applied to a Git repository
 * (using various configuration management tools) to incorporate newly observed
 * materials into an Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitRepoUpdate
 */
export class GitRepoUpdate extends Message<GitRepoUpdate> {
  /**
   * RepoURL is the URL of the repository to update. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^((https?://)|([\w-]+@))([\w\d\.]+)(:[\d]+)?/(.*)$`
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * ReadBranch specifies a particular branch of the repository from which to
   * locate contents that will be written to the branch specified by the
   * WriteBranch field. This field is optional. In cases where an
   * EnvironmentState includes a GitCommit, that commit's ID will supersede the
   * value of this field. Therefore, in practice, this field is only used to
   * clarify what branch of a repository can be treated as a source of manifests
   * or other configuration when an Environment has no subscription to that
   * repository.
   *
   * +kubebuilder:validation:Optional
   * +kubebuilder:validation:Pattern=`^(\w+([-/]\w+)*)?$`
   *
   * @generated from field: optional string readBranch = 2;
   */
  readBranch?: string;

  /**
   * WriteBranch specifies the particular branch of the repository to be
   * updated. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^\w+([-/]\w+)*$`
   *
   * @generated from field: optional string writeBranch = 3;
   */
  writeBranch?: string;

  /**
   * Bookkeeper describes how to use Bookkeeper to incorporate newly observed
   * materials into the Environment. This is mutually exclusive with the
   * Kustomize and Helm fields.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.BookkeeperPromotionMechanism bookkeeper = 4;
   */
  bookkeeper?: BookkeeperPromotionMechanism;

  /**
   * Kustomize describes how to use Kustomize to incorporate newly observed
   * materials into the Environment. This is mutually exclusive with the
   * Bookkeeper and Helm fields.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.KustomizePromotionMechanism kustomize = 5;
   */
  kustomize?: KustomizePromotionMechanism;

  /**
   * Helm describes how to use Helm to incorporate newly observed materials into
   * the Environment. This is mutually exclusive with the Bookkeeper and
   * Kustomize fields.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.HelmPromotionMechanism helm = 6;
   */
  helm?: HelmPromotionMechanism;

  constructor(data?: PartialMessage<GitRepoUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitRepoUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "readBranch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "writeBranch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "bookkeeper", kind: "message", T: BookkeeperPromotionMechanism, opt: true },
    { no: 5, name: "kustomize", kind: "message", T: KustomizePromotionMechanism, opt: true },
    { no: 6, name: "helm", kind: "message", T: HelmPromotionMechanism, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitRepoUpdate {
    return new GitRepoUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitRepoUpdate {
    return new GitRepoUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitRepoUpdate {
    return new GitRepoUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: GitRepoUpdate | PlainMessage<GitRepoUpdate> | undefined, b: GitRepoUpdate | PlainMessage<GitRepoUpdate> | undefined): boolean {
    return proto2.util.equals(GitRepoUpdate, a, b);
  }
}

/**
 * GitSubscription defines a subscription to a Git repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitSubscription
 */
export class GitSubscription extends Message<GitSubscription> {
  /**
   * URL is the repository's URL. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^((https?://)|([\w-]+@))([\w\d\.]+)(:[\d]+)?/(.*)$`
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Branch references a particular branch of the repository. This is a required
   * field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^\w+([-/]\w+)*$`
   *
   * @generated from field: optional string branch = 2;
   */
  branch?: string;

  constructor(data?: PartialMessage<GitSubscription>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitSubscription";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "branch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitSubscription {
    return new GitSubscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitSubscription {
    return new GitSubscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitSubscription {
    return new GitSubscription().fromJsonString(jsonString, options);
  }

  static equals(a: GitSubscription | PlainMessage<GitSubscription> | undefined, b: GitSubscription | PlainMessage<GitSubscription> | undefined): boolean {
    return proto2.util.equals(GitSubscription, a, b);
  }
}

/**
 * Health describes the health of an Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Health
 */
export class Health extends Message<Health> {
  /**
   * Status describes the health of the Environment.
   *
   * @generated from field: optional string status = 1;
   */
  status?: string;

  /**
   * StatusReason clarifies why an Environment in any state other than Healthy
   * is in that state. The value of this field will always be the empty string
   * when an Environment is Healthy.
   *
   * @generated from field: optional string statusReason = 2;
   */
  statusReason?: string;

  constructor(data?: PartialMessage<Health>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Health";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "statusReason", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Health {
    return new Health().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Health {
    return new Health().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Health {
    return new Health().fromJsonString(jsonString, options);
  }

  static equals(a: Health | PlainMessage<Health> | undefined, b: Health | PlainMessage<Health> | undefined): boolean {
    return proto2.util.equals(Health, a, b);
  }
}

/**
 * HealthChecks describes how the health of an Environment can be assessed on an
 * ongoing basis.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.HealthChecks
 */
export class HealthChecks extends Message<HealthChecks> {
  /**
   * ArgoCDAppChecks specifies Argo CD Application resources whose sync status
   * and health should be evaluated in assessing the health of the Environment.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDAppCheck argoCDAppChecks = 1;
   */
  argoCDAppChecks: ArgoCDAppCheck[] = [];

  constructor(data?: PartialMessage<HealthChecks>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.HealthChecks";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "argoCDAppChecks", kind: "message", T: ArgoCDAppCheck, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthChecks {
    return new HealthChecks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthChecks {
    return new HealthChecks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthChecks {
    return new HealthChecks().fromJsonString(jsonString, options);
  }

  static equals(a: HealthChecks | PlainMessage<HealthChecks> | undefined, b: HealthChecks | PlainMessage<HealthChecks> | undefined): boolean {
    return proto2.util.equals(HealthChecks, a, b);
  }
}

/**
 * HelmChartDependencyUpdate describes how a specific Helm chart that is used
 * as a subchart of an umbrella chart can be updated.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.HelmChartDependencyUpdate
 */
export class HelmChartDependencyUpdate extends Message<HelmChartDependencyUpdate> {
  /**
   * RegistryURL along with Name identify a subchart of the umbrella chart at
   * ChartPath whose version should be updated.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^(((https?)|(oci))://)([\w\d\.]+)(:[\d]+)?(/.*)*$`
   *
   * @generated from field: optional string registryURL = 1;
   */
  registryURL?: string;

  /**
   * Name along with RegistryURL identify a subchart of the umbrella chart at
   * ChartPath whose version should be updated.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * ChartPath is the path to an umbrella chart.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[\w-\.]+(/[\w-\.]+)*$
   *
   * @generated from field: optional string chartPath = 3;
   */
  chartPath?: string;

  constructor(data?: PartialMessage<HelmChartDependencyUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.HelmChartDependencyUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "registryURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "chartPath", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HelmChartDependencyUpdate {
    return new HelmChartDependencyUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HelmChartDependencyUpdate {
    return new HelmChartDependencyUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HelmChartDependencyUpdate {
    return new HelmChartDependencyUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: HelmChartDependencyUpdate | PlainMessage<HelmChartDependencyUpdate> | undefined, b: HelmChartDependencyUpdate | PlainMessage<HelmChartDependencyUpdate> | undefined): boolean {
    return proto2.util.equals(HelmChartDependencyUpdate, a, b);
  }
}

/**
 * HelmImageUpdate describes how a specific image version can be incorporated
 * into a specific Helm values file.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.HelmImageUpdate
 */
export class HelmImageUpdate extends Message<HelmImageUpdate> {
  /**
   * Image specifies a container image (without tag). This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^(([\w\d\.]+)(:[\d]+)?/)?[a-z0-9]+(/[a-z0-9]+)*$`
   *
   * @generated from field: optional string image = 1;
   */
  image?: string;

  /**
   * ValuesFilePath specifies a path to the Helm values file that is to be
   * updated. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[\w-\.]+(/[\w-\.]+)*$
   *
   * @generated from field: optional string valuesFilePath = 2;
   */
  valuesFilePath?: string;

  /**
   * Key specifies a key within the Helm values file that is to be updated. This
   * is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string key = 3;
   */
  key?: string;

  /**
   * Value specifies the new value for the specified key in the specified Helm
   * values file. Valid values are "Image", which replaces the value of the
   * specified key with the entire <image name>:<tag>, or "Tag" which replaces
   * the value of the specified with just the new tag. This is a required field.
   *
   * @generated from field: optional string value = 4;
   */
  value?: string;

  constructor(data?: PartialMessage<HelmImageUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.HelmImageUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "valuesFilePath", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HelmImageUpdate {
    return new HelmImageUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HelmImageUpdate {
    return new HelmImageUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HelmImageUpdate {
    return new HelmImageUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: HelmImageUpdate | PlainMessage<HelmImageUpdate> | undefined, b: HelmImageUpdate | PlainMessage<HelmImageUpdate> | undefined): boolean {
    return proto2.util.equals(HelmImageUpdate, a, b);
  }
}

/**
 * HelmPromotionMechanism describes how to use Helm to incorporate newly
 * observed materials into an Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.HelmPromotionMechanism
 */
export class HelmPromotionMechanism extends Message<HelmPromotionMechanism> {
  /**
   * Images describes how specific image versions can be incorporated into Helm
   * values files.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.HelmImageUpdate images = 1;
   */
  images: HelmImageUpdate[] = [];

  /**
   * Charts describes how specific chart versions can be incorporated into an
   * umbrella chart.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.HelmChartDependencyUpdate charts = 2;
   */
  charts: HelmChartDependencyUpdate[] = [];

  constructor(data?: PartialMessage<HelmPromotionMechanism>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.HelmPromotionMechanism";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "message", T: HelmImageUpdate, repeated: true },
    { no: 2, name: "charts", kind: "message", T: HelmChartDependencyUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HelmPromotionMechanism {
    return new HelmPromotionMechanism().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HelmPromotionMechanism {
    return new HelmPromotionMechanism().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HelmPromotionMechanism {
    return new HelmPromotionMechanism().fromJsonString(jsonString, options);
  }

  static equals(a: HelmPromotionMechanism | PlainMessage<HelmPromotionMechanism> | undefined, b: HelmPromotionMechanism | PlainMessage<HelmPromotionMechanism> | undefined): boolean {
    return proto2.util.equals(HelmPromotionMechanism, a, b);
  }
}

/**
 * Image describes a specific version of a container image.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Image
 */
export class Image extends Message<Image> {
  /**
   * RepoURL describes the repository in which the image can be found.
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Tag identifies a specific version of the image in the repository specified
   * by RepoURL.
   *
   * @generated from field: optional string tag = 2;
   */
  tag?: string;

  constructor(data?: PartialMessage<Image>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Image";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Image {
    return new Image().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Image {
    return new Image().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Image {
    return new Image().fromJsonString(jsonString, options);
  }

  static equals(a: Image | PlainMessage<Image> | undefined, b: Image | PlainMessage<Image> | undefined): boolean {
    return proto2.util.equals(Image, a, b);
  }
}

/**
 * ImageSubscription defines a subscription to an image repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ImageSubscription
 */
export class ImageSubscription extends Message<ImageSubscription> {
  /**
   * RepoURL specifies the URL of the image repository to subscribe to. The
   * value in this field MUST NOT include an image tag. This field is required.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^(([\w\d\.]+)(:[\d]+)?/)?[a-z0-9]+(/[a-z0-9]+)*$`
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * UpdateStrategy specifies the rules for how to identify the newest version
   * of the image specified by the RepoURL field. This field is optional. When
   * left unspecified, the field is implicitly treated as if its value were
   * "SemVer".
   *
   * +kubebuilder:default=SemVer
   *
   * @generated from field: optional string updateStrategy = 2;
   */
  updateStrategy?: string;

  /**
   * SemverConstraint specifies constraints on what new image versions are
   * permissible. This value in this field only has any effect when the
   * UpdateStrategy is SemVer or left unspecified (which is implicitly the same
   * as SemVer). This field is also optional. When left unspecified, (and the
   * UpdateStrategy is SemVer or unspecified), there will be no constraints,
   * which means the latest semantically tagged version of an image will always
   * be used. Care should be taken with leaving this field unspecified, as it
   * can lead to the unanticipated rollout of breaking changes. Refer to Image
   * Updater documentation for more details.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string semverConstraint = 3;
   */
  semverConstraint?: string;

  /**
   * AllowTags is a regular expression that can optionally be used to limit the
   * image tags that are considered in determining the newest version of an
   * image. This field is optional.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string allowTags = 4;
   */
  allowTags?: string;

  /**
   * IgnoreTags is a list of tags that must be ignored when determining the
   * newest version of an image. No regular expressions or glob patterns are
   * supported yet. This field is optional.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: repeated string ignoreTags = 5;
   */
  ignoreTags: string[] = [];

  /**
   * Platform is a string of the form <os>/<arch> that limits the tags that can
   * be considered when searching for new versions of an image. This field is
   * optional. When left unspecified, it is implicitly equivalent to the
   * OS/architecture of the Kargo controller. Care should be taken to set this
   * value correctly in cases where the image referenced by this
   * ImageRepositorySubscription will run on a Kubernetes node with a different
   * OS/architecture than the Kargo controller. At present this is uncommon, but
   * not unheard of.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string platform = 6;
   */
  platform?: string;

  constructor(data?: PartialMessage<ImageSubscription>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ImageSubscription";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "updateStrategy", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "semverConstraint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "allowTags", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "ignoreTags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "platform", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageSubscription {
    return new ImageSubscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageSubscription {
    return new ImageSubscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageSubscription {
    return new ImageSubscription().fromJsonString(jsonString, options);
  }

  static equals(a: ImageSubscription | PlainMessage<ImageSubscription> | undefined, b: ImageSubscription | PlainMessage<ImageSubscription> | undefined): boolean {
    return proto2.util.equals(ImageSubscription, a, b);
  }
}

/**
 * KustomizeImageUpdate describes how to run `kustomize edit set image`
 * for a given image.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.KustomizeImageUpdate
 */
export class KustomizeImageUpdate extends Message<KustomizeImageUpdate> {
  /**
   * Image specifies a container image (without tag). This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string image = 1;
   */
  image?: string;

  /**
   * Path specifies a path in which the `kustomize edit set image` command
   * should be executed. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[\w-\.]+(/[\w-\.]+)*$
   *
   * @generated from field: optional string path = 2;
   */
  path?: string;

  constructor(data?: PartialMessage<KustomizeImageUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.KustomizeImageUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KustomizeImageUpdate {
    return new KustomizeImageUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KustomizeImageUpdate {
    return new KustomizeImageUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KustomizeImageUpdate {
    return new KustomizeImageUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: KustomizeImageUpdate | PlainMessage<KustomizeImageUpdate> | undefined, b: KustomizeImageUpdate | PlainMessage<KustomizeImageUpdate> | undefined): boolean {
    return proto2.util.equals(KustomizeImageUpdate, a, b);
  }
}

/**
 * KustomizePromotionMechanism describes how to use Kustomize to incorporate
 * newly observed materials into an Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.KustomizePromotionMechanism
 */
export class KustomizePromotionMechanism extends Message<KustomizePromotionMechanism> {
  /**
   * Images describes images for which `kustomize edit set image` should be
   * executed and the paths in which those commands should be executed.
   *
   * +kubebuilder:validation:MinItems=1
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.KustomizeImageUpdate images = 1;
   */
  images: KustomizeImageUpdate[] = [];

  constructor(data?: PartialMessage<KustomizePromotionMechanism>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.KustomizePromotionMechanism";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "message", T: KustomizeImageUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KustomizePromotionMechanism {
    return new KustomizePromotionMechanism().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KustomizePromotionMechanism {
    return new KustomizePromotionMechanism().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KustomizePromotionMechanism {
    return new KustomizePromotionMechanism().fromJsonString(jsonString, options);
  }

  static equals(a: KustomizePromotionMechanism | PlainMessage<KustomizePromotionMechanism> | undefined, b: KustomizePromotionMechanism | PlainMessage<KustomizePromotionMechanism> | undefined): boolean {
    return proto2.util.equals(KustomizePromotionMechanism, a, b);
  }
}

/**
 * Promotion represents a request to transition a particular Environment into a
 * particular state.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Promotion
 */
export class Promotion extends Message<Promotion> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec describes the desired transition of a specific Environment into a
   * specific EnvironmentState.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionSpec spec = 2;
   */
  spec?: PromotionSpec;

  /**
   * Status describes the current state of the transition represented by this
   * Promotion.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionStatus status = 3;
   */
  status?: PromotionStatus;

  constructor(data?: PartialMessage<Promotion>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Promotion";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ObjectMeta, opt: true },
    { no: 2, name: "spec", kind: "message", T: PromotionSpec, opt: true },
    { no: 3, name: "status", kind: "message", T: PromotionStatus, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Promotion {
    return new Promotion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Promotion {
    return new Promotion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Promotion {
    return new Promotion().fromJsonString(jsonString, options);
  }

  static equals(a: Promotion | PlainMessage<Promotion> | undefined, b: Promotion | PlainMessage<Promotion> | undefined): boolean {
    return proto2.util.equals(Promotion, a, b);
  }
}

/**
 * PromotionList contains a list of Promotion
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionList
 */
export class PromotionList extends Message<PromotionList> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Promotion items = 2;
   */
  items: Promotion[] = [];

  constructor(data?: PartialMessage<PromotionList>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionList";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ListMeta, opt: true },
    { no: 2, name: "items", kind: "message", T: Promotion, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionList {
    return new PromotionList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionList {
    return new PromotionList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionList {
    return new PromotionList().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionList | PlainMessage<PromotionList> | undefined, b: PromotionList | PlainMessage<PromotionList> | undefined): boolean {
    return proto2.util.equals(PromotionList, a, b);
  }
}

/**
 * PromotionMechanisms describes how to incorporate newly observed materials
 * into an Environment.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionMechanisms
 */
export class PromotionMechanisms extends Message<PromotionMechanisms> {
  /**
   * GitRepoUpdates describes updates that should be applied to Git repositories
   * to incorporate newly observed materials into the Environment. This field is
   * optional, as such actions are not required in all cases.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.GitRepoUpdate gitRepoUpdates = 1;
   */
  gitRepoUpdates: GitRepoUpdate[] = [];

  /**
   * ArgoCDAppUpdates describes updates that should be applied to Argo CD
   * Application resources to incorporate newly observed materials into the
   * Environment. This field is optional, as such actions are not required in
   * all cases. Note that all updates specified by the GitRepoUpdates field, if
   * any, are applied BEFORE these.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDAppUpdate argoCDAppUpdates = 2;
   */
  argoCDAppUpdates: ArgoCDAppUpdate[] = [];

  constructor(data?: PartialMessage<PromotionMechanisms>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionMechanisms";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "gitRepoUpdates", kind: "message", T: GitRepoUpdate, repeated: true },
    { no: 2, name: "argoCDAppUpdates", kind: "message", T: ArgoCDAppUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionMechanisms {
    return new PromotionMechanisms().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionMechanisms {
    return new PromotionMechanisms().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionMechanisms {
    return new PromotionMechanisms().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionMechanisms | PlainMessage<PromotionMechanisms> | undefined, b: PromotionMechanisms | PlainMessage<PromotionMechanisms> | undefined): boolean {
    return proto2.util.equals(PromotionMechanisms, a, b);
  }
}

/**
 * PromotionPolicy provides fine-grained access control beyond what Kubernetes
 * RBAC is capable of. A PromotionPolicy names an Environment and enumerates
 * subjects (such as users, groups, ServiceAccounts, or RBAC Roles) that are
 * authorized to create Promotions for that Environment. It is through
 * PromotionPolicies that multiple users may be permitted to create Promotion
 * resources in a given namespace, but creation of Promotion resources for
 * specific Environments may be restricted.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionPolicy
 */
export class PromotionPolicy extends Message<PromotionPolicy> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Environment references an Environment in the same namespace as this
   * PromotionPolicy to which this PromotionPolicy applies.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string environment = 2;
   */
  environment?: string;

  /**
   * AuthorizedPromoters enumerates subjects (such as users, groups,
   * ServiceAccounts, or RBAC Roles) that are authorized to create Promotions
   * for the Environment referenced by the Environment field.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.AuthorizedPromoter authorizedPromoters = 3;
   */
  authorizedPromoters: AuthorizedPromoter[] = [];

  /**
   * EnableAutoPromotion indicates whether new EnvironmentStates can
   * automatically be promoted into the Environment referenced by the
   * Environment field. Note: There are other conditions also required for an
   * auto-promotion to occur. Specifically, there must be a single source of new
   * EnvironmentStates, so regardless of the value of this field, an
   * auto-promotion could never occur for an Environment subscribed to MULTIPLE
   * upstream environments. This field defaults to false, but is commonly set to
   * true for Environments that subscribe to repositories instead of other,
   * upstream Environments. This allows users to define Environments that are
   * automatically updated as soon as new materials are detected.
   *
   * @generated from field: optional bool enableAutoPromotion = 4;
   */
  enableAutoPromotion?: boolean;

  constructor(data?: PartialMessage<PromotionPolicy>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionPolicy";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ObjectMeta, opt: true },
    { no: 2, name: "environment", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "authorizedPromoters", kind: "message", T: AuthorizedPromoter, repeated: true },
    { no: 4, name: "enableAutoPromotion", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionPolicy {
    return new PromotionPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionPolicy {
    return new PromotionPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionPolicy {
    return new PromotionPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionPolicy | PlainMessage<PromotionPolicy> | undefined, b: PromotionPolicy | PlainMessage<PromotionPolicy> | undefined): boolean {
    return proto2.util.equals(PromotionPolicy, a, b);
  }
}

/**
 * PromotionPolicyList contains a list of PromotionPolicies
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionPolicyList
 */
export class PromotionPolicyList extends Message<PromotionPolicyList> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.PromotionPolicy items = 2;
   */
  items: PromotionPolicy[] = [];

  constructor(data?: PartialMessage<PromotionPolicyList>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionPolicyList";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ListMeta, opt: true },
    { no: 2, name: "items", kind: "message", T: PromotionPolicy, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionPolicyList {
    return new PromotionPolicyList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionPolicyList {
    return new PromotionPolicyList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionPolicyList {
    return new PromotionPolicyList().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionPolicyList | PlainMessage<PromotionPolicyList> | undefined, b: PromotionPolicyList | PlainMessage<PromotionPolicyList> | undefined): boolean {
    return proto2.util.equals(PromotionPolicyList, a, b);
  }
}

/**
 * PromotionSpec describes the desired transition of a specific Environment into
 * a specific EnvironmentState.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionSpec
 */
export class PromotionSpec extends Message<PromotionSpec> {
  /**
   * Environment specifies the name of the Environment to which this Promotion
   * applies. The Environment referenced by this field MUST be in the same
   * namespace as the Promotion.
   *
   * TODO: Use a webhook to make this immutable
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string environment = 1;
   */
  environment?: string;

  /**
   * State specifies the specific EnvironmentState into which the Environment
   * referenced by the Environment field should be transitioned. The State MUST
   * be among the Environment's Status.AvailableStates or the Promotion will
   * ultimately fail.
   *
   * TODO: Use a webhook to make this immutable
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string state = 2;
   */
  state?: string;

  constructor(data?: PartialMessage<PromotionSpec>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionSpec";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "environment", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "state", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionSpec {
    return new PromotionSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionSpec {
    return new PromotionSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionSpec {
    return new PromotionSpec().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionSpec | PlainMessage<PromotionSpec> | undefined, b: PromotionSpec | PlainMessage<PromotionSpec> | undefined): boolean {
    return proto2.util.equals(PromotionSpec, a, b);
  }
}

/**
 * PromotionStatus describes the current state of the transition represented by
 * a Promotion.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionStatus
 */
export class PromotionStatus extends Message<PromotionStatus> {
  /**
   * Phase describes where the Promotion currently is in its lifecycle.
   *
   * @generated from field: optional string phase = 1;
   */
  phase?: string;

  /**
   * Error describes any errors that are preventing the Promotion controller
   * from executing this Promotion. i.e. If the Phase field has a value of
   * Failed, this field can be expected to explain why.
   *
   * @generated from field: optional string error = 2;
   */
  error?: string;

  constructor(data?: PartialMessage<PromotionStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "phase", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionStatus {
    return new PromotionStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionStatus {
    return new PromotionStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionStatus {
    return new PromotionStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionStatus | PlainMessage<PromotionStatus> | undefined, b: PromotionStatus | PlainMessage<PromotionStatus> | undefined): boolean {
    return proto2.util.equals(PromotionStatus, a, b);
  }
}

/**
 * RepoSubscriptions describes various sorts of repositories an Environment uses
 * as sources of material.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.RepoSubscriptions
 */
export class RepoSubscriptions extends Message<RepoSubscriptions> {
  /**
   * Git describes subscriptions to Git repositories.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.GitSubscription git = 1;
   */
  git: GitSubscription[] = [];

  /**
   * Images describes subscriptions to container image repositories.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ImageSubscription images = 2;
   */
  images: ImageSubscription[] = [];

  /**
   * Charts describes subscriptions to Helm charts.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ChartSubscription charts = 3;
   */
  charts: ChartSubscription[] = [];

  constructor(data?: PartialMessage<RepoSubscriptions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.RepoSubscriptions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "git", kind: "message", T: GitSubscription, repeated: true },
    { no: 2, name: "images", kind: "message", T: ImageSubscription, repeated: true },
    { no: 3, name: "charts", kind: "message", T: ChartSubscription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepoSubscriptions {
    return new RepoSubscriptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepoSubscriptions {
    return new RepoSubscriptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepoSubscriptions {
    return new RepoSubscriptions().fromJsonString(jsonString, options);
  }

  static equals(a: RepoSubscriptions | PlainMessage<RepoSubscriptions> | undefined, b: RepoSubscriptions | PlainMessage<RepoSubscriptions> | undefined): boolean {
    return proto2.util.equals(RepoSubscriptions, a, b);
  }
}

/**
 * Subscriptions describes an Environment's sources of material.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Subscriptions
 */
export class Subscriptions extends Message<Subscriptions> {
  /**
   * Repos describes various sorts of repositories an Environment uses as
   * sources of material. This field is mutually exclusive with the UpstreamEnvs
   * field.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.RepoSubscriptions repos = 1;
   */
  repos?: RepoSubscriptions;

  /**
   * UpstreamEnvs identifies other environments as potential sources of material
   * for the Environment. This field is mutually exclusive with the Repos field.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.EnvironmentSubscription upstreamEnvs = 2;
   */
  upstreamEnvs: EnvironmentSubscription[] = [];

  constructor(data?: PartialMessage<Subscriptions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Subscriptions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repos", kind: "message", T: RepoSubscriptions, opt: true },
    { no: 2, name: "upstreamEnvs", kind: "message", T: EnvironmentSubscription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subscriptions {
    return new Subscriptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subscriptions {
    return new Subscriptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subscriptions {
    return new Subscriptions().fromJsonString(jsonString, options);
  }

  static equals(a: Subscriptions | PlainMessage<Subscriptions> | undefined, b: Subscriptions | PlainMessage<Subscriptions> | undefined): boolean {
    return proto2.util.equals(Subscriptions, a, b);
  }
}

