// This file was autogenerated by go-to-protobuf. Do not edit it manually!

// @generated by protoc-gen-es v1.8.0 with parameter "target=ts"
// @generated from file v1alpha1/generated.proto (package github.com.akuity.kargo.api.v1alpha1, syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2 } from "@bufbuild/protobuf";
import { Condition, Duration, ListMeta, ObjectMeta, Time } from "../k8s.io/apimachinery/pkg/apis/meta/v1/generated_pb.js";

/**
 * AnalysisRunArgument represents an argument to be added to an AnalysisRun.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.AnalysisRunArgument
 */
export class AnalysisRunArgument extends Message<AnalysisRunArgument> {
  /**
   * Name is the name of the argument.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * Value is the value of the argument.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional string value = 2;
   */
  value?: string;

  constructor(data?: PartialMessage<AnalysisRunArgument>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.AnalysisRunArgument";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalysisRunArgument {
    return new AnalysisRunArgument().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalysisRunArgument {
    return new AnalysisRunArgument().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalysisRunArgument {
    return new AnalysisRunArgument().fromJsonString(jsonString, options);
  }

  static equals(a: AnalysisRunArgument | PlainMessage<AnalysisRunArgument> | undefined, b: AnalysisRunArgument | PlainMessage<AnalysisRunArgument> | undefined): boolean {
    return proto2.util.equals(AnalysisRunArgument, a, b);
  }
}

/**
 * AnalysisRunMetadata contains optional metadata that should be applied to all
 * AnalysisRuns.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.AnalysisRunMetadata
 */
export class AnalysisRunMetadata extends Message<AnalysisRunMetadata> {
  /**
   * Additional labels to apply to an AnalysisRun.
   *
   * @generated from field: map<string, string> labels = 1;
   */
  labels: { [key: string]: string } = {};

  /**
   * Additional annotations to apply to an AnalysisRun.
   *
   * @generated from field: map<string, string> annotations = 2;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<AnalysisRunMetadata>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.AnalysisRunMetadata";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalysisRunMetadata {
    return new AnalysisRunMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalysisRunMetadata {
    return new AnalysisRunMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalysisRunMetadata {
    return new AnalysisRunMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AnalysisRunMetadata | PlainMessage<AnalysisRunMetadata> | undefined, b: AnalysisRunMetadata | PlainMessage<AnalysisRunMetadata> | undefined): boolean {
    return proto2.util.equals(AnalysisRunMetadata, a, b);
  }
}

/**
 * AnalysisRunReference is a reference to an AnalysisRun.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.AnalysisRunReference
 */
export class AnalysisRunReference extends Message<AnalysisRunReference> {
  /**
   * Namespace is the namespace of the AnalysisRun.
   *
   * @generated from field: optional string namespace = 1;
   */
  namespace?: string;

  /**
   * Name is the name of the AnalysisRun.
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * Phase is the last observed phase of the AnalysisRun referenced by Name.
   *
   * @generated from field: optional string phase = 3;
   */
  phase?: string;

  constructor(data?: PartialMessage<AnalysisRunReference>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.AnalysisRunReference";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "phase", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalysisRunReference {
    return new AnalysisRunReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalysisRunReference {
    return new AnalysisRunReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalysisRunReference {
    return new AnalysisRunReference().fromJsonString(jsonString, options);
  }

  static equals(a: AnalysisRunReference | PlainMessage<AnalysisRunReference> | undefined, b: AnalysisRunReference | PlainMessage<AnalysisRunReference> | undefined): boolean {
    return proto2.util.equals(AnalysisRunReference, a, b);
  }
}

/**
 * AnalysisTemplateReference is a reference to an AnalysisTemplate.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.AnalysisTemplateReference
 */
export class AnalysisTemplateReference extends Message<AnalysisTemplateReference> {
  /**
   * Name is the name of the AnalysisTemplate in the same project/namespace as
   * the Stage.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  constructor(data?: PartialMessage<AnalysisTemplateReference>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.AnalysisTemplateReference";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalysisTemplateReference {
    return new AnalysisTemplateReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalysisTemplateReference {
    return new AnalysisTemplateReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalysisTemplateReference {
    return new AnalysisTemplateReference().fromJsonString(jsonString, options);
  }

  static equals(a: AnalysisTemplateReference | PlainMessage<AnalysisTemplateReference> | undefined, b: AnalysisTemplateReference | PlainMessage<AnalysisTemplateReference> | undefined): boolean {
    return proto2.util.equals(AnalysisTemplateReference, a, b);
  }
}

/**
 * ApprovedStage describes a Stage for which Freight has been (manually)
 * approved.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ApprovedStage
 */
export class ApprovedStage extends Message<ApprovedStage> {
  constructor(data?: PartialMessage<ApprovedStage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ApprovedStage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovedStage {
    return new ApprovedStage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovedStage {
    return new ApprovedStage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovedStage {
    return new ApprovedStage().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovedStage | PlainMessage<ApprovedStage> | undefined, b: ApprovedStage | PlainMessage<ApprovedStage> | undefined): boolean {
    return proto2.util.equals(ApprovedStage, a, b);
  }
}

/**
 * ArgoCDAppHealthStatus describes the health of an ArgoCD Application.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDAppHealthStatus
 */
export class ArgoCDAppHealthStatus extends Message<ArgoCDAppHealthStatus> {
  /**
   * @generated from field: optional string status = 1;
   */
  status?: string;

  /**
   * @generated from field: optional string message = 2;
   */
  message?: string;

  constructor(data?: PartialMessage<ArgoCDAppHealthStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDAppHealthStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDAppHealthStatus {
    return new ArgoCDAppHealthStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDAppHealthStatus {
    return new ArgoCDAppHealthStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDAppHealthStatus {
    return new ArgoCDAppHealthStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDAppHealthStatus | PlainMessage<ArgoCDAppHealthStatus> | undefined, b: ArgoCDAppHealthStatus | PlainMessage<ArgoCDAppHealthStatus> | undefined): boolean {
    return proto2.util.equals(ArgoCDAppHealthStatus, a, b);
  }
}

/**
 * ArgoCDAppStatus describes the current state of a single ArgoCD Application.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDAppStatus
 */
export class ArgoCDAppStatus extends Message<ArgoCDAppStatus> {
  /**
   * Namespace is the namespace of the ArgoCD Application.
   *
   * @generated from field: optional string namespace = 1;
   */
  namespace?: string;

  /**
   * Name is the name of the ArgoCD Application.
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * HealthStatus is the health of the ArgoCD Application.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ArgoCDAppHealthStatus healthStatus = 3;
   */
  healthStatus?: ArgoCDAppHealthStatus;

  /**
   * SyncStatus is the sync status of the ArgoCD Application.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ArgoCDAppSyncStatus syncStatus = 4;
   */
  syncStatus?: ArgoCDAppSyncStatus;

  constructor(data?: PartialMessage<ArgoCDAppStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDAppStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "healthStatus", kind: "message", T: ArgoCDAppHealthStatus, opt: true },
    { no: 4, name: "syncStatus", kind: "message", T: ArgoCDAppSyncStatus, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDAppStatus {
    return new ArgoCDAppStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDAppStatus {
    return new ArgoCDAppStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDAppStatus {
    return new ArgoCDAppStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDAppStatus | PlainMessage<ArgoCDAppStatus> | undefined, b: ArgoCDAppStatus | PlainMessage<ArgoCDAppStatus> | undefined): boolean {
    return proto2.util.equals(ArgoCDAppStatus, a, b);
  }
}

/**
 * ArgoCDAppSyncStatus describes the sync status of an ArgoCD Application.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDAppSyncStatus
 */
export class ArgoCDAppSyncStatus extends Message<ArgoCDAppSyncStatus> {
  /**
   * @generated from field: optional string status = 1;
   */
  status?: string;

  /**
   * @generated from field: optional string revision = 2;
   */
  revision?: string;

  /**
   * @generated from field: repeated string revisions = 3;
   */
  revisions: string[] = [];

  constructor(data?: PartialMessage<ArgoCDAppSyncStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDAppSyncStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "revision", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "revisions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDAppSyncStatus {
    return new ArgoCDAppSyncStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDAppSyncStatus {
    return new ArgoCDAppSyncStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDAppSyncStatus {
    return new ArgoCDAppSyncStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDAppSyncStatus | PlainMessage<ArgoCDAppSyncStatus> | undefined, b: ArgoCDAppSyncStatus | PlainMessage<ArgoCDAppSyncStatus> | undefined): boolean {
    return proto2.util.equals(ArgoCDAppSyncStatus, a, b);
  }
}

/**
 * ArgoCDAppUpdate describes updates that should be applied to an Argo CD
 * Application resources to incorporate Freight into a Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDAppUpdate
 */
export class ArgoCDAppUpdate extends Message<ArgoCDAppUpdate> {
  /**
   * AppName specifies the name of an Argo CD Application resource to be
   * updated.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string appName = 1;
   */
  appName?: string;

  /**
   * AppNamespace specifies the namespace of an Argo CD Application resource to
   * be updated. If left unspecified, the namespace of this Application resource
   * will use the value of ARGOCD_NAMESPACE or "argocd"
   *
   * +kubebuilder:validation:Optional
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string appNamespace = 2;
   */
  appNamespace?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional, but Promotions will fail if there
   * is ever ambiguity regarding which piece of Freight from which an artifact
   * is to be sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 4;
   */
  origin?: FreightOrigin;

  /**
   * SourceUpdates describes updates to be applied to various sources of the
   * specified Argo CD Application resource.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDSourceUpdate sourceUpdates = 3;
   */
  sourceUpdates: ArgoCDSourceUpdate[] = [];

  constructor(data?: PartialMessage<ArgoCDAppUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDAppUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "appName", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "appNamespace", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 3, name: "sourceUpdates", kind: "message", T: ArgoCDSourceUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDAppUpdate {
    return new ArgoCDAppUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDAppUpdate {
    return new ArgoCDAppUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDAppUpdate {
    return new ArgoCDAppUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDAppUpdate | PlainMessage<ArgoCDAppUpdate> | undefined, b: ArgoCDAppUpdate | PlainMessage<ArgoCDAppUpdate> | undefined): boolean {
    return proto2.util.equals(ArgoCDAppUpdate, a, b);
  }
}

/**
 * ArgoCDHelm describes updates to an Argo CD Application source's Helm-specific
 * attributes to incorporate newly observed Freight into a Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDHelm
 */
export class ArgoCDHelm extends Message<ArgoCDHelm> {
  /**
   * Images describes how specific image versions can be incorporated into an
   * Argo CD Application's Helm parameters.
   *
   * +kubebuilder:validation:MinItems=1
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDHelmImageUpdate images = 1;
   */
  images: ArgoCDHelmImageUpdate[] = [];

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing ArgoCDSourceUpdate's Origin
   * field. If that, too, is unspecified, Promotions will fail if there is ever
   * ambiguity regarding from which piece of Freight an artifact is to be
   * sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 2;
   */
  origin?: FreightOrigin;

  constructor(data?: PartialMessage<ArgoCDHelm>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDHelm";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "message", T: ArgoCDHelmImageUpdate, repeated: true },
    { no: 2, name: "origin", kind: "message", T: FreightOrigin, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDHelm {
    return new ArgoCDHelm().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDHelm {
    return new ArgoCDHelm().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDHelm {
    return new ArgoCDHelm().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDHelm | PlainMessage<ArgoCDHelm> | undefined, b: ArgoCDHelm | PlainMessage<ArgoCDHelm> | undefined): boolean {
    return proto2.util.equals(ArgoCDHelm, a, b);
  }
}

/**
 * ArgoCDHelmImageUpdate describes how a specific image version can be
 * incorporated into an Argo CD Application's Helm parameters.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDHelmImageUpdate
 */
export class ArgoCDHelmImageUpdate extends Message<ArgoCDHelmImageUpdate> {
  /**
   * Image specifies a container image (without tag). This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string image = 1;
   */
  image?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing ArgoCDHelm's Origin field. If
   * that, too, is unspecified, Promotions will fail if there is ever ambiguity
   * regarding from which piece of Freight an artifact is to be sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 4;
   */
  origin?: FreightOrigin;

  /**
   * Key specifies a key within an Argo CD Application's Helm parameters that is
   * to be updated. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string key = 2;
   */
  key?: string;

  /**
   * Value specifies the new value for the specified key in the Argo CD
   * Application's Helm parameters. Valid values are:
   *
   * - ImageAndTag: Replaces the value of the specified key with
   *   <image name>:<tag>
   * - Tag: Replaces the value of the specified key with just the new tag
   * - ImageAndDigest: Replaces the value of the specified key with
   *   <image name>@<digest>
   * - Digest: Replaces the value of the specified key with just the new digest.
   *
   * This is a required field.
   *
   * @generated from field: optional string value = 3;
   */
  value?: string;

  constructor(data?: PartialMessage<ArgoCDHelmImageUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDHelmImageUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDHelmImageUpdate {
    return new ArgoCDHelmImageUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDHelmImageUpdate {
    return new ArgoCDHelmImageUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDHelmImageUpdate {
    return new ArgoCDHelmImageUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDHelmImageUpdate | PlainMessage<ArgoCDHelmImageUpdate> | undefined, b: ArgoCDHelmImageUpdate | PlainMessage<ArgoCDHelmImageUpdate> | undefined): boolean {
    return proto2.util.equals(ArgoCDHelmImageUpdate, a, b);
  }
}

/**
 * ArgoCDKustomize describes updates to an Argo CD Application source's
 * Kustomize-specific attributes to incorporate newly observed Freight into a
 * Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomize
 */
export class ArgoCDKustomize extends Message<ArgoCDKustomize> {
  /**
   * Images describes how specific image versions can be incorporated into an
   * Argo CD Application's Kustomize parameters.
   *
   * +kubebuilder:validation:MinItems=1
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomizeImageUpdate images = 1;
   */
  images: ArgoCDKustomizeImageUpdate[] = [];

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing ArgoCDSourceUpdate's Origin
   * field. If that, too, is unspecified, Promotions will fail if there is ever
   * ambiguity regarding from which piece of Freight an artifact is to be
   * sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 2;
   */
  origin?: FreightOrigin;

  constructor(data?: PartialMessage<ArgoCDKustomize>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomize";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "message", T: ArgoCDKustomizeImageUpdate, repeated: true },
    { no: 2, name: "origin", kind: "message", T: FreightOrigin, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDKustomize {
    return new ArgoCDKustomize().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDKustomize {
    return new ArgoCDKustomize().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDKustomize {
    return new ArgoCDKustomize().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDKustomize | PlainMessage<ArgoCDKustomize> | undefined, b: ArgoCDKustomize | PlainMessage<ArgoCDKustomize> | undefined): boolean {
    return proto2.util.equals(ArgoCDKustomize, a, b);
  }
}

/**
 * ArgoCDKustomizeImageUpdate describes how a specific image version can be
 * incorporated into an Argo CD Application's Kustomize parameters.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomizeImageUpdate
 */
export class ArgoCDKustomizeImageUpdate extends Message<ArgoCDKustomizeImageUpdate> {
  /**
   * Image specifies a container image (without tag). This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string image = 1;
   */
  image?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing ArgoCDKustomize's Origin
   * field. If that, too, is unspecified, Promotions will fail if there is ever
   * ambiguity regarding from which piece of Freight an artifact is to be
   * sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 3;
   */
  origin?: FreightOrigin;

  /**
   * UseDigest specifies whether the image's digest should be used instead of
   * its tag.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional bool useDigest = 2;
   */
  useDigest?: boolean;

  constructor(data?: PartialMessage<ArgoCDKustomizeImageUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomizeImageUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 2, name: "useDigest", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDKustomizeImageUpdate {
    return new ArgoCDKustomizeImageUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDKustomizeImageUpdate {
    return new ArgoCDKustomizeImageUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDKustomizeImageUpdate {
    return new ArgoCDKustomizeImageUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDKustomizeImageUpdate | PlainMessage<ArgoCDKustomizeImageUpdate> | undefined, b: ArgoCDKustomizeImageUpdate | PlainMessage<ArgoCDKustomizeImageUpdate> | undefined): boolean {
    return proto2.util.equals(ArgoCDKustomizeImageUpdate, a, b);
  }
}

/**
 * ArgoCDSourceUpdate describes updates that should be applied to one of an Argo
 * CD Application resource's sources.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ArgoCDSourceUpdate
 */
export class ArgoCDSourceUpdate extends Message<ArgoCDSourceUpdate> {
  /**
   * RepoURL along with the Chart field identifies which of an Argo CD
   * Application's sources this update is intended for. Note: As of Argo CD 2.6,
   * Applications can use multiple sources. When the source to be updated
   * references a Helm chart repository, the values of the RepoURL and Chart
   * fields should exactly match the values of the fields of the same names in
   * the source. i.e. Do not match the values of these two fields to your
   * Warehouse; match them to the Application source you wish to update. This is
   * a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Chart along with the RepoURL field identifies which of an Argo CD
   * Application's sources this update is intended for. Note: As of Argo CD 2.6,
   * Applications can use multiple sources. When the source to be updated
   * references a Helm chart repository, the values of the RepoURL and Chart
   * fields should exactly match the values of the fields of the same names in
   * the source. i.e. Do not match the values of these two fields to your
   * Warehouse; match them to the Application source you wish to update.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string chart = 2;
   */
  chart?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing ArgoCDAppUpdate's Origin
   * field. If that, too, is unspecified, Promotions will fail if there is ever
   * ambiguity regarding from which piece of Freight an artifact is to be
   * sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 6;
   */
  origin?: FreightOrigin;

  /**
   * UpdateTargetRevision is a bool indicating whether the source should be
   * updated such that its TargetRevision field points at the most recently git
   * commit (if RepoURL references a git repository) or chart version (if
   * RepoURL references a chart repository).
   *
   * @generated from field: optional bool updateTargetRevision = 3;
   */
  updateTargetRevision?: boolean;

  /**
   * Kustomize describes updates to the source's Kustomize-specific attributes.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ArgoCDKustomize kustomize = 4;
   */
  kustomize?: ArgoCDKustomize;

  /**
   * Helm describes updates to the source's Helm-specific attributes.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ArgoCDHelm helm = 5;
   */
  helm?: ArgoCDHelm;

  constructor(data?: PartialMessage<ArgoCDSourceUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ArgoCDSourceUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "chart", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 3, name: "updateTargetRevision", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "kustomize", kind: "message", T: ArgoCDKustomize, opt: true },
    { no: 5, name: "helm", kind: "message", T: ArgoCDHelm, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgoCDSourceUpdate {
    return new ArgoCDSourceUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgoCDSourceUpdate {
    return new ArgoCDSourceUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgoCDSourceUpdate {
    return new ArgoCDSourceUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ArgoCDSourceUpdate | PlainMessage<ArgoCDSourceUpdate> | undefined, b: ArgoCDSourceUpdate | PlainMessage<ArgoCDSourceUpdate> | undefined): boolean {
    return proto2.util.equals(ArgoCDSourceUpdate, a, b);
  }
}

/**
 * Chart describes a specific version of a Helm chart.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Chart
 */
export class Chart extends Message<Chart> {
  /**
   * RepoURL specifies the URL of a Helm chart repository. Classic chart
   * repositories (using HTTP/S) can contain differently named charts. When this
   * field points to such a repository, the Name field will specify the name of
   * the chart within the repository. In the case of a repository within an OCI
   * registry, the URL implicitly points to a specific chart and the Name field
   * will be empty.
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Name specifies the name of the chart.
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * Version specifies a particular version of the chart.
   *
   * @generated from field: optional string version = 3;
   */
  version?: string;

  constructor(data?: PartialMessage<Chart>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Chart";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Chart {
    return new Chart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Chart {
    return new Chart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Chart {
    return new Chart().fromJsonString(jsonString, options);
  }

  static equals(a: Chart | PlainMessage<Chart> | undefined, b: Chart | PlainMessage<Chart> | undefined): boolean {
    return proto2.util.equals(Chart, a, b);
  }
}

/**
 * ChartDiscoveryResult represents the result of a chart discovery operation for
 * a ChartSubscription.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ChartDiscoveryResult
 */
export class ChartDiscoveryResult extends Message<ChartDiscoveryResult> {
  /**
   * RepoURL is the repository URL of the Helm chart, as specified in the
   * ChartSubscription.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Name is the name of the Helm chart, as specified in the ChartSubscription.
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * SemverConstraint is the constraint for which versions were discovered.
   * This field is optional, and only populated if the ChartSubscription
   * specifies a SemverConstraint.
   *
   * @generated from field: optional string semverConstraint = 3;
   */
  semverConstraint?: string;

  /**
   * Versions is a list of versions discovered by the Warehouse for the
   * ChartSubscription. An empty list indicates that the discovery operation was
   * successful, but no versions matching the ChartSubscription criteria were
   * found.
   *
   * +optional
   *
   * @generated from field: repeated string versions = 4;
   */
  versions: string[] = [];

  constructor(data?: PartialMessage<ChartDiscoveryResult>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ChartDiscoveryResult";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "semverConstraint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "versions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChartDiscoveryResult {
    return new ChartDiscoveryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChartDiscoveryResult {
    return new ChartDiscoveryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChartDiscoveryResult {
    return new ChartDiscoveryResult().fromJsonString(jsonString, options);
  }

  static equals(a: ChartDiscoveryResult | PlainMessage<ChartDiscoveryResult> | undefined, b: ChartDiscoveryResult | PlainMessage<ChartDiscoveryResult> | undefined): boolean {
    return proto2.util.equals(ChartDiscoveryResult, a, b);
  }
}

/**
 * ChartSubscription defines a subscription to a Helm chart repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ChartSubscription
 */
export class ChartSubscription extends Message<ChartSubscription> {
  /**
   * RepoURL specifies the URL of a Helm chart repository. It may be a classic
   * chart repository (using HTTP/S) OR a repository within an OCI registry.
   * Classic chart repositories can contain differently named charts. When this
   * field points to such a repository, the Name field MUST also be used
   * to specify the name of the desired chart within that repository. In the
   * case of a repository within an OCI registry, the URL implicitly points to
   * a specific chart and the Name field MUST NOT be used. The RepoURL field is
   * required.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^(((https?)|(oci))://)([\w\d\.\-]+)(:[\d]+)?(/.*)*$`
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Name specifies the name of a Helm chart to subscribe to within a classic
   * chart repository specified by the RepoURL field. This field is required
   * when the RepoURL field points to a classic chart repository and MUST
   * otherwise be empty.
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * SemverConstraint specifies constraints on what new chart versions are
   * permissible. This field is optional. When left unspecified, there will be
   * no constraints, which means the latest version of the chart will always be
   * used. Care should be taken with leaving this field unspecified, as it can
   * lead to the unanticipated rollout of breaking changes.
   * More info: https://github.com/masterminds/semver#checking-version-constraints
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string semverConstraint = 3;
   */
  semverConstraint?: string;

  /**
   * DiscoveryLimit is an optional limit on the number of chart versions that
   * can be discovered for this subscription. The limit is applied after
   * filtering charts based on the SemverConstraint field.
   * When left unspecified, the field is implicitly treated as if its value
   * were "20". The upper limit for this field is 100.
   *
   * +kubebuilder:validation:Minimum=1
   * +kubebuilder:validation:Maximum=100
   * +kubebuilder:default=20
   *
   * @generated from field: optional int32 discoveryLimit = 4;
   */
  discoveryLimit?: number;

  constructor(data?: PartialMessage<ChartSubscription>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ChartSubscription";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "semverConstraint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "discoveryLimit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChartSubscription {
    return new ChartSubscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChartSubscription {
    return new ChartSubscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChartSubscription {
    return new ChartSubscription().fromJsonString(jsonString, options);
  }

  static equals(a: ChartSubscription | PlainMessage<ChartSubscription> | undefined, b: ChartSubscription | PlainMessage<ChartSubscription> | undefined): boolean {
    return proto2.util.equals(ChartSubscription, a, b);
  }
}

/**
 * DiscoveredArtifacts holds the artifacts discovered by the Warehouse for its
 * subscriptions.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.DiscoveredArtifacts
 */
export class DiscoveredArtifacts extends Message<DiscoveredArtifacts> {
  /**
   * DiscoveredAt is the time at which the Warehouse discovered the artifacts.
   *
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time discoveredAt = 4;
   */
  discoveredAt?: Time;

  /**
   * Git holds the commits discovered by the Warehouse for the Git
   * subscriptions.
   *
   * +optional
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.GitDiscoveryResult git = 1;
   */
  git: GitDiscoveryResult[] = [];

  /**
   * Images holds the image references discovered by the Warehouse for the
   * image subscriptions.
   *
   * +optional
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ImageDiscoveryResult images = 2;
   */
  images: ImageDiscoveryResult[] = [];

  /**
   * Charts holds the charts discovered by the Warehouse for the chart
   * subscriptions.
   *
   * +optional
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ChartDiscoveryResult charts = 3;
   */
  charts: ChartDiscoveryResult[] = [];

  constructor(data?: PartialMessage<DiscoveredArtifacts>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.DiscoveredArtifacts";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 4, name: "discoveredAt", kind: "message", T: Time, opt: true },
    { no: 1, name: "git", kind: "message", T: GitDiscoveryResult, repeated: true },
    { no: 2, name: "images", kind: "message", T: ImageDiscoveryResult, repeated: true },
    { no: 3, name: "charts", kind: "message", T: ChartDiscoveryResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveredArtifacts {
    return new DiscoveredArtifacts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveredArtifacts {
    return new DiscoveredArtifacts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveredArtifacts {
    return new DiscoveredArtifacts().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveredArtifacts | PlainMessage<DiscoveredArtifacts> | undefined, b: DiscoveredArtifacts | PlainMessage<DiscoveredArtifacts> | undefined): boolean {
    return proto2.util.equals(DiscoveredArtifacts, a, b);
  }
}

/**
 * DiscoveredCommit represents a commit discovered by a Warehouse for a
 * GitSubscription.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.DiscoveredCommit
 */
export class DiscoveredCommit extends Message<DiscoveredCommit> {
  /**
   * ID is the identifier of the commit. This typically is a SHA-1 hash.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string id = 1;
   */
  id?: string;

  /**
   * Branch is the branch in which the commit was found. This field is
   * optional, and populated based on the CommitSelectionStrategy of the
   * GitSubscription.
   *
   * @generated from field: optional string branch = 2;
   */
  branch?: string;

  /**
   * Tag is the tag that resolved to this commit. This field is optional, and
   * populated based on the CommitSelectionStrategy of the GitSubscription.
   *
   * @generated from field: optional string tag = 3;
   */
  tag?: string;

  /**
   * Subject is the subject of the commit (i.e. the first line of the commit
   * message).
   *
   * @generated from field: optional string subject = 4;
   */
  subject?: string;

  /**
   * Author is the author of the commit.
   *
   * @generated from field: optional string author = 5;
   */
  author?: string;

  /**
   * Committer is the person who committed the commit.
   *
   * @generated from field: optional string committer = 6;
   */
  committer?: string;

  /**
   * CreatorDate is the commit creation date as specified by the commit, or
   * the tagger date if the commit belongs to an annotated tag.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time creatorDate = 7;
   */
  creatorDate?: Time;

  constructor(data?: PartialMessage<DiscoveredCommit>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.DiscoveredCommit";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "branch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "subject", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "author", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "committer", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "creatorDate", kind: "message", T: Time, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveredCommit {
    return new DiscoveredCommit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveredCommit {
    return new DiscoveredCommit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveredCommit {
    return new DiscoveredCommit().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveredCommit | PlainMessage<DiscoveredCommit> | undefined, b: DiscoveredCommit | PlainMessage<DiscoveredCommit> | undefined): boolean {
    return proto2.util.equals(DiscoveredCommit, a, b);
  }
}

/**
 * DiscoveredImageReference represents an image reference discovered by a
 * Warehouse for an ImageSubscription.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.DiscoveredImageReference
 */
export class DiscoveredImageReference extends Message<DiscoveredImageReference> {
  /**
   * Tag is the tag of the image.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:MaxLength=128
   * +kubebuilder:validation:Pattern=`^[\w.\-\_]+$`
   *
   * @generated from field: optional string tag = 1;
   */
  tag?: string;

  /**
   * Digest is the digest of the image.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^[a-z0-9]+:[a-f0-9]+$`
   *
   * @generated from field: optional string digest = 2;
   */
  digest?: string;

  /**
   * GitRepoURL is the URL of the Git repository that contains the source
   * code for this image. This field is optional, and only populated if the
   * ImageSubscription specifies a GitRepoURL.
   *
   * @generated from field: optional string gitRepoURL = 3;
   */
  gitRepoURL?: string;

  /**
   * CreatedAt is the time the image was created. This field is optional, and
   * not populated for every ImageSelectionStrategy.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time createdAt = 4;
   */
  createdAt?: Time;

  constructor(data?: PartialMessage<DiscoveredImageReference>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.DiscoveredImageReference";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "digest", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "gitRepoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "createdAt", kind: "message", T: Time, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveredImageReference {
    return new DiscoveredImageReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveredImageReference {
    return new DiscoveredImageReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveredImageReference {
    return new DiscoveredImageReference().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveredImageReference | PlainMessage<DiscoveredImageReference> | undefined, b: DiscoveredImageReference | PlainMessage<DiscoveredImageReference> | undefined): boolean {
    return proto2.util.equals(DiscoveredImageReference, a, b);
  }
}

/**
 * Freight represents a collection of versioned artifacts.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Freight
 */
export class Freight extends Message<Freight> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Alias is a human-friendly alias for a piece of Freight. This is an optional
   * field. A defaulting webhook will sync this field with the value of the
   * kargo.akuity.io/alias label. When the alias label is not present or differs
   * from the value of this field, the defaulting webhook will set the label to
   * the value of this field. If the alias label is present and this field is
   * empty, the defaulting webhook will set the value of this field to the value
   * of the alias label. If this field is empty and the alias label is not
   * present, the defaulting webhook will choose an available alias and assign
   * it to both the field and label.
   *
   * @generated from field: optional string alias = 7;
   */
  alias?: string;

  /**
   * Origin describes a kind of Freight in terms of its origin.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 9;
   */
  origin?: FreightOrigin;

  /**
   * Commits describes specific Git repository commits.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.GitCommit commits = 3;
   */
  commits: GitCommit[] = [];

  /**
   * Images describes specific versions of specific container images.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Image images = 4;
   */
  images: Image[] = [];

  /**
   * Charts describes specific versions of specific Helm charts.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Chart charts = 5;
   */
  charts: Chart[] = [];

  /**
   * Status describes the current status of this Freight.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightStatus status = 6;
   */
  status?: FreightStatus;

  constructor(data?: PartialMessage<Freight>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Freight";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ObjectMeta, opt: true },
    { no: 7, name: "alias", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 3, name: "commits", kind: "message", T: GitCommit, repeated: true },
    { no: 4, name: "images", kind: "message", T: Image, repeated: true },
    { no: 5, name: "charts", kind: "message", T: Chart, repeated: true },
    { no: 6, name: "status", kind: "message", T: FreightStatus, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Freight {
    return new Freight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Freight {
    return new Freight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Freight {
    return new Freight().fromJsonString(jsonString, options);
  }

  static equals(a: Freight | PlainMessage<Freight> | undefined, b: Freight | PlainMessage<Freight> | undefined): boolean {
    return proto2.util.equals(Freight, a, b);
  }
}

/**
 * FreightCollection is a collection of FreightReferences, each of which
 * represents a piece of Freight that has been selected for deployment to a
 * Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.FreightCollection
 */
export class FreightCollection extends Message<FreightCollection> {
  /**
   * ID is a unique and deterministically calculated identifier for the
   * FreightCollection. It is updated on each use of the UpdateOrPush method.
   *
   * @generated from field: optional string id = 3;
   */
  id?: string;

  /**
   * Freight is a map of FreightReference objects, indexed by their Warehouse
   * origin.
   *
   * @generated from field: map<string, github.com.akuity.kargo.api.v1alpha1.FreightReference> items = 1;
   */
  items: { [key: string]: FreightReference } = {};

  /**
   * VerificationHistory is a stack of recent VerificationInfo. By default,
   * the last ten VerificationInfo are stored.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.VerificationInfo verificationHistory = 2;
   */
  verificationHistory: VerificationInfo[] = [];

  constructor(data?: PartialMessage<FreightCollection>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.FreightCollection";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 1, name: "items", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: FreightReference} },
    { no: 2, name: "verificationHistory", kind: "message", T: VerificationInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FreightCollection {
    return new FreightCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FreightCollection {
    return new FreightCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FreightCollection {
    return new FreightCollection().fromJsonString(jsonString, options);
  }

  static equals(a: FreightCollection | PlainMessage<FreightCollection> | undefined, b: FreightCollection | PlainMessage<FreightCollection> | undefined): boolean {
    return proto2.util.equals(FreightCollection, a, b);
  }
}

/**
 * FreightList is a list of Freight resources.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.FreightList
 */
export class FreightList extends Message<FreightList> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Freight items = 2;
   */
  items: Freight[] = [];

  constructor(data?: PartialMessage<FreightList>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.FreightList";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ListMeta, opt: true },
    { no: 2, name: "items", kind: "message", T: Freight, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FreightList {
    return new FreightList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FreightList {
    return new FreightList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FreightList {
    return new FreightList().fromJsonString(jsonString, options);
  }

  static equals(a: FreightList | PlainMessage<FreightList> | undefined, b: FreightList | PlainMessage<FreightList> | undefined): boolean {
    return proto2.util.equals(FreightList, a, b);
  }
}

/**
 * FreightOrigin describes a kind of Freight in terms of where it may have
 * originated.
 *
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.FreightOrigin
 */
export class FreightOrigin extends Message<FreightOrigin> {
  /**
   * Kind is the kind of resource from which Freight may have originated. At
   * present, this can only be "Warehouse".
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional string kind = 1;
   */
  kind?: string;

  /**
   * Name is the name of the resource of the kind indicated by the Kind field
   * from which Freight may originated.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  constructor(data?: PartialMessage<FreightOrigin>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.FreightOrigin";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FreightOrigin {
    return new FreightOrigin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FreightOrigin {
    return new FreightOrigin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FreightOrigin {
    return new FreightOrigin().fromJsonString(jsonString, options);
  }

  static equals(a: FreightOrigin | PlainMessage<FreightOrigin> | undefined, b: FreightOrigin | PlainMessage<FreightOrigin> | undefined): boolean {
    return proto2.util.equals(FreightOrigin, a, b);
  }
}

/**
 * FreightReference is a simplified representation of a piece of Freight -- not
 * a root resource type.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.FreightReference
 */
export class FreightReference extends Message<FreightReference> {
  /**
   * Name is system-assigned identifier that is derived deterministically from
   * the contents of the Freight. i.e. Two pieces of Freight can be compared for
   * equality by comparing their Names.
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * Origin describes a kind of Freight in terms of its origin.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 8;
   */
  origin?: FreightOrigin;

  /**
   * Commits describes specific Git repository commits.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.GitCommit commits = 2;
   */
  commits: GitCommit[] = [];

  /**
   * Images describes specific versions of specific container images.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Image images = 3;
   */
  images: Image[] = [];

  /**
   * Charts describes specific versions of specific Helm charts.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Chart charts = 4;
   */
  charts: Chart[] = [];

  constructor(data?: PartialMessage<FreightReference>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.FreightReference";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 2, name: "commits", kind: "message", T: GitCommit, repeated: true },
    { no: 3, name: "images", kind: "message", T: Image, repeated: true },
    { no: 4, name: "charts", kind: "message", T: Chart, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FreightReference {
    return new FreightReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FreightReference {
    return new FreightReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FreightReference {
    return new FreightReference().fromJsonString(jsonString, options);
  }

  static equals(a: FreightReference | PlainMessage<FreightReference> | undefined, b: FreightReference | PlainMessage<FreightReference> | undefined): boolean {
    return proto2.util.equals(FreightReference, a, b);
  }
}

/**
 * FreightRequest expresses a Stage's need for Freight having originated from a
 * particular Warehouse.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.FreightRequest
 */
export class FreightRequest extends Message<FreightRequest> {
  /**
   * Origin specifies from where the requested Freight must have originated.
   * This is a required field.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 1;
   */
  origin?: FreightOrigin;

  /**
   * Sources describes where the requested Freight may be obtained from. This is
   * a required field.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightSources sources = 2;
   */
  sources?: FreightSources;

  constructor(data?: PartialMessage<FreightRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.FreightRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 2, name: "sources", kind: "message", T: FreightSources, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FreightRequest {
    return new FreightRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FreightRequest {
    return new FreightRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FreightRequest {
    return new FreightRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FreightRequest | PlainMessage<FreightRequest> | undefined, b: FreightRequest | PlainMessage<FreightRequest> | undefined): boolean {
    return proto2.util.equals(FreightRequest, a, b);
  }
}

/**
 * @generated from message github.com.akuity.kargo.api.v1alpha1.FreightSources
 */
export class FreightSources extends Message<FreightSources> {
  /**
   * Direct indicates the requested Freight may be obtained directly from the
   * Warehouse from which it originated. If this field's value is false, then
   * the value of the Stages field must be non-empty. i.e. Between the two
   * fields, at least one source must be specified.
   *
   * @generated from field: optional bool direct = 1;
   */
  direct?: boolean;

  /**
   * Stages identifies other "upstream" Stages as potential sources of the
   * requested Freight. If this field's value is empty, then the value of the
   * Direct field must be true. i.e. Between the two fields, at least on source
   * must be specified.
   *
   * @generated from field: repeated string stages = 2;
   */
  stages: string[] = [];

  constructor(data?: PartialMessage<FreightSources>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.FreightSources";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "direct", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "stages", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FreightSources {
    return new FreightSources().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FreightSources {
    return new FreightSources().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FreightSources {
    return new FreightSources().fromJsonString(jsonString, options);
  }

  static equals(a: FreightSources | PlainMessage<FreightSources> | undefined, b: FreightSources | PlainMessage<FreightSources> | undefined): boolean {
    return proto2.util.equals(FreightSources, a, b);
  }
}

/**
 * FreightStatus describes a piece of Freight's most recently observed state.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.FreightStatus
 */
export class FreightStatus extends Message<FreightStatus> {
  /**
   * VerifiedIn describes the Stages in which this Freight has been verified
   * through promotion and subsequent health checks.
   *
   * @generated from field: map<string, github.com.akuity.kargo.api.v1alpha1.VerifiedStage> verifiedIn = 1;
   */
  verifiedIn: { [key: string]: VerifiedStage } = {};

  /**
   * ApprovedFor describes the Stages for which this Freight has been approved
   * preemptively/manually by a user. This is useful for hotfixes, where one
   * might wish to promote a piece of Freight to a given Stage without
   * transiting the entire pipeline.
   *
   * @generated from field: map<string, github.com.akuity.kargo.api.v1alpha1.ApprovedStage> approvedFor = 2;
   */
  approvedFor: { [key: string]: ApprovedStage } = {};

  constructor(data?: PartialMessage<FreightStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.FreightStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "verifiedIn", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: VerifiedStage} },
    { no: 2, name: "approvedFor", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ApprovedStage} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FreightStatus {
    return new FreightStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FreightStatus {
    return new FreightStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FreightStatus {
    return new FreightStatus().fromJsonString(jsonString, options);
  }

  static equals(a: FreightStatus | PlainMessage<FreightStatus> | undefined, b: FreightStatus | PlainMessage<FreightStatus> | undefined): boolean {
    return proto2.util.equals(FreightStatus, a, b);
  }
}

/**
 * GitCommit describes a specific commit from a specific Git repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitCommit
 */
export class GitCommit extends Message<GitCommit> {
  /**
   * RepoURL is the URL of a Git repository.
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * ID is the ID of a specific commit in the Git repository specified by
   * RepoURL.
   *
   * @generated from field: optional string id = 2;
   */
  id?: string;

  /**
   * Branch denotes the branch of the repository where this commit was found.
   *
   * @generated from field: optional string branch = 3;
   */
  branch?: string;

  /**
   * Tag denotes a tag in the repository that matched selection criteria and
   * resolved to this commit.
   *
   * @generated from field: optional string tag = 4;
   */
  tag?: string;

  /**
   * HealthCheckCommit is the ID of a specific commit. When specified,
   * assessments of Stage health will use this value (instead of ID) when
   * determining if applicable sources of Argo CD Application resources
   * associated with the Stage are or are not synced to this commit. Note that
   * there are cases (as in that of Kargo Render being utilized as a promotion
   * mechanism) wherein the value of this field may differ from the commit ID
   * found in the ID field.
   *
   * @generated from field: optional string healthCheckCommit = 5;
   */
  healthCheckCommit?: string;

  /**
   * Message is the message associated with the commit. At present, this only
   * contains the first line (subject) of the commit message.
   *
   * @generated from field: optional string message = 6;
   */
  message?: string;

  /**
   * Author is the author of the commit.
   *
   * @generated from field: optional string author = 7;
   */
  author?: string;

  /**
   * Committer is the person who committed the commit.
   *
   * @generated from field: optional string committer = 8;
   */
  committer?: string;

  constructor(data?: PartialMessage<GitCommit>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitCommit";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "branch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "healthCheckCommit", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "author", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "committer", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitCommit {
    return new GitCommit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitCommit {
    return new GitCommit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitCommit {
    return new GitCommit().fromJsonString(jsonString, options);
  }

  static equals(a: GitCommit | PlainMessage<GitCommit> | undefined, b: GitCommit | PlainMessage<GitCommit> | undefined): boolean {
    return proto2.util.equals(GitCommit, a, b);
  }
}

/**
 * GitDiscoveryResult represents the result of a Git discovery operation for a
 * GitSubscription.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitDiscoveryResult
 */
export class GitDiscoveryResult extends Message<GitDiscoveryResult> {
  /**
   * RepoURL is the repository URL of the GitSubscription.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`(?:^(https?)://(?:([\w-]+):(.+)@)?([\w-]+(?:\.[\w-]+)*)(?::(\d{1,5}))?(/.*)$)|(?:^([\w-]+)@([\w+]+(?:\.[\w-]+)*):(/?.*))`
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Commits is a list of commits discovered by the Warehouse for the
   * GitSubscription. An empty list indicates that the discovery operation was
   * successful, but no commits matching the GitSubscription criteria were found.
   *
   * +optional
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.DiscoveredCommit commits = 2;
   */
  commits: DiscoveredCommit[] = [];

  constructor(data?: PartialMessage<GitDiscoveryResult>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitDiscoveryResult";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "commits", kind: "message", T: DiscoveredCommit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitDiscoveryResult {
    return new GitDiscoveryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitDiscoveryResult {
    return new GitDiscoveryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitDiscoveryResult {
    return new GitDiscoveryResult().fromJsonString(jsonString, options);
  }

  static equals(a: GitDiscoveryResult | PlainMessage<GitDiscoveryResult> | undefined, b: GitDiscoveryResult | PlainMessage<GitDiscoveryResult> | undefined): boolean {
    return proto2.util.equals(GitDiscoveryResult, a, b);
  }
}

/**
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitHubPullRequest
 */
export class GitHubPullRequest extends Message<GitHubPullRequest> {
  constructor(data?: PartialMessage<GitHubPullRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitHubPullRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitHubPullRequest {
    return new GitHubPullRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitHubPullRequest {
    return new GitHubPullRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitHubPullRequest {
    return new GitHubPullRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GitHubPullRequest | PlainMessage<GitHubPullRequest> | undefined, b: GitHubPullRequest | PlainMessage<GitHubPullRequest> | undefined): boolean {
    return proto2.util.equals(GitHubPullRequest, a, b);
  }
}

/**
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitLabPullRequest
 */
export class GitLabPullRequest extends Message<GitLabPullRequest> {
  constructor(data?: PartialMessage<GitLabPullRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitLabPullRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitLabPullRequest {
    return new GitLabPullRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitLabPullRequest {
    return new GitLabPullRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitLabPullRequest {
    return new GitLabPullRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GitLabPullRequest | PlainMessage<GitLabPullRequest> | undefined, b: GitLabPullRequest | PlainMessage<GitLabPullRequest> | undefined): boolean {
    return proto2.util.equals(GitLabPullRequest, a, b);
  }
}

/**
 * GitRepoUpdate describes updates that should be applied to a Git repository
 * (using various configuration management tools) to incorporate Freight into a
 * Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitRepoUpdate
 */
export class GitRepoUpdate extends Message<GitRepoUpdate> {
  /**
   * RepoURL is the URL of the repository to update. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^https?://(\w+([\.-]\w+)*@)?\w+([\.-]\w+)*(:[\d]+)?(/.*)?$`
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, the branch
   * checked out by this promotion mechanism will be the one specified by the
   * ReadBranch field. If that, too, is unspecified, the default branch of the
   * repository will be checked out. Always provide a value for this field if
   * wishing to check out a specific commit indicated by a piece of Freight.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 9;
   */
  origin?: FreightOrigin;

  /**
   * InsecureSkipTLSVerify specifies whether certificate verification errors
   * should be ignored when connecting to the repository. This should be enabled
   * only with great caution.
   *
   * @generated from field: optional bool insecureSkipTLSVerify = 2;
   */
  insecureSkipTLSVerify?: boolean;

  /**
   * ReadBranch specifies a particular branch of the repository from which to
   * locate contents that will be written to the branch specified by the
   * WriteBranch field. This field is optional. When not specified, the
   * ReadBranch is implicitly the repository's default branch AND in cases where
   * a Freight includes a GitCommit, that commit's ID will supersede the value
   * of this field. Therefore, in practice, this field is only used to clarify
   * what branch of a repository can be treated as a source of manifests or
   * other configuration when a Stage has no subscription to that repository.
   *
   * +kubebuilder:validation:Optional
   * +kubebuilder:validation:Pattern=`^(\w+([-/]\w+)*)?$`
   *
   * @generated from field: optional string readBranch = 3;
   */
  readBranch?: string;

  /**
   * WriteBranch specifies the particular branch of the repository to be
   * updated. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^\w+([-/]\w+)*$`
   *
   * @generated from field: optional string writeBranch = 4;
   */
  writeBranch?: string;

  /**
   * PullRequest will generate a pull request instead of making the commit directly
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PullRequestPromotionMechanism pullRequest = 5;
   */
  pullRequest?: PullRequestPromotionMechanism;

  /**
   * Render describes how to use Kargo Render to incorporate Freight into the
   * Stage. This is mutually exclusive with the Kustomize and Helm fields.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.KargoRenderPromotionMechanism render = 6;
   */
  render?: KargoRenderPromotionMechanism;

  /**
   * Kustomize describes how to use Kustomize to incorporate Freight into the
   * Stage. This is mutually exclusive with the Render and Helm fields.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.KustomizePromotionMechanism kustomize = 7;
   */
  kustomize?: KustomizePromotionMechanism;

  /**
   * Helm describes how to use Helm to incorporate Freight into the Stage. This
   * is mutually exclusive with the Render and Kustomize fields.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.HelmPromotionMechanism helm = 8;
   */
  helm?: HelmPromotionMechanism;

  constructor(data?: PartialMessage<GitRepoUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitRepoUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 2, name: "insecureSkipTLSVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "readBranch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "writeBranch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "pullRequest", kind: "message", T: PullRequestPromotionMechanism, opt: true },
    { no: 6, name: "render", kind: "message", T: KargoRenderPromotionMechanism, opt: true },
    { no: 7, name: "kustomize", kind: "message", T: KustomizePromotionMechanism, opt: true },
    { no: 8, name: "helm", kind: "message", T: HelmPromotionMechanism, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitRepoUpdate {
    return new GitRepoUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitRepoUpdate {
    return new GitRepoUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitRepoUpdate {
    return new GitRepoUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: GitRepoUpdate | PlainMessage<GitRepoUpdate> | undefined, b: GitRepoUpdate | PlainMessage<GitRepoUpdate> | undefined): boolean {
    return proto2.util.equals(GitRepoUpdate, a, b);
  }
}

/**
 * GitSubscription defines a subscription to a Git repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.GitSubscription
 */
export class GitSubscription extends Message<GitSubscription> {
  /**
   * URL is the repository's URL. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`(?:^(https?)://(?:([\w-]+):(.+)@)?([\w-]+(?:\.[\w-]+)*)(?::(\d{1,5}))?(/.*)$)|(?:^([\w-]+)@([\w+]+(?:\.[\w-]+)*):(/?.*))`
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * CommitSelectionStrategy specifies the rules for how to identify the newest
   * commit of interest in the repository specified by the RepoURL field. This
   * field is optional. When left unspecified, the field is implicitly treated
   * as if its value were "NewestFromBranch".
   *
   * +kubebuilder:default=NewestFromBranch
   *
   * @generated from field: optional string commitSelectionStrategy = 2;
   */
  commitSelectionStrategy?: string;

  /**
   * Branch references a particular branch of the repository. The value in this
   * field only has any effect when the CommitSelectionStrategy is
   * NewestFromBranch or left unspecified (which is implicitly the same as
   * NewestFromBranch). This field is optional. When left unspecified, (and the
   * CommitSelectionStrategy is NewestFromBranch or unspecified), the
   * subscription is implicitly to the repository's default branch.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^\w+([-/]\w+)*$`
   *
   * @generated from field: optional string branch = 3;
   */
  branch?: string;

  /**
   * StrictSemvers specifies whether only "strict" semver tags should be
   * considered. A "strict" semver tag is one containing ALL of major, minor,
   * and patch version components. This is enabled by default, but only has any
   * effect when the CommitSelectionStrategy is SemVer. This should be disabled
   * cautiously, as it creates the potential for any tag containing numeric
   * characters only to be mistaken for a semver string containing the major
   * version number only.
   *
   * +kubebuilder:default=true
   *
   * @generated from field: optional bool strictSemvers = 11;
   */
  strictSemvers?: boolean;

  /**
   * SemverConstraint specifies constraints on what new tagged commits are
   * considered in determining the newest commit of interest. The value in this
   * field only has any effect when the CommitSelectionStrategy is SemVer. This
   * field is optional. When left unspecified, there will be no constraints,
   * which means the latest semantically tagged commit will always be used. Care
   * should be taken with leaving this field unspecified, as it can lead to the
   * unanticipated rollout of breaking changes.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string semverConstraint = 4;
   */
  semverConstraint?: string;

  /**
   * AllowTags is a regular expression that can optionally be used to limit the
   * tags that are considered in determining the newest commit of interest. The
   * value in this field only has any effect when the CommitSelectionStrategy is
   * Lexical, NewestTag, or SemVer. This field is optional.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string allowTags = 5;
   */
  allowTags?: string;

  /**
   * IgnoreTags is a list of tags that must be ignored when determining the
   * newest commit of interest. No regular expressions or glob patterns are
   * supported yet. The value in this field only has any effect when the
   * CommitSelectionStrategy is Lexical, NewestTag, or SemVer. This field is
   * optional.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: repeated string ignoreTags = 6;
   */
  ignoreTags: string[] = [];

  /**
   * InsecureSkipTLSVerify specifies whether certificate verification errors
   * should be ignored when connecting to the repository. This should be enabled
   * only with great caution.
   *
   * @generated from field: optional bool insecureSkipTLSVerify = 7;
   */
  insecureSkipTLSVerify?: boolean;

  /**
   * IncludePaths is a list of selectors that designate paths in the repository
   * that should trigger the production of new Freight when changes are detected
   * therein. When specified, only changes in the identified paths will trigger
   * Freight production. When not specified, changes in any path will trigger
   * Freight production. Selectors may be defined using:
   *   1. Exact paths to files or directories (ex. "charts/foo")
   *   2. Glob patterns (prefix the pattern with "glob:"; ex. "glob:*.yaml")
   *   3. Regular expressions (prefix the pattern with "regex:" or "regexp:";
   *      ex. "regexp:^.*\.yaml$")
   * Paths selected by IncludePaths may be unselected by ExcludePaths. This
   * is a useful method for including a broad set of paths and then excluding a
   * subset of them.
   * +kubebuilder:validation:Optional
   *
   * @generated from field: repeated string includePaths = 8;
   */
  includePaths: string[] = [];

  /**
   * ExcludePaths is a list of selectors that designate paths in the repository
   * that should NOT trigger the production of new Freight when changes are
   * detected therein. When specified, changes in the identified paths will not
   * trigger Freight production. When not specified, paths that should trigger
   * Freight production will be defined solely by IncludePaths. Selectors may be
   * defined using:
   *   1. Exact paths to files or directories (ex. "charts/foo")
   *   2. Glob patterns (prefix the pattern with "glob:"; ex. "glob:*.yaml")
   *   3. Regular expressions (prefix the pattern with "regex:" or "regexp:";
   *      ex. "regexp:^.*\.yaml$")
   * Paths selected by IncludePaths may be unselected by ExcludePaths. This
   * is a useful method for including a broad set of paths and then excluding a
   * subset of them.
   * +kubebuilder:validation:Optional
   *
   * @generated from field: repeated string excludePaths = 9;
   */
  excludePaths: string[] = [];

  /**
   * DiscoveryLimit is an optional limit on the number of commits that can be
   * discovered for this subscription. The limit is applied after filtering
   * commits based on the AllowTags and IgnoreTags fields.
   * When left unspecified, the field is implicitly treated as if its value
   * were "20". The upper limit for this field is 100.
   *
   * +kubebuilder:validation:Minimum=1
   * +kubebuilder:validation:Maximum=100
   * +kubebuilder:default=20
   *
   * @generated from field: optional int32 discoveryLimit = 10;
   */
  discoveryLimit?: number;

  constructor(data?: PartialMessage<GitSubscription>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.GitSubscription";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "commitSelectionStrategy", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "branch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "strictSemvers", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "semverConstraint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "allowTags", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "ignoreTags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "insecureSkipTLSVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 8, name: "includePaths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "excludePaths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "discoveryLimit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitSubscription {
    return new GitSubscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitSubscription {
    return new GitSubscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitSubscription {
    return new GitSubscription().fromJsonString(jsonString, options);
  }

  static equals(a: GitSubscription | PlainMessage<GitSubscription> | undefined, b: GitSubscription | PlainMessage<GitSubscription> | undefined): boolean {
    return proto2.util.equals(GitSubscription, a, b);
  }
}

/**
 * Health describes the health of a Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Health
 */
export class Health extends Message<Health> {
  /**
   * Status describes the health of the Stage.
   *
   * @generated from field: optional string status = 1;
   */
  status?: string;

  /**
   * Issues clarifies why a Stage in any state other than Healthy is in that
   * state. This field will always be the empty when a Stage is Healthy.
   *
   * @generated from field: repeated string issues = 2;
   */
  issues: string[] = [];

  /**
   * ArgoCDApps describes the current state of any related ArgoCD Applications.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDAppStatus argoCDApps = 3;
   */
  argoCDApps: ArgoCDAppStatus[] = [];

  constructor(data?: PartialMessage<Health>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Health";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "issues", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "argoCDApps", kind: "message", T: ArgoCDAppStatus, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Health {
    return new Health().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Health {
    return new Health().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Health {
    return new Health().fromJsonString(jsonString, options);
  }

  static equals(a: Health | PlainMessage<Health> | undefined, b: Health | PlainMessage<Health> | undefined): boolean {
    return proto2.util.equals(Health, a, b);
  }
}

/**
 * HelmChartDependencyUpdate describes how a specific Helm chart that is used
 * as a subchart of an umbrella chart can be updated.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.HelmChartDependencyUpdate
 */
export class HelmChartDependencyUpdate extends Message<HelmChartDependencyUpdate> {
  /**
   * Repository along with Name identifies a subchart of the umbrella chart at
   * ChartPath whose version should be updated. The values of both fields should
   * exactly match the values of the fields of the same names in a dependency
   * expressed in the Chart.yaml of the umbrella chart at ChartPath. i.e. Do not
   * match the values of these two fields to your Warehouse; match them to the
   * Chart.yaml. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^(((https?)|(oci))://)([\w\d\.\-]+)(:[\d]+)?(/.*)*$`
   *
   * @generated from field: optional string repository = 1;
   */
  repository?: string;

  /**
   * Name along with Repository identifies a subchart of the umbrella chart at
   * ChartPath whose version should be updated. The values of both fields should
   * exactly match the values of the fields of the same names in a dependency
   * expressed in the Chart.yaml of the umbrella chart at ChartPath. i.e. Do not
   * match the values of these two fields to your Warehouse; match them to the
   * Chart.yaml. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing HelmPromotionMechanism's
   * Origin field. If that, too, is unspecified, Promotions will fail if there
   * is ever ambiguity regarding from which piece of Freight an artifact is to
   * be sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 4;
   */
  origin?: FreightOrigin;

  /**
   * ChartPath is the path to an umbrella chart.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[\w-\.]+(/[\w-\.]+)*$
   *
   * @generated from field: optional string chartPath = 3;
   */
  chartPath?: string;

  constructor(data?: PartialMessage<HelmChartDependencyUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.HelmChartDependencyUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 3, name: "chartPath", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HelmChartDependencyUpdate {
    return new HelmChartDependencyUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HelmChartDependencyUpdate {
    return new HelmChartDependencyUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HelmChartDependencyUpdate {
    return new HelmChartDependencyUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: HelmChartDependencyUpdate | PlainMessage<HelmChartDependencyUpdate> | undefined, b: HelmChartDependencyUpdate | PlainMessage<HelmChartDependencyUpdate> | undefined): boolean {
    return proto2.util.equals(HelmChartDependencyUpdate, a, b);
  }
}

/**
 * HelmImageUpdate describes how a specific image version can be incorporated
 * into a specific Helm values file.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.HelmImageUpdate
 */
export class HelmImageUpdate extends Message<HelmImageUpdate> {
  /**
   * Image specifies a container image (without tag). This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^(\w+([\.-]\w+)*(:[\d]+)?/)?(\w+([\.-]\w+)*)(/\w+([\.-]\w+)*)*$`
   *
   * @generated from field: optional string image = 1;
   */
  image?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing HelmPromotionMechanism's
   * Origin field. If that, too, is unspecified, Promotions will fail if there
   * is ever ambiguity regarding from which piece of Freight an artifact is to
   * be sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 5;
   */
  origin?: FreightOrigin;

  /**
   * ValuesFilePath specifies a path to the Helm values file that is to be
   * updated. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[\w-\.]+(/[\w-\.]+)*$
   *
   * @generated from field: optional string valuesFilePath = 2;
   */
  valuesFilePath?: string;

  /**
   * Key specifies a key within the Helm values file that is to be updated. This
   * is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string key = 3;
   */
  key?: string;

  /**
   * Value specifies the new value for the specified key in the specified Helm
   * values file. Valid values are:
   *
   * - ImageAndTag: Replaces the value of the specified key with
   *   <image name>:<tag>
   * - Tag: Replaces the value of the specified key with just the new tag
   * - ImageAndDigest: Replaces the value of the specified key with
   *   <image name>@<digest>
   * - Digest: Replaces the value of the specified key with just the new digest.
   *
   * This is a required field.
   *
   * @generated from field: optional string value = 4;
   */
  value?: string;

  constructor(data?: PartialMessage<HelmImageUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.HelmImageUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 2, name: "valuesFilePath", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HelmImageUpdate {
    return new HelmImageUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HelmImageUpdate {
    return new HelmImageUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HelmImageUpdate {
    return new HelmImageUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: HelmImageUpdate | PlainMessage<HelmImageUpdate> | undefined, b: HelmImageUpdate | PlainMessage<HelmImageUpdate> | undefined): boolean {
    return proto2.util.equals(HelmImageUpdate, a, b);
  }
}

/**
 * HelmPromotionMechanism describes how to use Helm to incorporate Freight into
 * a Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.HelmPromotionMechanism
 */
export class HelmPromotionMechanism extends Message<HelmPromotionMechanism> {
  /**
   * Images describes how specific image versions can be incorporated into Helm
   * values files.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.HelmImageUpdate images = 1;
   */
  images: HelmImageUpdate[] = [];

  /**
   * Charts describes how specific chart versions can be incorporated into an
   * umbrella chart.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.HelmChartDependencyUpdate charts = 2;
   */
  charts: HelmChartDependencyUpdate[] = [];

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing GitRepoUpdate's Origin field.
   * If that, too, is unspecified, Promotions will fail if there is ever
   * ambiguity regarding from which piece of Freight an artifact is to be
   * sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 3;
   */
  origin?: FreightOrigin;

  constructor(data?: PartialMessage<HelmPromotionMechanism>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.HelmPromotionMechanism";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "message", T: HelmImageUpdate, repeated: true },
    { no: 2, name: "charts", kind: "message", T: HelmChartDependencyUpdate, repeated: true },
    { no: 3, name: "origin", kind: "message", T: FreightOrigin, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HelmPromotionMechanism {
    return new HelmPromotionMechanism().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HelmPromotionMechanism {
    return new HelmPromotionMechanism().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HelmPromotionMechanism {
    return new HelmPromotionMechanism().fromJsonString(jsonString, options);
  }

  static equals(a: HelmPromotionMechanism | PlainMessage<HelmPromotionMechanism> | undefined, b: HelmPromotionMechanism | PlainMessage<HelmPromotionMechanism> | undefined): boolean {
    return proto2.util.equals(HelmPromotionMechanism, a, b);
  }
}

/**
 * Image describes a specific version of a container image.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Image
 */
export class Image extends Message<Image> {
  /**
   * RepoURL describes the repository in which the image can be found.
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * GitRepoURL specifies the URL of a Git repository that contains the source
   * code for the image repository referenced by the RepoURL field if Kargo was
   * able to infer it.
   *
   * @generated from field: optional string gitRepoURL = 2;
   */
  gitRepoURL?: string;

  /**
   * Tag identifies a specific version of the image in the repository specified
   * by RepoURL.
   *
   * @generated from field: optional string tag = 3;
   */
  tag?: string;

  /**
   * Digest identifies a specific version of the image in the repository
   * specified by RepoURL. This is a more precise identifier than Tag.
   *
   * @generated from field: optional string digest = 4;
   */
  digest?: string;

  constructor(data?: PartialMessage<Image>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Image";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "gitRepoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "digest", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Image {
    return new Image().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Image {
    return new Image().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Image {
    return new Image().fromJsonString(jsonString, options);
  }

  static equals(a: Image | PlainMessage<Image> | undefined, b: Image | PlainMessage<Image> | undefined): boolean {
    return proto2.util.equals(Image, a, b);
  }
}

/**
 * ImageDiscoveryResult represents the result of an image discovery operation
 * for an ImageSubscription.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ImageDiscoveryResult
 */
export class ImageDiscoveryResult extends Message<ImageDiscoveryResult> {
  /**
   * RepoURL is the repository URL of the image, as specified in the
   * ImageSubscription.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * Platform is the target platform constraint of the ImageSubscription
   * for which references were discovered. This field is optional, and
   * only populated if the ImageSubscription specifies a Platform.
   *
   * @generated from field: optional string platform = 2;
   */
  platform?: string;

  /**
   * References is a list of image references discovered by the Warehouse for
   * the ImageSubscription. An empty list indicates that the discovery
   * operation was successful, but no images matching the ImageSubscription
   * criteria were found.
   *
   * +optional
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.DiscoveredImageReference references = 3;
   */
  references: DiscoveredImageReference[] = [];

  constructor(data?: PartialMessage<ImageDiscoveryResult>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ImageDiscoveryResult";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "platform", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "references", kind: "message", T: DiscoveredImageReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageDiscoveryResult {
    return new ImageDiscoveryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageDiscoveryResult {
    return new ImageDiscoveryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageDiscoveryResult {
    return new ImageDiscoveryResult().fromJsonString(jsonString, options);
  }

  static equals(a: ImageDiscoveryResult | PlainMessage<ImageDiscoveryResult> | undefined, b: ImageDiscoveryResult | PlainMessage<ImageDiscoveryResult> | undefined): boolean {
    return proto2.util.equals(ImageDiscoveryResult, a, b);
  }
}

/**
 * ImageSubscription defines a subscription to an image repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ImageSubscription
 */
export class ImageSubscription extends Message<ImageSubscription> {
  /**
   * RepoURL specifies the URL of the image repository to subscribe to. The
   * value in this field MUST NOT include an image tag. This field is required.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^(\w+([\.-]\w+)*(:[\d]+)?/)?(\w+([\.-]\w+)*)(/\w+([\.-]\w+)*)*$`
   *
   * @generated from field: optional string repoURL = 1;
   */
  repoURL?: string;

  /**
   * GitRepoURL optionally specifies the URL of a Git repository that contains
   * the source code for the image repository referenced by the RepoURL field.
   * When this is specified, Kargo MAY be able to infer and link to the exact
   * revision of that source code that was used to build the image.
   *
   * +kubebuilder:validation:Optional
   * +kubebuilder:validation:Pattern=`^https?://(\w+([\.-]\w+)*@)?\w+([\.-]\w+)*(:[\d]+)?(/.*)?$`
   *
   * @generated from field: optional string gitRepoURL = 2;
   */
  gitRepoURL?: string;

  /**
   * ImageSelectionStrategy specifies the rules for how to identify the newest version
   * of the image specified by the RepoURL field. This field is optional. When
   * left unspecified, the field is implicitly treated as if its value were
   * "SemVer".
   *
   * +kubebuilder:default=SemVer
   *
   * @generated from field: optional string imageSelectionStrategy = 3;
   */
  imageSelectionStrategy?: string;

  /**
   * StrictSemvers specifies whether only "strict" semver tags should be
   * considered. A "strict" semver tag is one containing ALL of major, minor,
   * and patch version components. This is enabled by default, but only has any
   * effect when the ImageSelectionStrategy is SemVer. This should be disabled
   * cautiously, as it is not uncommon to tag container images with short Git
   * commit hashes, which have the potential to contain numeric characters only
   * and could be mistaken for a semver string containing the major version
   * number only.
   *
   * +kubebuilder:default=true
   *
   * @generated from field: optional bool strictSemvers = 10;
   */
  strictSemvers?: boolean;

  /**
   * SemverConstraint specifies constraints on what new image versions are
   * permissible. The value in this field only has any effect when the
   * ImageSelectionStrategy is SemVer or left unspecified (which is implicitly
   * the same as SemVer). This field is also optional. When left unspecified,
   * (and the ImageSelectionStrategy is SemVer or unspecified), there will be no
   * constraints, which means the latest semantically tagged version of an image
   * will always be used. Care should be taken with leaving this field
   * unspecified, as it can lead to the unanticipated rollout of breaking
   * changes. Refer to Image Updater documentation for more details.
   * More info: https://github.com/masterminds/semver#checking-version-constraints
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string semverConstraint = 4;
   */
  semverConstraint?: string;

  /**
   * AllowTags is a regular expression that can optionally be used to limit the
   * image tags that are considered in determining the newest version of an
   * image. This field is optional.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string allowTags = 5;
   */
  allowTags?: string;

  /**
   * IgnoreTags is a list of tags that must be ignored when determining the
   * newest version of an image. No regular expressions or glob patterns are
   * supported yet. This field is optional.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: repeated string ignoreTags = 6;
   */
  ignoreTags: string[] = [];

  /**
   * Platform is a string of the form <os>/<arch> that limits the tags that can
   * be considered when searching for new versions of an image. This field is
   * optional. When left unspecified, it is implicitly equivalent to the
   * OS/architecture of the Kargo controller. Care should be taken to set this
   * value correctly in cases where the image referenced by this
   * ImageRepositorySubscription will run on a Kubernetes node with a different
   * OS/architecture than the Kargo controller. At present this is uncommon, but
   * not unheard of.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string platform = 7;
   */
  platform?: string;

  /**
   * InsecureSkipTLSVerify specifies whether certificate verification errors
   * should be ignored when connecting to the repository. This should be enabled
   * only with great caution.
   *
   * @generated from field: optional bool insecureSkipTLSVerify = 8;
   */
  insecureSkipTLSVerify?: boolean;

  /**
   * DiscoveryLimit is an optional limit on the number of image references
   * that can be discovered for this subscription. The limit is applied after
   * filtering images based on the AllowTags and IgnoreTags fields.
   * When left unspecified, the field is implicitly treated as if its value
   * were "20". The upper limit for this field is 100.
   *
   * +kubebuilder:validation:Minimum=1
   * +kubebuilder:validation:Maximum=100
   * +kubebuilder:default=20
   *
   * @generated from field: optional int32 discoveryLimit = 9;
   */
  discoveryLimit?: number;

  constructor(data?: PartialMessage<ImageSubscription>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ImageSubscription";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "repoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "gitRepoURL", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "imageSelectionStrategy", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "strictSemvers", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "semverConstraint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "allowTags", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "ignoreTags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "platform", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "insecureSkipTLSVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 9, name: "discoveryLimit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageSubscription {
    return new ImageSubscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageSubscription {
    return new ImageSubscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageSubscription {
    return new ImageSubscription().fromJsonString(jsonString, options);
  }

  static equals(a: ImageSubscription | PlainMessage<ImageSubscription> | undefined, b: ImageSubscription | PlainMessage<ImageSubscription> | undefined): boolean {
    return proto2.util.equals(ImageSubscription, a, b);
  }
}

/**
 * KargoRenderImageUpdate describes how an image can be incorporated into a
 * Stage using Kargo Render.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.KargoRenderImageUpdate
 */
export class KargoRenderImageUpdate extends Message<KargoRenderImageUpdate> {
  /**
   * Image specifies a container image (without tag). This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string image = 1;
   */
  image?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing
   * KargoRenderPromotionMechanism's Origin field. If that, too, is unspecified,
   * Promotions will fail if there is ever ambiguity regarding from which piece
   * of Freight an artifact is to be sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 3;
   */
  origin?: FreightOrigin;

  /**
   * UseDigest specifies whether the image's digest should be used instead of
   * its tag.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional bool useDigest = 2;
   */
  useDigest?: boolean;

  constructor(data?: PartialMessage<KargoRenderImageUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.KargoRenderImageUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 2, name: "useDigest", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KargoRenderImageUpdate {
    return new KargoRenderImageUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KargoRenderImageUpdate {
    return new KargoRenderImageUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KargoRenderImageUpdate {
    return new KargoRenderImageUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: KargoRenderImageUpdate | PlainMessage<KargoRenderImageUpdate> | undefined, b: KargoRenderImageUpdate | PlainMessage<KargoRenderImageUpdate> | undefined): boolean {
    return proto2.util.equals(KargoRenderImageUpdate, a, b);
  }
}

/**
 * KargoRenderPromotionMechanism describes how to use Kargo Render to
 * incorporate Freight into a Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.KargoRenderPromotionMechanism
 */
export class KargoRenderPromotionMechanism extends Message<KargoRenderPromotionMechanism> {
  /**
   * Images describes how images can be incorporated into a Stage using Kargo
   * Render. If this field is omitted, all images in the Freight being promoted
   * will be passed to Kargo Render in the form <image name>:<tag>. (e.g. Will
   * not use digests by default.)
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.KargoRenderImageUpdate images = 1;
   */
  images: KargoRenderImageUpdate[] = [];

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing GitRepoUpdate's Origin field.
   * If that, too, is unspecified, Promotions will fail if there is ever
   * ambiguity regarding from which piece of Freight an artifact is to be
   * sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 2;
   */
  origin?: FreightOrigin;

  constructor(data?: PartialMessage<KargoRenderPromotionMechanism>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.KargoRenderPromotionMechanism";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "message", T: KargoRenderImageUpdate, repeated: true },
    { no: 2, name: "origin", kind: "message", T: FreightOrigin, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KargoRenderPromotionMechanism {
    return new KargoRenderPromotionMechanism().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KargoRenderPromotionMechanism {
    return new KargoRenderPromotionMechanism().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KargoRenderPromotionMechanism {
    return new KargoRenderPromotionMechanism().fromJsonString(jsonString, options);
  }

  static equals(a: KargoRenderPromotionMechanism | PlainMessage<KargoRenderPromotionMechanism> | undefined, b: KargoRenderPromotionMechanism | PlainMessage<KargoRenderPromotionMechanism> | undefined): boolean {
    return proto2.util.equals(KargoRenderPromotionMechanism, a, b);
  }
}

/**
 * KustomizeImageUpdate describes how to run `kustomize edit set image`
 * for a given image.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.KustomizeImageUpdate
 */
export class KustomizeImageUpdate extends Message<KustomizeImageUpdate> {
  /**
   * Image specifies a container image (without tag). This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string image = 1;
   */
  image?: string;

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing KustomizePromotionMechanism's
   * Origin field. If that, too, is unspecified, Promotions will fail if there
   * is ever ambiguity regarding from which piece of Freight an artifact is to
   * be sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 4;
   */
  origin?: FreightOrigin;

  /**
   * Path specifies a path in which the `kustomize edit set image` command
   * should be executed. This is a required field.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[\w-\.]+(/[\w-\.]+)*$
   *
   * @generated from field: optional string path = 2;
   */
  path?: string;

  /**
   * UseDigest specifies whether the image's digest should be used instead of
   * its tag.
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional bool useDigest = 3;
   */
  useDigest?: boolean;

  /**
   * NewName specifies a container image name override when setting the image
   *
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string newName = 5;
   */
  newName?: string;

  constructor(data?: PartialMessage<KustomizeImageUpdate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.KustomizeImageUpdate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "useDigest", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 5, name: "newName", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KustomizeImageUpdate {
    return new KustomizeImageUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KustomizeImageUpdate {
    return new KustomizeImageUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KustomizeImageUpdate {
    return new KustomizeImageUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: KustomizeImageUpdate | PlainMessage<KustomizeImageUpdate> | undefined, b: KustomizeImageUpdate | PlainMessage<KustomizeImageUpdate> | undefined): boolean {
    return proto2.util.equals(KustomizeImageUpdate, a, b);
  }
}

/**
 * KustomizePromotionMechanism describes how to use Kustomize to incorporate
 * Freight into a Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.KustomizePromotionMechanism
 */
export class KustomizePromotionMechanism extends Message<KustomizePromotionMechanism> {
  /**
   * Images describes images for which `kustomize edit set image` should be
   * executed and the paths in which those commands should be executed.
   *
   * +kubebuilder:validation:MinItems=1
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.KustomizeImageUpdate images = 1;
   */
  images: KustomizeImageUpdate[] = [];

  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. When left unspecified, it will
   * implicitly inherit the value of the enclosing GitRepoUpdate's Origin field.
   * If that, too, is unspecified, Promotions will fail if there is ever
   * ambiguity regarding from which piece of Freight an artifact is to be
   * sourced.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 2;
   */
  origin?: FreightOrigin;

  constructor(data?: PartialMessage<KustomizePromotionMechanism>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.KustomizePromotionMechanism";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "images", kind: "message", T: KustomizeImageUpdate, repeated: true },
    { no: 2, name: "origin", kind: "message", T: FreightOrigin, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KustomizePromotionMechanism {
    return new KustomizePromotionMechanism().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KustomizePromotionMechanism {
    return new KustomizePromotionMechanism().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KustomizePromotionMechanism {
    return new KustomizePromotionMechanism().fromJsonString(jsonString, options);
  }

  static equals(a: KustomizePromotionMechanism | PlainMessage<KustomizePromotionMechanism> | undefined, b: KustomizePromotionMechanism | PlainMessage<KustomizePromotionMechanism> | undefined): boolean {
    return proto2.util.equals(KustomizePromotionMechanism, a, b);
  }
}

/**
 * Project is a resource type that reconciles to a specially labeled namespace
 * and other TODO: TBD project-level resources.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Project
 */
export class Project extends Message<Project> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec describes a Project.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ProjectSpec spec = 2;
   */
  spec?: ProjectSpec;

  /**
   * Status describes the Project's current status.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ProjectStatus status = 3;
   */
  status?: ProjectStatus;

  constructor(data?: PartialMessage<Project>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Project";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ObjectMeta, opt: true },
    { no: 2, name: "spec", kind: "message", T: ProjectSpec, opt: true },
    { no: 3, name: "status", kind: "message", T: ProjectStatus, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Project {
    return new Project().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Project {
    return new Project().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Project {
    return new Project().fromJsonString(jsonString, options);
  }

  static equals(a: Project | PlainMessage<Project> | undefined, b: Project | PlainMessage<Project> | undefined): boolean {
    return proto2.util.equals(Project, a, b);
  }
}

/**
 * ProjectList is a list of Project resources.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ProjectList
 */
export class ProjectList extends Message<ProjectList> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Project items = 2;
   */
  items: Project[] = [];

  constructor(data?: PartialMessage<ProjectList>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ProjectList";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ListMeta, opt: true },
    { no: 2, name: "items", kind: "message", T: Project, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectList {
    return new ProjectList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectList {
    return new ProjectList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectList {
    return new ProjectList().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectList | PlainMessage<ProjectList> | undefined, b: ProjectList | PlainMessage<ProjectList> | undefined): boolean {
    return proto2.util.equals(ProjectList, a, b);
  }
}

/**
 * ProjectSpec describes a Project.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ProjectSpec
 */
export class ProjectSpec extends Message<ProjectSpec> {
  /**
   * PromotionPolicies defines policies governing the promotion of Freight to
   * specific Stages within this Project.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.PromotionPolicy promotionPolicies = 1;
   */
  promotionPolicies: PromotionPolicy[] = [];

  constructor(data?: PartialMessage<ProjectSpec>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ProjectSpec";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "promotionPolicies", kind: "message", T: PromotionPolicy, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectSpec {
    return new ProjectSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectSpec {
    return new ProjectSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectSpec {
    return new ProjectSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectSpec | PlainMessage<ProjectSpec> | undefined, b: ProjectSpec | PlainMessage<ProjectSpec> | undefined): boolean {
    return proto2.util.equals(ProjectSpec, a, b);
  }
}

/**
 * ProjectStatus describes a Project's current status.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.ProjectStatus
 */
export class ProjectStatus extends Message<ProjectStatus> {
  /**
   * Phase describes the Project's current phase.
   *
   * @generated from field: optional string phase = 1;
   */
  phase?: string;

  /**
   * Message is a display message about the Project, including any errors
   * preventing the Project from being reconciled. i.e. If the Phase field has a
   * value of CreationFailed, this field can be expected to explain why.
   *
   * @generated from field: optional string message = 2;
   */
  message?: string;

  constructor(data?: PartialMessage<ProjectStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.ProjectStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "phase", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectStatus {
    return new ProjectStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectStatus {
    return new ProjectStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectStatus {
    return new ProjectStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectStatus | PlainMessage<ProjectStatus> | undefined, b: ProjectStatus | PlainMessage<ProjectStatus> | undefined): boolean {
    return proto2.util.equals(ProjectStatus, a, b);
  }
}

/**
 * Promotion represents a request to transition a particular Stage into a
 * particular Freight.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Promotion
 */
export class Promotion extends Message<Promotion> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec describes the desired transition of a specific Stage into a specific
   * Freight.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionSpec spec = 2;
   */
  spec?: PromotionSpec;

  /**
   * Status describes the current state of the transition represented by this
   * Promotion.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionStatus status = 3;
   */
  status?: PromotionStatus;

  constructor(data?: PartialMessage<Promotion>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Promotion";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ObjectMeta, opt: true },
    { no: 2, name: "spec", kind: "message", T: PromotionSpec, opt: true },
    { no: 3, name: "status", kind: "message", T: PromotionStatus, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Promotion {
    return new Promotion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Promotion {
    return new Promotion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Promotion {
    return new Promotion().fromJsonString(jsonString, options);
  }

  static equals(a: Promotion | PlainMessage<Promotion> | undefined, b: Promotion | PlainMessage<Promotion> | undefined): boolean {
    return proto2.util.equals(Promotion, a, b);
  }
}

/**
 * PromotionList contains a list of Promotion
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionList
 */
export class PromotionList extends Message<PromotionList> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Promotion items = 2;
   */
  items: Promotion[] = [];

  constructor(data?: PartialMessage<PromotionList>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionList";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ListMeta, opt: true },
    { no: 2, name: "items", kind: "message", T: Promotion, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionList {
    return new PromotionList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionList {
    return new PromotionList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionList {
    return new PromotionList().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionList | PlainMessage<PromotionList> | undefined, b: PromotionList | PlainMessage<PromotionList> | undefined): boolean {
    return proto2.util.equals(PromotionList, a, b);
  }
}

/**
 * PromotionMechanisms describes how to incorporate Freight into a Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionMechanisms
 */
export class PromotionMechanisms extends Message<PromotionMechanisms> {
  /**
   * Origin disambiguates the origin from which artifacts used by this promotion
   * mechanism must have originated. This is especially useful in cases where a
   * Stage may request Freight from multiples origins (e.g. multiple Warehouses)
   * and some of those each reference different versions of artifacts from the
   * same repository. This field is optional. Its value is overridable by
   * child promotion mechanisms.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightOrigin origin = 3;
   */
  origin?: FreightOrigin;

  /**
   * GitRepoUpdates describes updates that should be applied to Git repositories
   * to incorporate Freight into the Stage. This field is optional, as such
   * actions are not required in all cases.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.GitRepoUpdate gitRepoUpdates = 1;
   */
  gitRepoUpdates: GitRepoUpdate[] = [];

  /**
   * ArgoCDAppUpdates describes updates that should be applied to Argo CD
   * Application resources to incorporate Freight into the Stage. This field is
   * optional, as such actions are not required in all cases. Note that all
   * updates specified by the GitRepoUpdates field, if any, are applied BEFORE
   * these.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.ArgoCDAppUpdate argoCDAppUpdates = 2;
   */
  argoCDAppUpdates: ArgoCDAppUpdate[] = [];

  constructor(data?: PartialMessage<PromotionMechanisms>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionMechanisms";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 3, name: "origin", kind: "message", T: FreightOrigin, opt: true },
    { no: 1, name: "gitRepoUpdates", kind: "message", T: GitRepoUpdate, repeated: true },
    { no: 2, name: "argoCDAppUpdates", kind: "message", T: ArgoCDAppUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionMechanisms {
    return new PromotionMechanisms().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionMechanisms {
    return new PromotionMechanisms().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionMechanisms {
    return new PromotionMechanisms().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionMechanisms | PlainMessage<PromotionMechanisms> | undefined, b: PromotionMechanisms | PlainMessage<PromotionMechanisms> | undefined): boolean {
    return proto2.util.equals(PromotionMechanisms, a, b);
  }
}

/**
 * PromotionPolicy defines policies governing the promotion of Freight to a
 * specific Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionPolicy
 */
export class PromotionPolicy extends Message<PromotionPolicy> {
  /**
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string stage = 1;
   */
  stage?: string;

  /**
   * AutoPromotionEnabled indicates whether new Freight can automatically be
   * promoted into the Stage referenced by the Stage field. Note: There are may
   * be other conditions also required for an auto-promotion to occur. This
   * field defaults to false, but is commonly set to true for Stages that
   * subscribe to Warehouses instead of other, upstream Stages. This allows
   * users to define Stages that are automatically updated as soon as new
   * artifacts are detected.
   *
   * @generated from field: optional bool autoPromotionEnabled = 2;
   */
  autoPromotionEnabled?: boolean;

  constructor(data?: PartialMessage<PromotionPolicy>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionPolicy";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "stage", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "autoPromotionEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionPolicy {
    return new PromotionPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionPolicy {
    return new PromotionPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionPolicy {
    return new PromotionPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionPolicy | PlainMessage<PromotionPolicy> | undefined, b: PromotionPolicy | PlainMessage<PromotionPolicy> | undefined): boolean {
    return proto2.util.equals(PromotionPolicy, a, b);
  }
}

/**
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionReference
 */
export class PromotionReference extends Message<PromotionReference> {
  /**
   * Name is the name of the Promotion
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * Freight is the freight being promoted
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightReference freight = 2;
   */
  freight?: FreightReference;

  /**
   * Status is the (optional) status of the promotion
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionStatus status = 3;
   */
  status?: PromotionStatus;

  /**
   * FinishedAt is the time at which the Promotion was completed.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 4;
   */
  finishedAt?: Time;

  constructor(data?: PartialMessage<PromotionReference>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionReference";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "freight", kind: "message", T: FreightReference, opt: true },
    { no: 3, name: "status", kind: "message", T: PromotionStatus, opt: true },
    { no: 4, name: "finishedAt", kind: "message", T: Time, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionReference {
    return new PromotionReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionReference {
    return new PromotionReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionReference {
    return new PromotionReference().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionReference | PlainMessage<PromotionReference> | undefined, b: PromotionReference | PlainMessage<PromotionReference> | undefined): boolean {
    return proto2.util.equals(PromotionReference, a, b);
  }
}

/**
 * PromotionSpec describes the desired transition of a specific Stage into a
 * specific Freight.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionSpec
 */
export class PromotionSpec extends Message<PromotionSpec> {
  /**
   * Stage specifies the name of the Stage to which this Promotion
   * applies. The Stage referenced by this field MUST be in the same
   * namespace as the Promotion.
   *
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
   *
   * @generated from field: optional string stage = 1;
   */
  stage?: string;

  /**
   * Freight specifies the piece of Freight to be promoted into the Stage
   * referenced by the Stage field.
   *
   * +kubebuilder:validation:MinLength=1
   *
   * @generated from field: optional string freight = 2;
   */
  freight?: string;

  constructor(data?: PartialMessage<PromotionSpec>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionSpec";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "stage", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "freight", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionSpec {
    return new PromotionSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionSpec {
    return new PromotionSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionSpec {
    return new PromotionSpec().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionSpec | PlainMessage<PromotionSpec> | undefined, b: PromotionSpec | PlainMessage<PromotionSpec> | undefined): boolean {
    return proto2.util.equals(PromotionSpec, a, b);
  }
}

/**
 * PromotionStatus describes the current state of the transition represented by
 * a Promotion.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PromotionStatus
 */
export class PromotionStatus extends Message<PromotionStatus> {
  /**
   * LastHandledRefresh holds the value of the most recent AnnotationKeyRefresh
   * annotation that was handled by the controller. This field can be used to
   * determine whether the request to refresh the resource has been handled.
   * +optional
   *
   * @generated from field: optional string lastHandledRefresh = 4;
   */
  lastHandledRefresh?: string;

  /**
   * Phase describes where the Promotion currently is in its lifecycle.
   *
   * @generated from field: optional string phase = 1;
   */
  phase?: string;

  /**
   * Message is a display message about the promotion, including any errors
   * preventing the Promotion controller from executing this Promotion.
   * i.e. If the Phase field has a value of Failed, this field can be expected
   * to explain why.
   *
   * @generated from field: optional string message = 2;
   */
  message?: string;

  /**
   * Metadata holds arbitrary metadata set by promotion mechanisms
   * (e.g. for display purposes, or internal bookkeeping)
   *
   * @generated from field: map<string, string> metadata = 3;
   */
  metadata: { [key: string]: string } = {};

  /**
   * Freight is the detail of the piece of freight that was referenced by this promotion.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightReference freight = 5;
   */
  freight?: FreightReference;

  /**
   * FreightCollection contains the details of the piece of Freight referenced
   * by this Promotion as well as any additional Freight that is carried over
   * from the target Stage's current state.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.FreightCollection freightCollection = 7;
   */
  freightCollection?: FreightCollection;

  /**
   * FinishedAt is the time when the promotion was completed.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;
   */
  finishedAt?: Time;

  constructor(data?: PartialMessage<PromotionStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PromotionStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 4, name: "lastHandledRefresh", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 1, name: "phase", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "freight", kind: "message", T: FreightReference, opt: true },
    { no: 7, name: "freightCollection", kind: "message", T: FreightCollection, opt: true },
    { no: 6, name: "finishedAt", kind: "message", T: Time, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotionStatus {
    return new PromotionStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotionStatus {
    return new PromotionStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotionStatus {
    return new PromotionStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PromotionStatus | PlainMessage<PromotionStatus> | undefined, b: PromotionStatus | PlainMessage<PromotionStatus> | undefined): boolean {
    return proto2.util.equals(PromotionStatus, a, b);
  }
}

/**
 * PullRequestPromotionMechanism describes how to generate a pull request against the write branch during promotion
 * Attempts to infer the git provider from well-known git domains.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.PullRequestPromotionMechanism
 */
export class PullRequestPromotionMechanism extends Message<PullRequestPromotionMechanism> {
  /**
   * GitHub indicates git provider is GitHub
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.GitHubPullRequest github = 1;
   */
  github?: GitHubPullRequest;

  /**
   * GitLab indicates git provider is GitLab
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.GitLabPullRequest gitlab = 2;
   */
  gitlab?: GitLabPullRequest;

  constructor(data?: PartialMessage<PullRequestPromotionMechanism>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.PullRequestPromotionMechanism";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "github", kind: "message", T: GitHubPullRequest, opt: true },
    { no: 2, name: "gitlab", kind: "message", T: GitLabPullRequest, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PullRequestPromotionMechanism {
    return new PullRequestPromotionMechanism().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PullRequestPromotionMechanism {
    return new PullRequestPromotionMechanism().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PullRequestPromotionMechanism {
    return new PullRequestPromotionMechanism().fromJsonString(jsonString, options);
  }

  static equals(a: PullRequestPromotionMechanism | PlainMessage<PullRequestPromotionMechanism> | undefined, b: PullRequestPromotionMechanism | PlainMessage<PullRequestPromotionMechanism> | undefined): boolean {
    return proto2.util.equals(PullRequestPromotionMechanism, a, b);
  }
}

/**
 * RepoSubscription describes a subscription to ONE OF a Git repository, a
 * container image repository, or a Helm chart repository.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.RepoSubscription
 */
export class RepoSubscription extends Message<RepoSubscription> {
  /**
   * Git describes a subscriptions to a Git repository.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.GitSubscription git = 1;
   */
  git?: GitSubscription;

  /**
   * Image describes a subscription to container image repository.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ImageSubscription image = 2;
   */
  image?: ImageSubscription;

  /**
   * Chart describes a subscription to a Helm chart repository.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.ChartSubscription chart = 3;
   */
  chart?: ChartSubscription;

  constructor(data?: PartialMessage<RepoSubscription>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.RepoSubscription";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "git", kind: "message", T: GitSubscription, opt: true },
    { no: 2, name: "image", kind: "message", T: ImageSubscription, opt: true },
    { no: 3, name: "chart", kind: "message", T: ChartSubscription, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepoSubscription {
    return new RepoSubscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepoSubscription {
    return new RepoSubscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepoSubscription {
    return new RepoSubscription().fromJsonString(jsonString, options);
  }

  static equals(a: RepoSubscription | PlainMessage<RepoSubscription> | undefined, b: RepoSubscription | PlainMessage<RepoSubscription> | undefined): boolean {
    return proto2.util.equals(RepoSubscription, a, b);
  }
}

/**
 * Stage is the Kargo API's main type.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Stage
 */
export class Stage extends Message<Stage> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec describes sources of Freight used by the Stage and how to incorporate
   * Freight into the Stage.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.StageSpec spec = 2;
   */
  spec?: StageSpec;

  /**
   * Status describes the Stage's current and recent Freight, health, and more.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.StageStatus status = 3;
   */
  status?: StageStatus;

  constructor(data?: PartialMessage<Stage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Stage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ObjectMeta, opt: true },
    { no: 2, name: "spec", kind: "message", T: StageSpec, opt: true },
    { no: 3, name: "status", kind: "message", T: StageStatus, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Stage {
    return new Stage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Stage {
    return new Stage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Stage {
    return new Stage().fromJsonString(jsonString, options);
  }

  static equals(a: Stage | PlainMessage<Stage> | undefined, b: Stage | PlainMessage<Stage> | undefined): boolean {
    return proto2.util.equals(Stage, a, b);
  }
}

/**
 * StageList is a list of Stage resources.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.StageList
 */
export class StageList extends Message<StageList> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Stage items = 2;
   */
  items: Stage[] = [];

  constructor(data?: PartialMessage<StageList>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.StageList";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ListMeta, opt: true },
    { no: 2, name: "items", kind: "message", T: Stage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StageList {
    return new StageList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StageList {
    return new StageList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StageList {
    return new StageList().fromJsonString(jsonString, options);
  }

  static equals(a: StageList | PlainMessage<StageList> | undefined, b: StageList | PlainMessage<StageList> | undefined): boolean {
    return proto2.util.equals(StageList, a, b);
  }
}

/**
 * StageSpec describes the sources of Freight used by a Stage and how to
 * incorporate Freight into the Stage.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.StageSpec
 */
export class StageSpec extends Message<StageSpec> {
  /**
   * Shard is the name of the shard that this Stage belongs to. This is an
   * optional field. If not specified, the Stage will belong to the default
   * shard. A defaulting webhook will sync the value of the
   * kargo.akuity.io/shard label with the value of this field. When this field
   * is empty, the webhook will ensure that label is absent.
   *
   * @generated from field: optional string shard = 4;
   */
  shard?: string;

  /**
   * RequestedFreight expresses the Stage's need for certain pieces of Freight,
   * each having originated from a particular Warehouse. This list must be
   * non-empty. In the common case, a Stage will request Freight having
   * originated from just one specific Warehouse. In advanced cases, requesting
   * Freight from multiple Warehouses provides a method of advancing new
   * artifacts of different types through parallel pipelines at different
   * speeds. This can be useful, for instance, if a Stage is home to multiple
   * microservices that are independently versioned.
   *
   * +kubebuilder:validation:MinItems=1
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.FreightRequest requestedFreight = 5;
   */
  requestedFreight: FreightRequest[] = [];

  /**
   * PromotionMechanisms describes how to incorporate Freight into the Stage.
   * This is an optional field as it is sometimes useful to aggregates available
   * Freight from multiple upstream Stages without performing any actions. The
   * utility of this is to allow multiple downstream Stages to subscribe to a
   * single upstream Stage where they may otherwise have subscribed to multiple
   * upstream Stages.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionMechanisms promotionMechanisms = 2;
   */
  promotionMechanisms?: PromotionMechanisms;

  /**
   * Verification describes how to verify a Stage's current Freight is fit for
   * promotion downstream.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.Verification verification = 3;
   */
  verification?: Verification;

  constructor(data?: PartialMessage<StageSpec>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.StageSpec";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 4, name: "shard", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "requestedFreight", kind: "message", T: FreightRequest, repeated: true },
    { no: 2, name: "promotionMechanisms", kind: "message", T: PromotionMechanisms, opt: true },
    { no: 3, name: "verification", kind: "message", T: Verification, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StageSpec {
    return new StageSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StageSpec {
    return new StageSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StageSpec {
    return new StageSpec().fromJsonString(jsonString, options);
  }

  static equals(a: StageSpec | PlainMessage<StageSpec> | undefined, b: StageSpec | PlainMessage<StageSpec> | undefined): boolean {
    return proto2.util.equals(StageSpec, a, b);
  }
}

/**
 * StageStatus describes a Stages's current and recent Freight, health, and
 * more.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.StageStatus
 */
export class StageStatus extends Message<StageStatus> {
  /**
   * LastHandledRefresh holds the value of the most recent AnnotationKeyRefresh
   * annotation that was handled by the controller. This field can be used to
   * determine whether the request to refresh the resource has been handled.
   * +optional
   *
   * @generated from field: optional string lastHandledRefresh = 11;
   */
  lastHandledRefresh?: string;

  /**
   * Phase describes where the Stage currently is in its lifecycle.
   *
   * @generated from field: optional string phase = 1;
   */
  phase?: string;

  /**
   * FreightHistory is a list of recent Freight selections that were deployed
   * to the Stage. By default, the last ten Freight selections are stored.
   * The first item in the list is the most recent Freight selection and
   * currently deployed to the Stage, subsequent items are older selections.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.FreightCollection freightHistory = 4;
   */
  freightHistory: FreightCollection[] = [];

  /**
   * FreightSummary is human-readable text maintained by the controller that
   * summarizes what Freight is currently deployed to the Stage. For Stages that
   * request a single piece of Freight AND the request has been fulfilled, this
   * field will simply contain the name of the Freight. For Stages that request
   * a single piece of Freight AND the request has NOT been fulfilled, or for
   * Stages that request multiple pieces of Freight, this field will contain a
   * summary of fulfilled/requested Freight. The existence of this field is a
   * workaround for kubectl limitations so that this complex but valuable
   * information can be displayed in a column in response to `kubectl get
   * stages`.
   *
   * @generated from field: optional string freightSummary = 12;
   */
  freightSummary?: string;

  /**
   * Health is the Stage's last observed health.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.Health health = 8;
   */
  health?: Health;

  /**
   * Message describes any errors that are preventing the Stage controller
   * from assessing Stage health or from finding new Freight.
   *
   * @generated from field: optional string message = 9;
   */
  message?: string;

  /**
   * ObservedGeneration represents the .metadata.generation that this Stage
   * status was reconciled against.
   *
   * @generated from field: optional int64 observedGeneration = 6;
   */
  observedGeneration?: bigint;

  /**
   * CurrentPromotion is a reference to the currently Running promotion.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionReference currentPromotion = 7;
   */
  currentPromotion?: PromotionReference;

  /**
   * LastPromotion is a reference to the last completed promotion.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.PromotionReference lastPromotion = 10;
   */
  lastPromotion?: PromotionReference;

  constructor(data?: PartialMessage<StageStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.StageStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 11, name: "lastHandledRefresh", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 1, name: "phase", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "freightHistory", kind: "message", T: FreightCollection, repeated: true },
    { no: 12, name: "freightSummary", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "health", kind: "message", T: Health, opt: true },
    { no: 9, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "observedGeneration", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 7, name: "currentPromotion", kind: "message", T: PromotionReference, opt: true },
    { no: 10, name: "lastPromotion", kind: "message", T: PromotionReference, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StageStatus {
    return new StageStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StageStatus {
    return new StageStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StageStatus {
    return new StageStatus().fromJsonString(jsonString, options);
  }

  static equals(a: StageStatus | PlainMessage<StageStatus> | undefined, b: StageStatus | PlainMessage<StageStatus> | undefined): boolean {
    return proto2.util.equals(StageStatus, a, b);
  }
}

/**
 * Verification describes how to verify that a Promotion has been successful
 * using Argo Rollouts AnalysisTemplates.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Verification
 */
export class Verification extends Message<Verification> {
  /**
   * AnalysisTemplates is a list of AnalysisTemplates from which AnalysisRuns
   * should be created to verify a Stage's current Freight is fit to be promoted
   * downstream.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.AnalysisTemplateReference analysisTemplates = 1;
   */
  analysisTemplates: AnalysisTemplateReference[] = [];

  /**
   * AnalysisRunMetadata contains optional metadata that should be applied to
   * all AnalysisRuns.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.AnalysisRunMetadata analysisRunMetadata = 2;
   */
  analysisRunMetadata?: AnalysisRunMetadata;

  /**
   * Args lists arguments that should be added to all AnalysisRuns.
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.AnalysisRunArgument args = 3;
   */
  args: AnalysisRunArgument[] = [];

  constructor(data?: PartialMessage<Verification>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Verification";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "analysisTemplates", kind: "message", T: AnalysisTemplateReference, repeated: true },
    { no: 2, name: "analysisRunMetadata", kind: "message", T: AnalysisRunMetadata, opt: true },
    { no: 3, name: "args", kind: "message", T: AnalysisRunArgument, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Verification {
    return new Verification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Verification {
    return new Verification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Verification {
    return new Verification().fromJsonString(jsonString, options);
  }

  static equals(a: Verification | PlainMessage<Verification> | undefined, b: Verification | PlainMessage<Verification> | undefined): boolean {
    return proto2.util.equals(Verification, a, b);
  }
}

/**
 * VerificationInfo contains the details of an instance of a Verification
 * process.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.VerificationInfo
 */
export class VerificationInfo extends Message<VerificationInfo> {
  /**
   * ID is the identifier of the Verification process.
   *
   * @generated from field: optional string id = 4;
   */
  id?: string;

  /**
   * Actor is the name of the entity that initiated or aborted the
   * Verification process.
   *
   * @generated from field: optional string actor = 7;
   */
  actor?: string;

  /**
   * StartTime is the time at which the Verification process was started.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 5;
   */
  startTime?: Time;

  /**
   * Phase describes the current phase of the Verification process. Generally,
   * this will be a reflection of the underlying AnalysisRun's phase, however,
   * there are exceptions to this, such as in the case where an AnalysisRun
   * cannot be launched successfully.
   *
   * @generated from field: optional string phase = 1;
   */
  phase?: string;

  /**
   * Message may contain additional information about why the verification
   * process is in its current phase.
   *
   * @generated from field: optional string message = 2;
   */
  message?: string;

  /**
   * AnalysisRun is a reference to the Argo Rollouts AnalysisRun that implements
   * the Verification process.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.AnalysisRunReference analysisRun = 3;
   */
  analysisRun?: AnalysisRunReference;

  /**
   * FinishTime is the time at which the Verification process finished.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishTime = 6;
   */
  finishTime?: Time;

  constructor(data?: PartialMessage<VerificationInfo>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.VerificationInfo";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 4, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "actor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "startTime", kind: "message", T: Time, opt: true },
    { no: 1, name: "phase", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "analysisRun", kind: "message", T: AnalysisRunReference, opt: true },
    { no: 6, name: "finishTime", kind: "message", T: Time, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationInfo {
    return new VerificationInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationInfo {
    return new VerificationInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationInfo {
    return new VerificationInfo().fromJsonString(jsonString, options);
  }

  static equals(a: VerificationInfo | PlainMessage<VerificationInfo> | undefined, b: VerificationInfo | PlainMessage<VerificationInfo> | undefined): boolean {
    return proto2.util.equals(VerificationInfo, a, b);
  }
}

/**
 * VerifiedStage describes a Stage in which Freight has been verified.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.VerifiedStage
 */
export class VerifiedStage extends Message<VerifiedStage> {
  constructor(data?: PartialMessage<VerifiedStage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.VerifiedStage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerifiedStage {
    return new VerifiedStage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerifiedStage {
    return new VerifiedStage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerifiedStage {
    return new VerifiedStage().fromJsonString(jsonString, options);
  }

  static equals(a: VerifiedStage | PlainMessage<VerifiedStage> | undefined, b: VerifiedStage | PlainMessage<VerifiedStage> | undefined): boolean {
    return proto2.util.equals(VerifiedStage, a, b);
  }
}

/**
 * Warehouse is a source of Freight.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.Warehouse
 */
export class Warehouse extends Message<Warehouse> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec describes sources of artifacts.
   *
   * +kubebuilder:validation:Required
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.WarehouseSpec spec = 2;
   */
  spec?: WarehouseSpec;

  /**
   * Status describes the Warehouse's most recently observed state.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.WarehouseStatus status = 3;
   */
  status?: WarehouseStatus;

  constructor(data?: PartialMessage<Warehouse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.Warehouse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ObjectMeta, opt: true },
    { no: 2, name: "spec", kind: "message", T: WarehouseSpec, opt: true },
    { no: 3, name: "status", kind: "message", T: WarehouseStatus, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Warehouse {
    return new Warehouse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Warehouse {
    return new Warehouse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Warehouse {
    return new Warehouse().fromJsonString(jsonString, options);
  }

  static equals(a: Warehouse | PlainMessage<Warehouse> | undefined, b: Warehouse | PlainMessage<Warehouse> | undefined): boolean {
    return proto2.util.equals(Warehouse, a, b);
  }
}

/**
 * WarehouseList is a list of Warehouse resources.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.WarehouseList
 */
export class WarehouseList extends Message<WarehouseList> {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.Warehouse items = 2;
   */
  items: Warehouse[] = [];

  constructor(data?: PartialMessage<WarehouseList>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.WarehouseList";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ListMeta, opt: true },
    { no: 2, name: "items", kind: "message", T: Warehouse, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WarehouseList {
    return new WarehouseList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WarehouseList {
    return new WarehouseList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WarehouseList {
    return new WarehouseList().fromJsonString(jsonString, options);
  }

  static equals(a: WarehouseList | PlainMessage<WarehouseList> | undefined, b: WarehouseList | PlainMessage<WarehouseList> | undefined): boolean {
    return proto2.util.equals(WarehouseList, a, b);
  }
}

/**
 * WarehouseSpec describes sources of versioned artifacts to be included in
 * Freight produced by this Warehouse.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.WarehouseSpec
 */
export class WarehouseSpec extends Message<WarehouseSpec> {
  /**
   * Shard is the name of the shard that this Warehouse belongs to. This is an
   * optional field. If not specified, the Warehouse will belong to the default
   * shard. A defaulting webhook will sync this field with the value of the
   * kargo.akuity.io/shard label. When the shard label is not present or differs
   * from the value of this field, the defaulting webhook will set the label to
   * the value of this field. If the shard label is present and this field is
   * empty, the defaulting webhook will set the value of this field to the value
   * of the shard label.
   *
   * @generated from field: optional string shard = 2;
   */
  shard?: string;

  /**
   * Interval is the reconciliation interval for this Warehouse. On each
   * reconciliation, the Warehouse will discover new artifacts and optionally
   * produce new Freight. This field is optional. When left unspecified, the
   * field is implicitly treated as if its value were "5m0s".
   *
   * +kubebuilder:validation:Type=string
   * +kubebuilder:validation:Pattern="^([0-9]+(\\.[0-9]+)?(s|m|h))+$"
   * +kubebuilder:default="5m0s"
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration interval = 4;
   */
  interval?: Duration;

  /**
   * FreightCreationPolicy describes how Freight is created by this Warehouse.
   * This field is optional. When left unspecified, the field is implicitly
   * treated as if its value were "Automatic".
   *
   * +kubebuilder:default=Automatic
   * +kubebuilder:validation:Optional
   *
   * @generated from field: optional string freightCreationPolicy = 3;
   */
  freightCreationPolicy?: string;

  /**
   * Subscriptions describes sources of artifacts to be included in Freight
   * produced by this Warehouse.
   *
   * +kubebuilder:validation:MinItems=1
   *
   * @generated from field: repeated github.com.akuity.kargo.api.v1alpha1.RepoSubscription subscriptions = 1;
   */
  subscriptions: RepoSubscription[] = [];

  constructor(data?: PartialMessage<WarehouseSpec>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.WarehouseSpec";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 2, name: "shard", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "interval", kind: "message", T: Duration, opt: true },
    { no: 3, name: "freightCreationPolicy", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 1, name: "subscriptions", kind: "message", T: RepoSubscription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WarehouseSpec {
    return new WarehouseSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WarehouseSpec {
    return new WarehouseSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WarehouseSpec {
    return new WarehouseSpec().fromJsonString(jsonString, options);
  }

  static equals(a: WarehouseSpec | PlainMessage<WarehouseSpec> | undefined, b: WarehouseSpec | PlainMessage<WarehouseSpec> | undefined): boolean {
    return proto2.util.equals(WarehouseSpec, a, b);
  }
}

/**
 * WarehouseStatus describes a Warehouse's most recently observed state.
 *
 * @generated from message github.com.akuity.kargo.api.v1alpha1.WarehouseStatus
 */
export class WarehouseStatus extends Message<WarehouseStatus> {
  /**
   * Conditions contains the last observations of the Warehouse's current
   * state.
   * +patchMergeKey=type
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=type
   *
   * @generated from field: repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 9;
   */
  conditions: Condition[] = [];

  /**
   * LastHandledRefresh holds the value of the most recent AnnotationKeyRefresh
   * annotation that was handled by the controller. This field can be used to
   * determine whether the request to refresh the resource has been handled.
   * +optional
   *
   * @generated from field: optional string lastHandledRefresh = 6;
   */
  lastHandledRefresh?: string;

  /**
   * ObservedGeneration represents the .metadata.generation that this Warehouse
   * was reconciled against.
   *
   * @generated from field: optional int64 observedGeneration = 4;
   */
  observedGeneration?: bigint;

  /**
   * LastFreightID is a reference to the system-assigned identifier (name) of
   * the most recent Freight produced by the Warehouse.
   *
   * @generated from field: optional string lastFreightID = 8;
   */
  lastFreightID?: string;

  /**
   * DiscoveredArtifacts holds the artifacts discovered by the Warehouse.
   *
   * @generated from field: optional github.com.akuity.kargo.api.v1alpha1.DiscoveredArtifacts discoveredArtifacts = 7;
   */
  discoveredArtifacts?: DiscoveredArtifacts;

  constructor(data?: PartialMessage<WarehouseStatus>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "github.com.akuity.kargo.api.v1alpha1.WarehouseStatus";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 9, name: "conditions", kind: "message", T: Condition, repeated: true },
    { no: 6, name: "lastHandledRefresh", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "observedGeneration", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 8, name: "lastFreightID", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "discoveredArtifacts", kind: "message", T: DiscoveredArtifacts, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WarehouseStatus {
    return new WarehouseStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WarehouseStatus {
    return new WarehouseStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WarehouseStatus {
    return new WarehouseStatus().fromJsonString(jsonString, options);
  }

  static equals(a: WarehouseStatus | PlainMessage<WarehouseStatus> | undefined, b: WarehouseStatus | PlainMessage<WarehouseStatus> | undefined): boolean {
    return proto2.util.equals(WarehouseStatus, a, b);
  }
}

