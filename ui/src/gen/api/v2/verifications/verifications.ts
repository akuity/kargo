/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * Kargo API
 * REST API for Kargo
 * OpenAPI spec version: v1alpha1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetAnalysisRun200,
  GetAnalysisRunLogsParams,
  GetAnalysisTemplate200,
  GetClusterAnalysisTemplate200,
  ListAnalysisTemplates200,
  ListClusterAnalysisTemplates200
} from '.././models';

import { customFetch } from '../../../../lib/api/custom-fetch';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Retrieve an AnalysisRun resource from a project's namespace.
 * @summary Retrieve an AnalysisRun
 */
export type getAnalysisRunResponse200 = {
  data: GetAnalysisRun200;
  status: 200;
};

export type getAnalysisRunResponseSuccess = getAnalysisRunResponse200 & {
  headers: Headers;
};
export type getAnalysisRunResponse = getAnalysisRunResponseSuccess;

export const getGetAnalysisRunUrl = (project: string, analysisRun: string) => {
  return `/v1beta1/projects/${project}/analysis-runs/${analysisRun}`;
};

export const getAnalysisRun = async (
  project: string,
  analysisRun: string,
  options?: RequestInit
): Promise<getAnalysisRunResponse> => {
  return customFetch<getAnalysisRunResponse>(getGetAnalysisRunUrl(project, analysisRun), {
    ...options,
    method: 'GET'
  });
};

export const getGetAnalysisRunQueryKey = (project?: string, analysisRun?: string) => {
  return [`/v1beta1/projects/${project}/analysis-runs/${analysisRun}`] as const;
};

export const getGetAnalysisRunQueryOptions = <
  TData = Awaited<ReturnType<typeof getAnalysisRun>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRun>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAnalysisRunQueryKey(project, analysisRun);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnalysisRun>>> = () =>
    getAnalysisRun(project, analysisRun, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && analysisRun),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRun>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetAnalysisRunQueryResult = NonNullable<Awaited<ReturnType<typeof getAnalysisRun>>>;
export type GetAnalysisRunQueryError = unknown;

export function useGetAnalysisRun<
  TData = Awaited<ReturnType<typeof getAnalysisRun>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRun>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnalysisRun>>,
          TError,
          Awaited<ReturnType<typeof getAnalysisRun>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAnalysisRun<
  TData = Awaited<ReturnType<typeof getAnalysisRun>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRun>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnalysisRun>>,
          TError,
          Awaited<ReturnType<typeof getAnalysisRun>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAnalysisRun<
  TData = Awaited<ReturnType<typeof getAnalysisRun>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRun>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve an AnalysisRun
 */

export function useGetAnalysisRun<
  TData = Awaited<ReturnType<typeof getAnalysisRun>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRun>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAnalysisRunQueryOptions(project, analysisRun, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Stream logs from an AnalysisRun job as Server-Sent Events (SSE).
 * @summary Stream AnalysisRun logs
 */
export type getAnalysisRunLogsResponse200 = {
  data: string;
  status: 200;
};

export type getAnalysisRunLogsResponseSuccess = getAnalysisRunLogsResponse200 & {
  headers: Headers;
};
export type getAnalysisRunLogsResponse = getAnalysisRunLogsResponseSuccess;

export const getGetAnalysisRunLogsUrl = (
  project: string,
  analysisRun: string,
  params?: GetAnalysisRunLogsParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1beta1/projects/${project}/analysis-runs/${analysisRun}/logs?${stringifiedParams}`
    : `/v1beta1/projects/${project}/analysis-runs/${analysisRun}/logs`;
};

export const getAnalysisRunLogs = async (
  project: string,
  analysisRun: string,
  params?: GetAnalysisRunLogsParams,
  options?: RequestInit
): Promise<getAnalysisRunLogsResponse> => {
  return customFetch<getAnalysisRunLogsResponse>(
    getGetAnalysisRunLogsUrl(project, analysisRun, params),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetAnalysisRunLogsQueryKey = (
  project?: string,
  analysisRun?: string,
  params?: GetAnalysisRunLogsParams
) => {
  return [
    `/v1beta1/projects/${project}/analysis-runs/${analysisRun}/logs`,
    ...(params ? [params] : [])
  ] as const;
};

export const getGetAnalysisRunLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAnalysisRunLogs>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  params?: GetAnalysisRunLogsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRunLogs>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAnalysisRunLogsQueryKey(project, analysisRun, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnalysisRunLogs>>> = () =>
    getAnalysisRunLogs(project, analysisRun, params, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && analysisRun),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRunLogs>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetAnalysisRunLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAnalysisRunLogs>>
>;
export type GetAnalysisRunLogsQueryError = unknown;

export function useGetAnalysisRunLogs<
  TData = Awaited<ReturnType<typeof getAnalysisRunLogs>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  params: undefined | GetAnalysisRunLogsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRunLogs>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnalysisRunLogs>>,
          TError,
          Awaited<ReturnType<typeof getAnalysisRunLogs>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAnalysisRunLogs<
  TData = Awaited<ReturnType<typeof getAnalysisRunLogs>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  params?: GetAnalysisRunLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRunLogs>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnalysisRunLogs>>,
          TError,
          Awaited<ReturnType<typeof getAnalysisRunLogs>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAnalysisRunLogs<
  TData = Awaited<ReturnType<typeof getAnalysisRunLogs>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  params?: GetAnalysisRunLogsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRunLogs>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Stream AnalysisRun logs
 */

export function useGetAnalysisRunLogs<
  TData = Awaited<ReturnType<typeof getAnalysisRunLogs>>,
  TError = unknown
>(
  project: string,
  analysisRun: string,
  params?: GetAnalysisRunLogsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnalysisRunLogs>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAnalysisRunLogsQueryOptions(project, analysisRun, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * List AnalysisTemplate resources from a project's namespace.
 * @summary List AnalysisTemplates
 */
export type listAnalysisTemplatesResponse200 = {
  data: ListAnalysisTemplates200;
  status: 200;
};

export type listAnalysisTemplatesResponseSuccess = listAnalysisTemplatesResponse200 & {
  headers: Headers;
};
export type listAnalysisTemplatesResponse = listAnalysisTemplatesResponseSuccess;

export const getListAnalysisTemplatesUrl = (project: string) => {
  return `/v1beta1/projects/${project}/analysis-templates`;
};

export const listAnalysisTemplates = async (
  project: string,
  options?: RequestInit
): Promise<listAnalysisTemplatesResponse> => {
  return customFetch<listAnalysisTemplatesResponse>(getListAnalysisTemplatesUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getListAnalysisTemplatesQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/analysis-templates`] as const;
};

export const getListAnalysisTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof listAnalysisTemplates>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAnalysisTemplates>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListAnalysisTemplatesQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listAnalysisTemplates>>> = () =>
    listAnalysisTemplates(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAnalysisTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListAnalysisTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAnalysisTemplates>>
>;
export type ListAnalysisTemplatesQueryError = unknown;

export function useListAnalysisTemplates<
  TData = Awaited<ReturnType<typeof listAnalysisTemplates>>,
  TError = unknown
>(
  project: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAnalysisTemplates>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAnalysisTemplates>>,
          TError,
          Awaited<ReturnType<typeof listAnalysisTemplates>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListAnalysisTemplates<
  TData = Awaited<ReturnType<typeof listAnalysisTemplates>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAnalysisTemplates>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAnalysisTemplates>>,
          TError,
          Awaited<ReturnType<typeof listAnalysisTemplates>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListAnalysisTemplates<
  TData = Awaited<ReturnType<typeof listAnalysisTemplates>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAnalysisTemplates>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List AnalysisTemplates
 */

export function useListAnalysisTemplates<
  TData = Awaited<ReturnType<typeof listAnalysisTemplates>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAnalysisTemplates>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListAnalysisTemplatesQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve an AnalysisTemplate resource from a project's
namespace.
 * @summary Retrieve an AnalysisTemplate
 */
export type getAnalysisTemplateResponse200 = {
  data: GetAnalysisTemplate200;
  status: 200;
};

export type getAnalysisTemplateResponseSuccess = getAnalysisTemplateResponse200 & {
  headers: Headers;
};
export type getAnalysisTemplateResponse = getAnalysisTemplateResponseSuccess;

export const getGetAnalysisTemplateUrl = (project: string, analysisTemplate: string) => {
  return `/v1beta1/projects/${project}/analysis-templates/${analysisTemplate}`;
};

export const getAnalysisTemplate = async (
  project: string,
  analysisTemplate: string,
  options?: RequestInit
): Promise<getAnalysisTemplateResponse> => {
  return customFetch<getAnalysisTemplateResponse>(
    getGetAnalysisTemplateUrl(project, analysisTemplate),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetAnalysisTemplateQueryKey = (project?: string, analysisTemplate?: string) => {
  return [`/v1beta1/projects/${project}/analysis-templates/${analysisTemplate}`] as const;
};

export const getGetAnalysisTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof getAnalysisTemplate>>,
  TError = unknown
>(
  project: string,
  analysisTemplate: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAnalysisTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAnalysisTemplateQueryKey(project, analysisTemplate);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnalysisTemplate>>> = () =>
    getAnalysisTemplate(project, analysisTemplate, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && analysisTemplate),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getAnalysisTemplate>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetAnalysisTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAnalysisTemplate>>
>;
export type GetAnalysisTemplateQueryError = unknown;

export function useGetAnalysisTemplate<
  TData = Awaited<ReturnType<typeof getAnalysisTemplate>>,
  TError = unknown
>(
  project: string,
  analysisTemplate: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAnalysisTemplate>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnalysisTemplate>>,
          TError,
          Awaited<ReturnType<typeof getAnalysisTemplate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAnalysisTemplate<
  TData = Awaited<ReturnType<typeof getAnalysisTemplate>>,
  TError = unknown
>(
  project: string,
  analysisTemplate: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAnalysisTemplate>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnalysisTemplate>>,
          TError,
          Awaited<ReturnType<typeof getAnalysisTemplate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAnalysisTemplate<
  TData = Awaited<ReturnType<typeof getAnalysisTemplate>>,
  TError = unknown
>(
  project: string,
  analysisTemplate: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAnalysisTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve an AnalysisTemplate
 */

export function useGetAnalysisTemplate<
  TData = Awaited<ReturnType<typeof getAnalysisTemplate>>,
  TError = unknown
>(
  project: string,
  analysisTemplate: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAnalysisTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAnalysisTemplateQueryOptions(project, analysisTemplate, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete an AnalysisTemplate resource from a project's namespace.
 * @summary Delete an AnalysisTemplate
 */
export type deleteAnalysisTemplateResponse204 = {
  data: void;
  status: 204;
};

export type deleteAnalysisTemplateResponseSuccess = deleteAnalysisTemplateResponse204 & {
  headers: Headers;
};
export type deleteAnalysisTemplateResponse = deleteAnalysisTemplateResponseSuccess;

export const getDeleteAnalysisTemplateUrl = (project: string, analysisTemplate: string) => {
  return `/v1beta1/projects/${project}/analysis-templates/${analysisTemplate}`;
};

export const deleteAnalysisTemplate = async (
  project: string,
  analysisTemplate: string,
  options?: RequestInit
): Promise<deleteAnalysisTemplateResponse> => {
  return customFetch<deleteAnalysisTemplateResponse>(
    getDeleteAnalysisTemplateUrl(project, analysisTemplate),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteAnalysisTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAnalysisTemplate>>,
    TError,
    { project: string; analysisTemplate: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAnalysisTemplate>>,
  TError,
  { project: string; analysisTemplate: string },
  TContext
> => {
  const mutationKey = ['deleteAnalysisTemplate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAnalysisTemplate>>,
    { project: string; analysisTemplate: string }
  > = (props) => {
    const { project, analysisTemplate } = props ?? {};

    return deleteAnalysisTemplate(project, analysisTemplate, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAnalysisTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAnalysisTemplate>>
>;

export type DeleteAnalysisTemplateMutationError = unknown;

/**
 * @summary Delete an AnalysisTemplate
 */
export const useDeleteAnalysisTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAnalysisTemplate>>,
      TError,
      { project: string; analysisTemplate: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAnalysisTemplate>>,
  TError,
  { project: string; analysisTemplate: string },
  TContext
> => {
  const mutationOptions = getDeleteAnalysisTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Trigger re-verification of the Freight currently in use by a
Stage.
 * @summary Reverify Freight
 */
export type reverifyResponse200 = {
  data: void;
  status: 200;
};

export type reverifyResponseSuccess = reverifyResponse200 & {
  headers: Headers;
};
export type reverifyResponse = reverifyResponseSuccess;

export const getReverifyUrl = (project: string, stage: string) => {
  return `/v1beta1/projects/${project}/stages/${stage}/verification`;
};

export const reverify = async (
  project: string,
  stage: string,
  options?: RequestInit
): Promise<reverifyResponse> => {
  return customFetch<reverifyResponse>(getReverifyUrl(project, stage), {
    ...options,
    method: 'POST'
  });
};

export const getReverifyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reverify>>,
    TError,
    { project: string; stage: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reverify>>,
  TError,
  { project: string; stage: string },
  TContext
> => {
  const mutationKey = ['reverify'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reverify>>,
    { project: string; stage: string }
  > = (props) => {
    const { project, stage } = props ?? {};

    return reverify(project, stage, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReverifyMutationResult = NonNullable<Awaited<ReturnType<typeof reverify>>>;

export type ReverifyMutationError = unknown;

/**
 * @summary Reverify Freight
 */
export const useReverify = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reverify>>,
      TError,
      { project: string; stage: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof reverify>>,
  TError,
  { project: string; stage: string },
  TContext
> => {
  const mutationOptions = getReverifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Abort a running Verification process.
 * @summary Abort a running Verification process
 */
export type abortVerificationResponse200 = {
  data: void;
  status: 200;
};

export type abortVerificationResponseSuccess = abortVerificationResponse200 & {
  headers: Headers;
};
export type abortVerificationResponse = abortVerificationResponseSuccess;

export const getAbortVerificationUrl = (project: string, stage: string) => {
  return `/v1beta1/projects/${project}/stages/${stage}/verification/abort`;
};

export const abortVerification = async (
  project: string,
  stage: string,
  options?: RequestInit
): Promise<abortVerificationResponse> => {
  return customFetch<abortVerificationResponse>(getAbortVerificationUrl(project, stage), {
    ...options,
    method: 'POST'
  });
};

export const getAbortVerificationMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof abortVerification>>,
    TError,
    { project: string; stage: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof abortVerification>>,
  TError,
  { project: string; stage: string },
  TContext
> => {
  const mutationKey = ['abortVerification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof abortVerification>>,
    { project: string; stage: string }
  > = (props) => {
    const { project, stage } = props ?? {};

    return abortVerification(project, stage, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AbortVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof abortVerification>>
>;

export type AbortVerificationMutationError = unknown;

/**
 * @summary Abort a running Verification process
 */
export const useAbortVerification = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof abortVerification>>,
      TError,
      { project: string; stage: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof abortVerification>>,
  TError,
  { project: string; stage: string },
  TContext
> => {
  const mutationOptions = getAbortVerificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List ClusterAnalysisTemplate resources. Returns a
ClusterAnalysisTemplateList resource.
 * @summary List ClusterAnalysisTemplates
 */
export type listClusterAnalysisTemplatesResponse200 = {
  data: ListClusterAnalysisTemplates200;
  status: 200;
};

export type listClusterAnalysisTemplatesResponseSuccess =
  listClusterAnalysisTemplatesResponse200 & {
    headers: Headers;
  };
export type listClusterAnalysisTemplatesResponse = listClusterAnalysisTemplatesResponseSuccess;

export const getListClusterAnalysisTemplatesUrl = () => {
  return `/v1beta1/shared/cluster-analysis-templates`;
};

export const listClusterAnalysisTemplates = async (
  options?: RequestInit
): Promise<listClusterAnalysisTemplatesResponse> => {
  return customFetch<listClusterAnalysisTemplatesResponse>(getListClusterAnalysisTemplatesUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListClusterAnalysisTemplatesQueryKey = () => {
  return [`/v1beta1/shared/cluster-analysis-templates`] as const;
};

export const getListClusterAnalysisTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof listClusterAnalysisTemplates>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listClusterAnalysisTemplates>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListClusterAnalysisTemplatesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listClusterAnalysisTemplates>>> = () =>
    listClusterAnalysisTemplates(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listClusterAnalysisTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListClusterAnalysisTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listClusterAnalysisTemplates>>
>;
export type ListClusterAnalysisTemplatesQueryError = unknown;

export function useListClusterAnalysisTemplates<
  TData = Awaited<ReturnType<typeof listClusterAnalysisTemplates>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listClusterAnalysisTemplates>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listClusterAnalysisTemplates>>,
          TError,
          Awaited<ReturnType<typeof listClusterAnalysisTemplates>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListClusterAnalysisTemplates<
  TData = Awaited<ReturnType<typeof listClusterAnalysisTemplates>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listClusterAnalysisTemplates>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listClusterAnalysisTemplates>>,
          TError,
          Awaited<ReturnType<typeof listClusterAnalysisTemplates>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListClusterAnalysisTemplates<
  TData = Awaited<ReturnType<typeof listClusterAnalysisTemplates>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listClusterAnalysisTemplates>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List ClusterAnalysisTemplates
 */

export function useListClusterAnalysisTemplates<
  TData = Awaited<ReturnType<typeof listClusterAnalysisTemplates>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listClusterAnalysisTemplates>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListClusterAnalysisTemplatesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a ClusterAnalysisTemplate by name.
 * @summary Retrieve a ClusterAnalysisTemplate
 */
export type getClusterAnalysisTemplateResponse200 = {
  data: GetClusterAnalysisTemplate200;
  status: 200;
};

export type getClusterAnalysisTemplateResponseSuccess = getClusterAnalysisTemplateResponse200 & {
  headers: Headers;
};
export type getClusterAnalysisTemplateResponse = getClusterAnalysisTemplateResponseSuccess;

export const getGetClusterAnalysisTemplateUrl = (clusterAnalysisTemplate: string) => {
  return `/v1beta1/shared/cluster-analysis-templates/${clusterAnalysisTemplate}`;
};

export const getClusterAnalysisTemplate = async (
  clusterAnalysisTemplate: string,
  options?: RequestInit
): Promise<getClusterAnalysisTemplateResponse> => {
  return customFetch<getClusterAnalysisTemplateResponse>(
    getGetClusterAnalysisTemplateUrl(clusterAnalysisTemplate),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetClusterAnalysisTemplateQueryKey = (clusterAnalysisTemplate?: string) => {
  return [`/v1beta1/shared/cluster-analysis-templates/${clusterAnalysisTemplate}`] as const;
};

export const getGetClusterAnalysisTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterAnalysisTemplate>>,
  TError = unknown
>(
  clusterAnalysisTemplate: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterAnalysisTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterAnalysisTemplateQueryKey(clusterAnalysisTemplate);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterAnalysisTemplate>>> = () =>
    getClusterAnalysisTemplate(clusterAnalysisTemplate, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!clusterAnalysisTemplate,
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getClusterAnalysisTemplate>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetClusterAnalysisTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterAnalysisTemplate>>
>;
export type GetClusterAnalysisTemplateQueryError = unknown;

export function useGetClusterAnalysisTemplate<
  TData = Awaited<ReturnType<typeof getClusterAnalysisTemplate>>,
  TError = unknown
>(
  clusterAnalysisTemplate: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterAnalysisTemplate>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClusterAnalysisTemplate>>,
          TError,
          Awaited<ReturnType<typeof getClusterAnalysisTemplate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetClusterAnalysisTemplate<
  TData = Awaited<ReturnType<typeof getClusterAnalysisTemplate>>,
  TError = unknown
>(
  clusterAnalysisTemplate: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterAnalysisTemplate>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClusterAnalysisTemplate>>,
          TError,
          Awaited<ReturnType<typeof getClusterAnalysisTemplate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetClusterAnalysisTemplate<
  TData = Awaited<ReturnType<typeof getClusterAnalysisTemplate>>,
  TError = unknown
>(
  clusterAnalysisTemplate: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterAnalysisTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a ClusterAnalysisTemplate
 */

export function useGetClusterAnalysisTemplate<
  TData = Awaited<ReturnType<typeof getClusterAnalysisTemplate>>,
  TError = unknown
>(
  clusterAnalysisTemplate: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterAnalysisTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetClusterAnalysisTemplateQueryOptions(clusterAnalysisTemplate, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a ClusterAnalysisTemplate resource.
 * @summary Delete a ClusterAnalysisTemplate
 */
export type deleteClusterAnalysisTemplateResponse204 = {
  data: void;
  status: 204;
};

export type deleteClusterAnalysisTemplateResponseSuccess =
  deleteClusterAnalysisTemplateResponse204 & {
    headers: Headers;
  };
export type deleteClusterAnalysisTemplateResponse = deleteClusterAnalysisTemplateResponseSuccess;

export const getDeleteClusterAnalysisTemplateUrl = (clusterAnalysisTemplate: string) => {
  return `/v1beta1/shared/cluster-analysis-templates/${clusterAnalysisTemplate}`;
};

export const deleteClusterAnalysisTemplate = async (
  clusterAnalysisTemplate: string,
  options?: RequestInit
): Promise<deleteClusterAnalysisTemplateResponse> => {
  return customFetch<deleteClusterAnalysisTemplateResponse>(
    getDeleteClusterAnalysisTemplateUrl(clusterAnalysisTemplate),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteClusterAnalysisTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterAnalysisTemplate>>,
    TError,
    { clusterAnalysisTemplate: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClusterAnalysisTemplate>>,
  TError,
  { clusterAnalysisTemplate: string },
  TContext
> => {
  const mutationKey = ['deleteClusterAnalysisTemplate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterAnalysisTemplate>>,
    { clusterAnalysisTemplate: string }
  > = (props) => {
    const { clusterAnalysisTemplate } = props ?? {};

    return deleteClusterAnalysisTemplate(clusterAnalysisTemplate, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterAnalysisTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterAnalysisTemplate>>
>;

export type DeleteClusterAnalysisTemplateMutationError = unknown;

/**
 * @summary Delete a ClusterAnalysisTemplate
 */
export const useDeleteClusterAnalysisTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteClusterAnalysisTemplate>>,
      TError,
      { clusterAnalysisTemplate: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteClusterAnalysisTemplate>>,
  TError,
  { clusterAnalysisTemplate: string },
  TContext
> => {
  const mutationOptions = getDeleteClusterAnalysisTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
