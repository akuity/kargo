/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * Kargo API
 * REST API for Kargo
 * OpenAPI spec version: v1alpha1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApproveFreightParams,
  CreateConfigMapRequestBody,
  CreateProjectConfigMap201,
  CreateSharedConfigMap201,
  CreateSystemConfigMap201,
  GetClusterPromotionTask200,
  GetFreight200,
  GetProject200,
  GetProjectConfig200,
  GetProjectConfigMap200,
  GetPromotion200,
  GetPromotionTask200,
  GetSharedConfigMap200,
  GetStage200,
  GetSystemConfigMap200,
  GetWarehouse200,
  ListClusterPromotionTasks200,
  ListImages200,
  ListProjectConfigMaps200,
  ListProjects200,
  ListPromotionTasks200,
  ListPromotions200,
  ListPromotionsParams,
  ListSharedConfigMaps200,
  ListStages200,
  ListSystemConfigMaps200,
  ListWarehouses200,
  PatchConfigMapRequestBody,
  PatchFreightAliasParams,
  PatchProjectConfigMap200,
  PatchSharedConfigMap200,
  PatchSystemConfigMap200,
  PromoteDownstream201,
  PromoteDownstreamRequest,
  PromoteToStage201,
  PromoteToStageRequest,
  QueryFreightsRest200,
  QueryFreightsRestParams,
  UpdateConfigMapRequestBody,
  UpdateProjectConfigMap200,
  UpdateSharedConfigMap200,
  UpdateSystemConfigMap200
} from '.././models';

import { customFetch } from '../../../../lib/api/custom-fetch';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * List all Projects resources. Returns a ProjectList resource.
 * @summary List projects
 */
export type listProjectsResponse200 = {
  data: ListProjects200;
  status: 200;
};

export type listProjectsResponseSuccess = listProjectsResponse200 & {
  headers: Headers;
};
export type listProjectsResponse = listProjectsResponseSuccess;

export const getListProjectsUrl = () => {
  return `/v1beta1/projects`;
};

export const listProjects = async (options?: RequestInit): Promise<listProjectsResponse> => {
  return customFetch<listProjectsResponse>(getListProjectsUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListProjectsQueryKey = () => {
  return [`/v1beta1/projects`] as const;
};

export const getListProjectsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProjects>>,
  TError = unknown
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjects>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListProjectsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProjects>>> = () =>
    listProjects(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProjects>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof listProjects>>>;
export type ListProjectsQueryError = unknown;

export function useListProjects<TData = Awaited<ReturnType<typeof listProjects>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjects>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjects>>,
          TError,
          Awaited<ReturnType<typeof listProjects>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjects<TData = Awaited<ReturnType<typeof listProjects>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjects>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjects>>,
          TError,
          Awaited<ReturnType<typeof listProjects>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjects<TData = Awaited<ReturnType<typeof listProjects>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjects>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List projects
 */

export function useListProjects<TData = Awaited<ReturnType<typeof listProjects>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjects>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListProjectsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a Project resource.
 * @summary Retrieve a Project resource
 */
export type getProjectResponse200 = {
  data: GetProject200;
  status: 200;
};

export type getProjectResponseSuccess = getProjectResponse200 & {
  headers: Headers;
};
export type getProjectResponse = getProjectResponseSuccess;

export const getGetProjectUrl = (project: string) => {
  return `/v1beta1/projects/${project}`;
};

export const getProject = async (
  project: string,
  options?: RequestInit
): Promise<getProjectResponse> => {
  return customFetch<getProjectResponse>(getGetProjectUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getGetProjectQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}`] as const;
};

export const getGetProjectQueryOptions = <
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProjectQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = () =>
    getProject(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>;
export type GetProjectQueryError = unknown;

export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = unknown>(
  project: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          Awaited<ReturnType<typeof getProject>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          Awaited<ReturnType<typeof getProject>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a Project resource
 */

export function useGetProject<TData = Awaited<ReturnType<typeof getProject>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProjectQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a Project resource and its associated namespace.
 * @summary Delete a Project
 */
export type deleteProjectResponse204 = {
  data: void;
  status: 204;
};

export type deleteProjectResponseSuccess = deleteProjectResponse204 & {
  headers: Headers;
};
export type deleteProjectResponse = deleteProjectResponseSuccess;

export const getDeleteProjectUrl = (project: string) => {
  return `/v1beta1/projects/${project}`;
};

export const deleteProject = async (
  project: string,
  options?: RequestInit
): Promise<deleteProjectResponse> => {
  return customFetch<deleteProjectResponse>(getDeleteProjectUrl(project), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteProjectMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProject>>,
    TError,
    { project: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProject>>,
  TError,
  { project: string },
  TContext
> => {
  const mutationKey = ['deleteProject'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProject>>,
    { project: string }
  > = (props) => {
    const { project } = props ?? {};

    return deleteProject(project, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProject>>>;

export type DeleteProjectMutationError = unknown;

/**
 * @summary Delete a Project
 */
export const useDeleteProject = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProject>>,
      TError,
      { project: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProject>>,
  TError,
  { project: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve the single ProjectConfig resource from a project's
namespace.
 * @summary Retrieve ProjectConfig
 */
export type getProjectConfigResponse200 = {
  data: GetProjectConfig200;
  status: 200;
};

export type getProjectConfigResponseSuccess = getProjectConfigResponse200 & {
  headers: Headers;
};
export type getProjectConfigResponse = getProjectConfigResponseSuccess;

export const getGetProjectConfigUrl = (project: string) => {
  return `/v1beta1/projects/${project}/config`;
};

export const getProjectConfig = async (
  project: string,
  options?: RequestInit
): Promise<getProjectConfigResponse> => {
  return customFetch<getProjectConfigResponse>(getGetProjectConfigUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getGetProjectConfigQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/config`] as const;
};

export const getGetProjectConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectConfig>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProjectConfigQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectConfig>>> = () =>
    getProjectConfig(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectConfig>>>;
export type GetProjectConfigQueryError = unknown;

export function useGetProjectConfig<
  TData = Awaited<ReturnType<typeof getProjectConfig>>,
  TError = unknown
>(
  project: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectConfig>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectConfig>>,
          TError,
          Awaited<ReturnType<typeof getProjectConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectConfig<
  TData = Awaited<ReturnType<typeof getProjectConfig>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectConfig>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectConfig>>,
          TError,
          Awaited<ReturnType<typeof getProjectConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectConfig<
  TData = Awaited<ReturnType<typeof getProjectConfig>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve ProjectConfig
 */

export function useGetProjectConfig<
  TData = Awaited<ReturnType<typeof getProjectConfig>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProjectConfigQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete the single ProjectConfig resource from a project's
namespace.
 * @summary Delete a ProjectConfig resource
 */
export type deleteProjectConfigResponse204 = {
  data: void;
  status: 204;
};

export type deleteProjectConfigResponseSuccess = deleteProjectConfigResponse204 & {
  headers: Headers;
};
export type deleteProjectConfigResponse = deleteProjectConfigResponseSuccess;

export const getDeleteProjectConfigUrl = (project: string) => {
  return `/v1beta1/projects/${project}/config`;
};

export const deleteProjectConfig = async (
  project: string,
  options?: RequestInit
): Promise<deleteProjectConfigResponse> => {
  return customFetch<deleteProjectConfigResponse>(getDeleteProjectConfigUrl(project), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteProjectConfigMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectConfig>>,
    TError,
    { project: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectConfig>>,
  TError,
  { project: string },
  TContext
> => {
  const mutationKey = ['deleteProjectConfig'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectConfig>>,
    { project: string }
  > = (props) => {
    const { project } = props ?? {};

    return deleteProjectConfig(project, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectConfig>>
>;

export type DeleteProjectConfigMutationError = unknown;

/**
 * @summary Delete a ProjectConfig resource
 */
export const useDeleteProjectConfig = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProjectConfig>>,
      TError,
      { project: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectConfig>>,
  TError,
  { project: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Refresh the single ProjectConfig resource in a project's
namespace. Refreshing enqueues the resource for reconciliation
by its corresponding controller.
 * @summary Refresh ProjectConfig
 */
export type refreshProjectConfigResponse200 = {
  data: void;
  status: 200;
};

export type refreshProjectConfigResponseSuccess = refreshProjectConfigResponse200 & {
  headers: Headers;
};
export type refreshProjectConfigResponse = refreshProjectConfigResponseSuccess;

export const getRefreshProjectConfigUrl = (project: string) => {
  return `/v1beta1/projects/${project}/config/refresh`;
};

export const refreshProjectConfig = async (
  project: string,
  options?: RequestInit
): Promise<refreshProjectConfigResponse> => {
  return customFetch<refreshProjectConfigResponse>(getRefreshProjectConfigUrl(project), {
    ...options,
    method: 'POST'
  });
};

export const getRefreshProjectConfigMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshProjectConfig>>,
    TError,
    { project: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshProjectConfig>>,
  TError,
  { project: string },
  TContext
> => {
  const mutationKey = ['refreshProjectConfig'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshProjectConfig>>,
    { project: string }
  > = (props) => {
    const { project } = props ?? {};

    return refreshProjectConfig(project, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshProjectConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshProjectConfig>>
>;

export type RefreshProjectConfigMutationError = unknown;

/**
 * @summary Refresh ProjectConfig
 */
export const useRefreshProjectConfig = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshProjectConfig>>,
      TError,
      { project: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refreshProjectConfig>>,
  TError,
  { project: string },
  TContext
> => {
  const mutationOptions = getRefreshProjectConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List ConfigMap resources from a project's namespace. Returns a
Kubernetes ConfigMapList resource.
 * @summary List project-level ConfigMaps
 */
export type listProjectConfigMapsResponse200 = {
  data: ListProjectConfigMaps200;
  status: 200;
};

export type listProjectConfigMapsResponseSuccess = listProjectConfigMapsResponse200 & {
  headers: Headers;
};
export type listProjectConfigMapsResponse = listProjectConfigMapsResponseSuccess;

export const getListProjectConfigMapsUrl = (project: string) => {
  return `/v1beta1/projects/${project}/configmaps`;
};

export const listProjectConfigMaps = async (
  project: string,
  options?: RequestInit
): Promise<listProjectConfigMapsResponse> => {
  return customFetch<listProjectConfigMapsResponse>(getListProjectConfigMapsUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getListProjectConfigMapsQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/configmaps`] as const;
};

export const getListProjectConfigMapsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProjectConfigMaps>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectConfigMaps>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListProjectConfigMapsQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProjectConfigMaps>>> = () =>
    listProjectConfigMaps(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProjectConfigMaps>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListProjectConfigMapsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listProjectConfigMaps>>
>;
export type ListProjectConfigMapsQueryError = unknown;

export function useListProjectConfigMaps<
  TData = Awaited<ReturnType<typeof listProjectConfigMaps>>,
  TError = unknown
>(
  project: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectConfigMaps>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectConfigMaps>>,
          TError,
          Awaited<ReturnType<typeof listProjectConfigMaps>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectConfigMaps<
  TData = Awaited<ReturnType<typeof listProjectConfigMaps>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectConfigMaps>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectConfigMaps>>,
          TError,
          Awaited<ReturnType<typeof listProjectConfigMaps>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectConfigMaps<
  TData = Awaited<ReturnType<typeof listProjectConfigMaps>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectConfigMaps>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List project-level ConfigMaps
 */

export function useListProjectConfigMaps<
  TData = Awaited<ReturnType<typeof listProjectConfigMaps>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectConfigMaps>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListProjectConfigMapsQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a ConfigMap in a project's namespace. Returns the created
Kubernetes ConfigMap resource.
 * @summary Create a project-level ConfigMap
 */
export type createProjectConfigMapResponse201 = {
  data: CreateProjectConfigMap201;
  status: 201;
};

export type createProjectConfigMapResponseSuccess = createProjectConfigMapResponse201 & {
  headers: Headers;
};
export type createProjectConfigMapResponse = createProjectConfigMapResponseSuccess;

export const getCreateProjectConfigMapUrl = (project: string) => {
  return `/v1beta1/projects/${project}/configmaps`;
};

export const createProjectConfigMap = async (
  project: string,
  createConfigMapRequestBody: CreateConfigMapRequestBody,
  options?: RequestInit
): Promise<createProjectConfigMapResponse> => {
  return customFetch<createProjectConfigMapResponse>(getCreateProjectConfigMapUrl(project), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createConfigMapRequestBody)
  });
};

export const getCreateProjectConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectConfigMap>>,
    TError,
    { project: string; data: CreateConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectConfigMap>>,
  TError,
  { project: string; data: CreateConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['createProjectConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectConfigMap>>,
    { project: string; data: CreateConfigMapRequestBody }
  > = (props) => {
    const { project, data } = props ?? {};

    return createProjectConfigMap(project, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProjectConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectConfigMap>>
>;
export type CreateProjectConfigMapMutationBody = CreateConfigMapRequestBody;
export type CreateProjectConfigMapMutationError = unknown;

/**
 * @summary Create a project-level ConfigMap
 */
export const useCreateProjectConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProjectConfigMap>>,
      TError,
      { project: string; data: CreateConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProjectConfigMap>>,
  TError,
  { project: string; data: CreateConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getCreateProjectConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve a ConfigMap by name from a project's namespace.
 * @summary Retrieve a project-level ConfigMap
 */
export type getProjectConfigMapResponse200 = {
  data: GetProjectConfigMap200;
  status: 200;
};

export type getProjectConfigMapResponseSuccess = getProjectConfigMapResponse200 & {
  headers: Headers;
};
export type getProjectConfigMapResponse = getProjectConfigMapResponseSuccess;

export const getGetProjectConfigMapUrl = (project: string, configmap: string) => {
  return `/v1beta1/projects/${project}/configmaps/${configmap}`;
};

export const getProjectConfigMap = async (
  project: string,
  configmap: string,
  options?: RequestInit
): Promise<getProjectConfigMapResponse> => {
  return customFetch<getProjectConfigMapResponse>(getGetProjectConfigMapUrl(project, configmap), {
    ...options,
    method: 'GET'
  });
};

export const getGetProjectConfigMapQueryKey = (project?: string, configmap?: string) => {
  return [`/v1beta1/projects/${project}/configmaps/${configmap}`] as const;
};

export const getGetProjectConfigMapQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectConfigMap>>,
  TError = unknown
>(
  project: string,
  configmap: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectConfigMap>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProjectConfigMapQueryKey(project, configmap);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectConfigMap>>> = () =>
    getProjectConfigMap(project, configmap, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && configmap),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getProjectConfigMap>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetProjectConfigMapQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectConfigMap>>
>;
export type GetProjectConfigMapQueryError = unknown;

export function useGetProjectConfigMap<
  TData = Awaited<ReturnType<typeof getProjectConfigMap>>,
  TError = unknown
>(
  project: string,
  configmap: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectConfigMap>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectConfigMap>>,
          TError,
          Awaited<ReturnType<typeof getProjectConfigMap>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectConfigMap<
  TData = Awaited<ReturnType<typeof getProjectConfigMap>>,
  TError = unknown
>(
  project: string,
  configmap: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectConfigMap>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectConfigMap>>,
          TError,
          Awaited<ReturnType<typeof getProjectConfigMap>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectConfigMap<
  TData = Awaited<ReturnType<typeof getProjectConfigMap>>,
  TError = unknown
>(
  project: string,
  configmap: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectConfigMap>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a project-level ConfigMap
 */

export function useGetProjectConfigMap<
  TData = Awaited<ReturnType<typeof getProjectConfigMap>>,
  TError = unknown
>(
  project: string,
  configmap: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectConfigMap>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProjectConfigMapQueryOptions(project, configmap, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replace a ConfigMap in a project's namespace. All existing data
is replaced. Returns the updated Kubernetes ConfigMap resource.
 * @summary Replace a project-level ConfigMap
 */
export type updateProjectConfigMapResponse200 = {
  data: UpdateProjectConfigMap200;
  status: 200;
};

export type updateProjectConfigMapResponseSuccess = updateProjectConfigMapResponse200 & {
  headers: Headers;
};
export type updateProjectConfigMapResponse = updateProjectConfigMapResponseSuccess;

export const getUpdateProjectConfigMapUrl = (project: string, configmap: string) => {
  return `/v1beta1/projects/${project}/configmaps/${configmap}`;
};

export const updateProjectConfigMap = async (
  project: string,
  configmap: string,
  updateConfigMapRequestBody: UpdateConfigMapRequestBody,
  options?: RequestInit
): Promise<updateProjectConfigMapResponse> => {
  return customFetch<updateProjectConfigMapResponse>(
    getUpdateProjectConfigMapUrl(project, configmap),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(updateConfigMapRequestBody)
    }
  );
};

export const getUpdateProjectConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectConfigMap>>,
    TError,
    { project: string; configmap: string; data: UpdateConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProjectConfigMap>>,
  TError,
  { project: string; configmap: string; data: UpdateConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['updateProjectConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProjectConfigMap>>,
    { project: string; configmap: string; data: UpdateConfigMapRequestBody }
  > = (props) => {
    const { project, configmap, data } = props ?? {};

    return updateProjectConfigMap(project, configmap, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProjectConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProjectConfigMap>>
>;
export type UpdateProjectConfigMapMutationBody = UpdateConfigMapRequestBody;
export type UpdateProjectConfigMapMutationError = unknown;

/**
 * @summary Replace a project-level ConfigMap
 */
export const useUpdateProjectConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProjectConfigMap>>,
      TError,
      { project: string; configmap: string; data: UpdateConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProjectConfigMap>>,
  TError,
  { project: string; configmap: string; data: UpdateConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateProjectConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a ConfigMap from a project's namespace.
 * @summary Delete a project-level ConfigMap
 */
export type deleteProjectConfigMapResponse204 = {
  data: void;
  status: 204;
};

export type deleteProjectConfigMapResponseSuccess = deleteProjectConfigMapResponse204 & {
  headers: Headers;
};
export type deleteProjectConfigMapResponse = deleteProjectConfigMapResponseSuccess;

export const getDeleteProjectConfigMapUrl = (project: string, configmap: string) => {
  return `/v1beta1/projects/${project}/configmaps/${configmap}`;
};

export const deleteProjectConfigMap = async (
  project: string,
  configmap: string,
  options?: RequestInit
): Promise<deleteProjectConfigMapResponse> => {
  return customFetch<deleteProjectConfigMapResponse>(
    getDeleteProjectConfigMapUrl(project, configmap),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteProjectConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectConfigMap>>,
    TError,
    { project: string; configmap: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectConfigMap>>,
  TError,
  { project: string; configmap: string },
  TContext
> => {
  const mutationKey = ['deleteProjectConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectConfigMap>>,
    { project: string; configmap: string }
  > = (props) => {
    const { project, configmap } = props ?? {};

    return deleteProjectConfigMap(project, configmap, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectConfigMap>>
>;

export type DeleteProjectConfigMapMutationError = unknown;

/**
 * @summary Delete a project-level ConfigMap
 */
export const useDeleteProjectConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProjectConfigMap>>,
      TError,
      { project: string; configmap: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectConfigMap>>,
  TError,
  { project: string; configmap: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch a ConfigMap in a project's namespace. Merges provided data
with existing data. Use removeKeys to delete specific keys.
Returns the updated Kubernetes ConfigMap resource.
 * @summary Patch a project-level ConfigMap
 */
export type patchProjectConfigMapResponse200 = {
  data: PatchProjectConfigMap200;
  status: 200;
};

export type patchProjectConfigMapResponseSuccess = patchProjectConfigMapResponse200 & {
  headers: Headers;
};
export type patchProjectConfigMapResponse = patchProjectConfigMapResponseSuccess;

export const getPatchProjectConfigMapUrl = (project: string, configmap: string) => {
  return `/v1beta1/projects/${project}/configmaps/${configmap}`;
};

export const patchProjectConfigMap = async (
  project: string,
  configmap: string,
  patchConfigMapRequestBody: PatchConfigMapRequestBody,
  options?: RequestInit
): Promise<patchProjectConfigMapResponse> => {
  return customFetch<patchProjectConfigMapResponse>(
    getPatchProjectConfigMapUrl(project, configmap),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchConfigMapRequestBody)
    }
  );
};

export const getPatchProjectConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchProjectConfigMap>>,
    TError,
    { project: string; configmap: string; data: PatchConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchProjectConfigMap>>,
  TError,
  { project: string; configmap: string; data: PatchConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['patchProjectConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchProjectConfigMap>>,
    { project: string; configmap: string; data: PatchConfigMapRequestBody }
  > = (props) => {
    const { project, configmap, data } = props ?? {};

    return patchProjectConfigMap(project, configmap, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchProjectConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchProjectConfigMap>>
>;
export type PatchProjectConfigMapMutationBody = PatchConfigMapRequestBody;
export type PatchProjectConfigMapMutationError = unknown;

/**
 * @summary Patch a project-level ConfigMap
 */
export const usePatchProjectConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchProjectConfigMap>>,
      TError,
      { project: string; configmap: string; data: PatchConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchProjectConfigMap>>,
  TError,
  { project: string; configmap: string; data: PatchConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getPatchProjectConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Query and filter Freight resources from a project's namespace.
 * @summary Query Freight
 */
export type queryFreightsRestResponse200 = {
  data: QueryFreightsRest200;
  status: 200;
};

export type queryFreightsRestResponseSuccess = queryFreightsRestResponse200 & {
  headers: Headers;
};
export type queryFreightsRestResponse = queryFreightsRestResponseSuccess;

export const getQueryFreightsRestUrl = (project: string, params?: QueryFreightsRestParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ['origins'];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1beta1/projects/${project}/freight?${stringifiedParams}`
    : `/v1beta1/projects/${project}/freight`;
};

export const queryFreightsRest = async (
  project: string,
  params?: QueryFreightsRestParams,
  options?: RequestInit
): Promise<queryFreightsRestResponse> => {
  return customFetch<queryFreightsRestResponse>(getQueryFreightsRestUrl(project, params), {
    ...options,
    method: 'GET'
  });
};

export const getQueryFreightsRestQueryKey = (
  project?: string,
  params?: QueryFreightsRestParams
) => {
  return [`/v1beta1/projects/${project}/freight`, ...(params ? [params] : [])] as const;
};

export const getQueryFreightsRestQueryOptions = <
  TData = Awaited<ReturnType<typeof queryFreightsRest>>,
  TError = unknown
>(
  project: string,
  params?: QueryFreightsRestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof queryFreightsRest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getQueryFreightsRestQueryKey(project, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof queryFreightsRest>>> = () =>
    queryFreightsRest(project, params, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof queryFreightsRest>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryFreightsRestQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryFreightsRest>>
>;
export type QueryFreightsRestQueryError = unknown;

export function useQueryFreightsRest<
  TData = Awaited<ReturnType<typeof queryFreightsRest>>,
  TError = unknown
>(
  project: string,
  params: undefined | QueryFreightsRestParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof queryFreightsRest>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queryFreightsRest>>,
          TError,
          Awaited<ReturnType<typeof queryFreightsRest>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useQueryFreightsRest<
  TData = Awaited<ReturnType<typeof queryFreightsRest>>,
  TError = unknown
>(
  project: string,
  params?: QueryFreightsRestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof queryFreightsRest>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queryFreightsRest>>,
          TError,
          Awaited<ReturnType<typeof queryFreightsRest>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useQueryFreightsRest<
  TData = Awaited<ReturnType<typeof queryFreightsRest>>,
  TError = unknown
>(
  project: string,
  params?: QueryFreightsRestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof queryFreightsRest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Query Freight
 */

export function useQueryFreightsRest<
  TData = Awaited<ReturnType<typeof queryFreightsRest>>,
  TError = unknown
>(
  project: string,
  params?: QueryFreightsRestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof queryFreightsRest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getQueryFreightsRestQueryOptions(project, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a Freight resource from a project's namespace by name
or alias.
 * @summary Retrieve a Freight resource
 */
export type getFreightResponse200 = {
  data: GetFreight200;
  status: 200;
};

export type getFreightResponseSuccess = getFreightResponse200 & {
  headers: Headers;
};
export type getFreightResponse = getFreightResponseSuccess;

export const getGetFreightUrl = (project: string, freightNameOrAlias: string) => {
  return `/v1beta1/projects/${project}/freight/${freightNameOrAlias}`;
};

export const getFreight = async (
  project: string,
  freightNameOrAlias: string,
  options?: RequestInit
): Promise<getFreightResponse> => {
  return customFetch<getFreightResponse>(getGetFreightUrl(project, freightNameOrAlias), {
    ...options,
    method: 'GET'
  });
};

export const getGetFreightQueryKey = (project?: string, freightNameOrAlias?: string) => {
  return [`/v1beta1/projects/${project}/freight/${freightNameOrAlias}`] as const;
};

export const getGetFreightQueryOptions = <
  TData = Awaited<ReturnType<typeof getFreight>>,
  TError = unknown
>(
  project: string,
  freightNameOrAlias: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFreight>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFreightQueryKey(project, freightNameOrAlias);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFreight>>> = () =>
    getFreight(project, freightNameOrAlias, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && freightNameOrAlias),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getFreight>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetFreightQueryResult = NonNullable<Awaited<ReturnType<typeof getFreight>>>;
export type GetFreightQueryError = unknown;

export function useGetFreight<TData = Awaited<ReturnType<typeof getFreight>>, TError = unknown>(
  project: string,
  freightNameOrAlias: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFreight>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFreight>>,
          TError,
          Awaited<ReturnType<typeof getFreight>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetFreight<TData = Awaited<ReturnType<typeof getFreight>>, TError = unknown>(
  project: string,
  freightNameOrAlias: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFreight>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFreight>>,
          TError,
          Awaited<ReturnType<typeof getFreight>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetFreight<TData = Awaited<ReturnType<typeof getFreight>>, TError = unknown>(
  project: string,
  freightNameOrAlias: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFreight>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a Freight resource
 */

export function useGetFreight<TData = Awaited<ReturnType<typeof getFreight>>, TError = unknown>(
  project: string,
  freightNameOrAlias: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFreight>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFreightQueryOptions(project, freightNameOrAlias, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a Freight resource from a project's namespace by name or
alias.
 * @summary Delete a Freight resource
 */
export type deleteFreightResponse204 = {
  data: void;
  status: 204;
};

export type deleteFreightResponseSuccess = deleteFreightResponse204 & {
  headers: Headers;
};
export type deleteFreightResponse = deleteFreightResponseSuccess;

export const getDeleteFreightUrl = (project: string, freightNameOrAlias: string) => {
  return `/v1beta1/projects/${project}/freight/${freightNameOrAlias}`;
};

export const deleteFreight = async (
  project: string,
  freightNameOrAlias: string,
  options?: RequestInit
): Promise<deleteFreightResponse> => {
  return customFetch<deleteFreightResponse>(getDeleteFreightUrl(project, freightNameOrAlias), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteFreightMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFreight>>,
    TError,
    { project: string; freightNameOrAlias: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteFreight>>,
  TError,
  { project: string; freightNameOrAlias: string },
  TContext
> => {
  const mutationKey = ['deleteFreight'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFreight>>,
    { project: string; freightNameOrAlias: string }
  > = (props) => {
    const { project, freightNameOrAlias } = props ?? {};

    return deleteFreight(project, freightNameOrAlias, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteFreightMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFreight>>>;

export type DeleteFreightMutationError = unknown;

/**
 * @summary Delete a Freight resource
 */
export const useDeleteFreight = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteFreight>>,
      TError,
      { project: string; freightNameOrAlias: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteFreight>>,
  TError,
  { project: string; freightNameOrAlias: string },
  TContext
> => {
  const mutationOptions = getDeleteFreightMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch a Freight resource's human-friendly alias.
 * @summary Patch a Freight resource's alias
 */
export type patchFreightAliasResponse200 = {
  data: void;
  status: 200;
};

export type patchFreightAliasResponseSuccess = patchFreightAliasResponse200 & {
  headers: Headers;
};
export type patchFreightAliasResponse = patchFreightAliasResponseSuccess;

export const getPatchFreightAliasUrl = (
  project: string,
  freightNameOrAlias: string,
  params: PatchFreightAliasParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1beta1/projects/${project}/freight/${freightNameOrAlias}/alias?${stringifiedParams}`
    : `/v1beta1/projects/${project}/freight/${freightNameOrAlias}/alias`;
};

export const patchFreightAlias = async (
  project: string,
  freightNameOrAlias: string,
  params: PatchFreightAliasParams,
  options?: RequestInit
): Promise<patchFreightAliasResponse> => {
  return customFetch<patchFreightAliasResponse>(
    getPatchFreightAliasUrl(project, freightNameOrAlias, params),
    {
      ...options,
      method: 'PATCH'
    }
  );
};

export const getPatchFreightAliasMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchFreightAlias>>,
    TError,
    { project: string; freightNameOrAlias: string; params: PatchFreightAliasParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchFreightAlias>>,
  TError,
  { project: string; freightNameOrAlias: string; params: PatchFreightAliasParams },
  TContext
> => {
  const mutationKey = ['patchFreightAlias'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchFreightAlias>>,
    { project: string; freightNameOrAlias: string; params: PatchFreightAliasParams }
  > = (props) => {
    const { project, freightNameOrAlias, params } = props ?? {};

    return patchFreightAlias(project, freightNameOrAlias, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchFreightAliasMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchFreightAlias>>
>;

export type PatchFreightAliasMutationError = unknown;

/**
 * @summary Patch a Freight resource's alias
 */
export const usePatchFreightAlias = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchFreightAlias>>,
      TError,
      { project: string; freightNameOrAlias: string; params: PatchFreightAliasParams },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchFreightAlias>>,
  TError,
  { project: string; freightNameOrAlias: string; params: PatchFreightAliasParams },
  TContext
> => {
  const mutationOptions = getPatchFreightAliasMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Approve Freight for promotion to a Stage.
 * @summary Approve Freight for promotion to a Stage
 */
export type approveFreightResponse200 = {
  data: void;
  status: 200;
};

export type approveFreightResponseSuccess = approveFreightResponse200 & {
  headers: Headers;
};
export type approveFreightResponse = approveFreightResponseSuccess;

export const getApproveFreightUrl = (
  project: string,
  freightNameOrAlias: string,
  params: ApproveFreightParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1beta1/projects/${project}/freight/${freightNameOrAlias}/approve?${stringifiedParams}`
    : `/v1beta1/projects/${project}/freight/${freightNameOrAlias}/approve`;
};

export const approveFreight = async (
  project: string,
  freightNameOrAlias: string,
  params: ApproveFreightParams,
  options?: RequestInit
): Promise<approveFreightResponse> => {
  return customFetch<approveFreightResponse>(
    getApproveFreightUrl(project, freightNameOrAlias, params),
    {
      ...options,
      method: 'POST'
    }
  );
};

export const getApproveFreightMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof approveFreight>>,
    TError,
    { project: string; freightNameOrAlias: string; params: ApproveFreightParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof approveFreight>>,
  TError,
  { project: string; freightNameOrAlias: string; params: ApproveFreightParams },
  TContext
> => {
  const mutationKey = ['approveFreight'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof approveFreight>>,
    { project: string; freightNameOrAlias: string; params: ApproveFreightParams }
  > = (props) => {
    const { project, freightNameOrAlias, params } = props ?? {};

    return approveFreight(project, freightNameOrAlias, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApproveFreightMutationResult = NonNullable<Awaited<ReturnType<typeof approveFreight>>>;

export type ApproveFreightMutationError = unknown;

/**
 * @summary Approve Freight for promotion to a Stage
 */
export const useApproveFreight = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof approveFreight>>,
      TError,
      { project: string; freightNameOrAlias: string; params: ApproveFreightParams },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof approveFreight>>,
  TError,
  { project: string; freightNameOrAlias: string; params: ApproveFreightParams },
  TContext
> => {
  const mutationOptions = getApproveFreightMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List container images referenced by Freight resources in a
project's namespace.
 * @summary List container images
 */
export type listImagesResponse200 = {
  data: ListImages200;
  status: 200;
};

export type listImagesResponseSuccess = listImagesResponse200 & {
  headers: Headers;
};
export type listImagesResponse = listImagesResponseSuccess;

export const getListImagesUrl = (project: string) => {
  return `/v1beta1/projects/${project}/images`;
};

export const listImages = async (
  project: string,
  options?: RequestInit
): Promise<listImagesResponse> => {
  return customFetch<listImagesResponse>(getListImagesUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getListImagesQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/images`] as const;
};

export const getListImagesQueryOptions = <
  TData = Awaited<ReturnType<typeof listImages>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListImagesQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listImages>>> = () =>
    listImages(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listImages>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListImagesQueryResult = NonNullable<Awaited<ReturnType<typeof listImages>>>;
export type ListImagesQueryError = unknown;

export function useListImages<TData = Awaited<ReturnType<typeof listImages>>, TError = unknown>(
  project: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImages>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listImages>>,
          TError,
          Awaited<ReturnType<typeof listImages>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListImages<TData = Awaited<ReturnType<typeof listImages>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImages>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listImages>>,
          TError,
          Awaited<ReturnType<typeof listImages>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListImages<TData = Awaited<ReturnType<typeof listImages>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List container images
 */

export function useListImages<TData = Awaited<ReturnType<typeof listImages>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListImagesQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * List PromotionTask resources from a project's namespace. Returns
a PromotionTaskList resource.
 * @summary List PromotionTasks
 */
export type listPromotionTasksResponse200 = {
  data: ListPromotionTasks200;
  status: 200;
};

export type listPromotionTasksResponseSuccess = listPromotionTasksResponse200 & {
  headers: Headers;
};
export type listPromotionTasksResponse = listPromotionTasksResponseSuccess;

export const getListPromotionTasksUrl = (project: string) => {
  return `/v1beta1/projects/${project}/promotion-tasks`;
};

export const listPromotionTasks = async (
  project: string,
  options?: RequestInit
): Promise<listPromotionTasksResponse> => {
  return customFetch<listPromotionTasksResponse>(getListPromotionTasksUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getListPromotionTasksQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/promotion-tasks`] as const;
};

export const getListPromotionTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof listPromotionTasks>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotionTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListPromotionTasksQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listPromotionTasks>>> = () =>
    listPromotionTasks(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listPromotionTasks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListPromotionTasksQueryResult = NonNullable<
  Awaited<ReturnType<typeof listPromotionTasks>>
>;
export type ListPromotionTasksQueryError = unknown;

export function useListPromotionTasks<
  TData = Awaited<ReturnType<typeof listPromotionTasks>>,
  TError = unknown
>(
  project: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotionTasks>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPromotionTasks>>,
          TError,
          Awaited<ReturnType<typeof listPromotionTasks>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListPromotionTasks<
  TData = Awaited<ReturnType<typeof listPromotionTasks>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listPromotionTasks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPromotionTasks>>,
          TError,
          Awaited<ReturnType<typeof listPromotionTasks>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListPromotionTasks<
  TData = Awaited<ReturnType<typeof listPromotionTasks>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotionTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List PromotionTasks
 */

export function useListPromotionTasks<
  TData = Awaited<ReturnType<typeof listPromotionTasks>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotionTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListPromotionTasksQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a PromotionTask resource from a project's namespace.
 * @summary Retrieve a PromotionTask
 */
export type getPromotionTaskResponse200 = {
  data: GetPromotionTask200;
  status: 200;
};

export type getPromotionTaskResponseSuccess = getPromotionTaskResponse200 & {
  headers: Headers;
};
export type getPromotionTaskResponse = getPromotionTaskResponseSuccess;

export const getGetPromotionTaskUrl = (project: string, promotionTask: string) => {
  return `/v1beta1/projects/${project}/promotion-tasks/${promotionTask}`;
};

export const getPromotionTask = async (
  project: string,
  promotionTask: string,
  options?: RequestInit
): Promise<getPromotionTaskResponse> => {
  return customFetch<getPromotionTaskResponse>(getGetPromotionTaskUrl(project, promotionTask), {
    ...options,
    method: 'GET'
  });
};

export const getGetPromotionTaskQueryKey = (project?: string, promotionTask?: string) => {
  return [`/v1beta1/projects/${project}/promotion-tasks/${promotionTask}`] as const;
};

export const getGetPromotionTaskQueryOptions = <
  TData = Awaited<ReturnType<typeof getPromotionTask>>,
  TError = unknown
>(
  project: string,
  promotionTask: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotionTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPromotionTaskQueryKey(project, promotionTask);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPromotionTask>>> = () =>
    getPromotionTask(project, promotionTask, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && promotionTask),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getPromotionTask>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetPromotionTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getPromotionTask>>>;
export type GetPromotionTaskQueryError = unknown;

export function useGetPromotionTask<
  TData = Awaited<ReturnType<typeof getPromotionTask>>,
  TError = unknown
>(
  project: string,
  promotionTask: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotionTask>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPromotionTask>>,
          TError,
          Awaited<ReturnType<typeof getPromotionTask>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPromotionTask<
  TData = Awaited<ReturnType<typeof getPromotionTask>>,
  TError = unknown
>(
  project: string,
  promotionTask: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotionTask>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPromotionTask>>,
          TError,
          Awaited<ReturnType<typeof getPromotionTask>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPromotionTask<
  TData = Awaited<ReturnType<typeof getPromotionTask>>,
  TError = unknown
>(
  project: string,
  promotionTask: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotionTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a PromotionTask
 */

export function useGetPromotionTask<
  TData = Awaited<ReturnType<typeof getPromotionTask>>,
  TError = unknown
>(
  project: string,
  promotionTask: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotionTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPromotionTaskQueryOptions(project, promotionTask, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * List Promotion resources from a project's namespace. Returns a
PromotionList resource.
 * @summary List Promotions
 */
export type listPromotionsResponse200 = {
  data: ListPromotions200;
  status: 200;
};

export type listPromotionsResponseSuccess = listPromotionsResponse200 & {
  headers: Headers;
};
export type listPromotionsResponse = listPromotionsResponseSuccess;

export const getListPromotionsUrl = (project: string, params?: ListPromotionsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1beta1/projects/${project}/promotions?${stringifiedParams}`
    : `/v1beta1/projects/${project}/promotions`;
};

export const listPromotions = async (
  project: string,
  params?: ListPromotionsParams,
  options?: RequestInit
): Promise<listPromotionsResponse> => {
  return customFetch<listPromotionsResponse>(getListPromotionsUrl(project, params), {
    ...options,
    method: 'GET'
  });
};

export const getListPromotionsQueryKey = (project?: string, params?: ListPromotionsParams) => {
  return [`/v1beta1/projects/${project}/promotions`, ...(params ? [params] : [])] as const;
};

export const getListPromotionsQueryOptions = <
  TData = Awaited<ReturnType<typeof listPromotions>>,
  TError = unknown
>(
  project: string,
  params?: ListPromotionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListPromotionsQueryKey(project, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listPromotions>>> = () =>
    listPromotions(project, params, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listPromotions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListPromotionsQueryResult = NonNullable<Awaited<ReturnType<typeof listPromotions>>>;
export type ListPromotionsQueryError = unknown;

export function useListPromotions<
  TData = Awaited<ReturnType<typeof listPromotions>>,
  TError = unknown
>(
  project: string,
  params: undefined | ListPromotionsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotions>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPromotions>>,
          TError,
          Awaited<ReturnType<typeof listPromotions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListPromotions<
  TData = Awaited<ReturnType<typeof listPromotions>>,
  TError = unknown
>(
  project: string,
  params?: ListPromotionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotions>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPromotions>>,
          TError,
          Awaited<ReturnType<typeof listPromotions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListPromotions<
  TData = Awaited<ReturnType<typeof listPromotions>>,
  TError = unknown
>(
  project: string,
  params?: ListPromotionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Promotions
 */

export function useListPromotions<
  TData = Awaited<ReturnType<typeof listPromotions>>,
  TError = unknown
>(
  project: string,
  params?: ListPromotionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromotions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListPromotionsQueryOptions(project, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a Promotion resource from a project's namespace.
 * @summary Retrieve a Promotion
 */
export type getPromotionResponse200 = {
  data: GetPromotion200;
  status: 200;
};

export type getPromotionResponseSuccess = getPromotionResponse200 & {
  headers: Headers;
};
export type getPromotionResponse = getPromotionResponseSuccess;

export const getGetPromotionUrl = (project: string, promotion: string) => {
  return `/v1beta1/projects/${project}/promotions/${promotion}`;
};

export const getPromotion = async (
  project: string,
  promotion: string,
  options?: RequestInit
): Promise<getPromotionResponse> => {
  return customFetch<getPromotionResponse>(getGetPromotionUrl(project, promotion), {
    ...options,
    method: 'GET'
  });
};

export const getGetPromotionQueryKey = (project?: string, promotion?: string) => {
  return [`/v1beta1/projects/${project}/promotions/${promotion}`] as const;
};

export const getGetPromotionQueryOptions = <
  TData = Awaited<ReturnType<typeof getPromotion>>,
  TError = unknown
>(
  project: string,
  promotion: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotion>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPromotionQueryKey(project, promotion);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPromotion>>> = () =>
    getPromotion(project, promotion, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && promotion),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getPromotion>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetPromotionQueryResult = NonNullable<Awaited<ReturnType<typeof getPromotion>>>;
export type GetPromotionQueryError = unknown;

export function useGetPromotion<TData = Awaited<ReturnType<typeof getPromotion>>, TError = unknown>(
  project: string,
  promotion: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotion>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPromotion>>,
          TError,
          Awaited<ReturnType<typeof getPromotion>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPromotion<TData = Awaited<ReturnType<typeof getPromotion>>, TError = unknown>(
  project: string,
  promotion: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotion>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPromotion>>,
          TError,
          Awaited<ReturnType<typeof getPromotion>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPromotion<TData = Awaited<ReturnType<typeof getPromotion>>, TError = unknown>(
  project: string,
  promotion: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotion>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a Promotion
 */

export function useGetPromotion<TData = Awaited<ReturnType<typeof getPromotion>>, TError = unknown>(
  project: string,
  promotion: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromotion>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPromotionQueryOptions(project, promotion, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Abort a running Promotion.
 * @summary Abort a Promotion
 */
export type abortPromotionResponse200 = {
  data: void;
  status: 200;
};

export type abortPromotionResponseSuccess = abortPromotionResponse200 & {
  headers: Headers;
};
export type abortPromotionResponse = abortPromotionResponseSuccess;

export const getAbortPromotionUrl = (project: string, promotion: string) => {
  return `/v1beta1/projects/${project}/promotions/${promotion}/abort`;
};

export const abortPromotion = async (
  project: string,
  promotion: string,
  options?: RequestInit
): Promise<abortPromotionResponse> => {
  return customFetch<abortPromotionResponse>(getAbortPromotionUrl(project, promotion), {
    ...options,
    method: 'POST'
  });
};

export const getAbortPromotionMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof abortPromotion>>,
    TError,
    { project: string; promotion: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof abortPromotion>>,
  TError,
  { project: string; promotion: string },
  TContext
> => {
  const mutationKey = ['abortPromotion'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof abortPromotion>>,
    { project: string; promotion: string }
  > = (props) => {
    const { project, promotion } = props ?? {};

    return abortPromotion(project, promotion, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AbortPromotionMutationResult = NonNullable<Awaited<ReturnType<typeof abortPromotion>>>;

export type AbortPromotionMutationError = unknown;

/**
 * @summary Abort a Promotion
 */
export const useAbortPromotion = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof abortPromotion>>,
      TError,
      { project: string; promotion: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof abortPromotion>>,
  TError,
  { project: string; promotion: string },
  TContext
> => {
  const mutationOptions = getAbortPromotionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Refresh a Promotion resource in a project's namespace.
Refreshing enqueues the resource for reconciliation by its
corresponding controller.
 * @summary Refresh a Promotion
 */
export type refreshPromotionResponse200 = {
  data: void;
  status: 200;
};

export type refreshPromotionResponseSuccess = refreshPromotionResponse200 & {
  headers: Headers;
};
export type refreshPromotionResponse = refreshPromotionResponseSuccess;

export const getRefreshPromotionUrl = (project: string, promotion: string) => {
  return `/v1beta1/projects/${project}/promotions/${promotion}/refresh`;
};

export const refreshPromotion = async (
  project: string,
  promotion: string,
  options?: RequestInit
): Promise<refreshPromotionResponse> => {
  return customFetch<refreshPromotionResponse>(getRefreshPromotionUrl(project, promotion), {
    ...options,
    method: 'POST'
  });
};

export const getRefreshPromotionMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshPromotion>>,
    TError,
    { project: string; promotion: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshPromotion>>,
  TError,
  { project: string; promotion: string },
  TContext
> => {
  const mutationKey = ['refreshPromotion'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshPromotion>>,
    { project: string; promotion: string }
  > = (props) => {
    const { project, promotion } = props ?? {};

    return refreshPromotion(project, promotion, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshPromotionMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshPromotion>>
>;

export type RefreshPromotionMutationError = unknown;

/**
 * @summary Refresh a Promotion
 */
export const useRefreshPromotion = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshPromotion>>,
      TError,
      { project: string; promotion: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refreshPromotion>>,
  TError,
  { project: string; promotion: string },
  TContext
> => {
  const mutationOptions = getRefreshPromotionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List Stage resources from a project's namespace. Returns a
StageList resource.
 * @summary List Stages
 */
export type listStagesResponse200 = {
  data: ListStages200;
  status: 200;
};

export type listStagesResponseSuccess = listStagesResponse200 & {
  headers: Headers;
};
export type listStagesResponse = listStagesResponseSuccess;

export const getListStagesUrl = (project: string) => {
  return `/v1beta1/projects/${project}/stages`;
};

export const listStages = async (
  project: string,
  options?: RequestInit
): Promise<listStagesResponse> => {
  return customFetch<listStagesResponse>(getListStagesUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getListStagesQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/stages`] as const;
};

export const getListStagesQueryOptions = <
  TData = Awaited<ReturnType<typeof listStages>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listStages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListStagesQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listStages>>> = () =>
    listStages(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listStages>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListStagesQueryResult = NonNullable<Awaited<ReturnType<typeof listStages>>>;
export type ListStagesQueryError = unknown;

export function useListStages<TData = Awaited<ReturnType<typeof listStages>>, TError = unknown>(
  project: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listStages>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listStages>>,
          TError,
          Awaited<ReturnType<typeof listStages>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListStages<TData = Awaited<ReturnType<typeof listStages>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listStages>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listStages>>,
          TError,
          Awaited<ReturnType<typeof listStages>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListStages<TData = Awaited<ReturnType<typeof listStages>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listStages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Stages
 */

export function useListStages<TData = Awaited<ReturnType<typeof listStages>>, TError = unknown>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listStages>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListStagesQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a Stage resource from a project's namespace.
 * @summary Retrieve a Stage
 */
export type getStageResponse200 = {
  data: GetStage200;
  status: 200;
};

export type getStageResponseSuccess = getStageResponse200 & {
  headers: Headers;
};
export type getStageResponse = getStageResponseSuccess;

export const getGetStageUrl = (project: string, stage: string) => {
  return `/v1beta1/projects/${project}/stages/${stage}`;
};

export const getStage = async (
  project: string,
  stage: string,
  options?: RequestInit
): Promise<getStageResponse> => {
  return customFetch<getStageResponse>(getGetStageUrl(project, stage), {
    ...options,
    method: 'GET'
  });
};

export const getGetStageQueryKey = (project?: string, stage?: string) => {
  return [`/v1beta1/projects/${project}/stages/${stage}`] as const;
};

export const getGetStageQueryOptions = <
  TData = Awaited<ReturnType<typeof getStage>>,
  TError = unknown
>(
  project: string,
  stage: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStageQueryKey(project, stage);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStage>>> = () =>
    getStage(project, stage, requestOptions);

  return { queryKey, queryFn, enabled: !!(project && stage), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStageQueryResult = NonNullable<Awaited<ReturnType<typeof getStage>>>;
export type GetStageQueryError = unknown;

export function useGetStage<TData = Awaited<ReturnType<typeof getStage>>, TError = unknown>(
  project: string,
  stage: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStage>>,
          TError,
          Awaited<ReturnType<typeof getStage>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStage<TData = Awaited<ReturnType<typeof getStage>>, TError = unknown>(
  project: string,
  stage: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStage>>,
          TError,
          Awaited<ReturnType<typeof getStage>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStage<TData = Awaited<ReturnType<typeof getStage>>, TError = unknown>(
  project: string,
  stage: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a Stage
 */

export function useGetStage<TData = Awaited<ReturnType<typeof getStage>>, TError = unknown>(
  project: string,
  stage: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStage>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStageQueryOptions(project, stage, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a Stage resource from a project's namespace.
 * @summary Delete a Stage
 */
export type deleteStageResponse204 = {
  data: void;
  status: 204;
};

export type deleteStageResponseSuccess = deleteStageResponse204 & {
  headers: Headers;
};
export type deleteStageResponse = deleteStageResponseSuccess;

export const getDeleteStageUrl = (project: string, stage: string) => {
  return `/v1beta1/projects/${project}/stages/${stage}`;
};

export const deleteStage = async (
  project: string,
  stage: string,
  options?: RequestInit
): Promise<deleteStageResponse> => {
  return customFetch<deleteStageResponse>(getDeleteStageUrl(project, stage), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteStageMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteStage>>,
    TError,
    { project: string; stage: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteStage>>,
  TError,
  { project: string; stage: string },
  TContext
> => {
  const mutationKey = ['deleteStage'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteStage>>,
    { project: string; stage: string }
  > = (props) => {
    const { project, stage } = props ?? {};

    return deleteStage(project, stage, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteStageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStage>>>;

export type DeleteStageMutationError = unknown;

/**
 * @summary Delete a Stage
 */
export const useDeleteStage = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteStage>>,
      TError,
      { project: string; stage: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteStage>>,
  TError,
  { project: string; stage: string },
  TContext
> => {
  const mutationOptions = getDeleteStageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a Promotion resource to transition a specified Stage into
the state represented by the specified Freight.
 * @summary Promote to Stage
 */
export type promoteToStageResponse201 = {
  data: PromoteToStage201;
  status: 201;
};

export type promoteToStageResponseSuccess = promoteToStageResponse201 & {
  headers: Headers;
};
export type promoteToStageResponse = promoteToStageResponseSuccess;

export const getPromoteToStageUrl = (project: string, stage: string) => {
  return `/v1beta1/projects/${project}/stages/${stage}/promotions`;
};

export const promoteToStage = async (
  project: string,
  stage: string,
  promoteToStageRequest: PromoteToStageRequest,
  options?: RequestInit
): Promise<promoteToStageResponse> => {
  return customFetch<promoteToStageResponse>(getPromoteToStageUrl(project, stage), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(promoteToStageRequest)
  });
};

export const getPromoteToStageMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof promoteToStage>>,
    TError,
    { project: string; stage: string; data: PromoteToStageRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof promoteToStage>>,
  TError,
  { project: string; stage: string; data: PromoteToStageRequest },
  TContext
> => {
  const mutationKey = ['promoteToStage'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof promoteToStage>>,
    { project: string; stage: string; data: PromoteToStageRequest }
  > = (props) => {
    const { project, stage, data } = props ?? {};

    return promoteToStage(project, stage, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PromoteToStageMutationResult = NonNullable<Awaited<ReturnType<typeof promoteToStage>>>;
export type PromoteToStageMutationBody = PromoteToStageRequest;
export type PromoteToStageMutationError = unknown;

/**
 * @summary Promote to Stage
 */
export const usePromoteToStage = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof promoteToStage>>,
      TError,
      { project: string; stage: string; data: PromoteToStageRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof promoteToStage>>,
  TError,
  { project: string; stage: string; data: PromoteToStageRequest },
  TContext
> => {
  const mutationOptions = getPromoteToStageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a Promotion resource for each of a Stage's immediately
downstream Stages.
 * @summary Promote downstream
 */
export type promoteDownstreamResponse201 = {
  data: PromoteDownstream201;
  status: 201;
};

export type promoteDownstreamResponseSuccess = promoteDownstreamResponse201 & {
  headers: Headers;
};
export type promoteDownstreamResponse = promoteDownstreamResponseSuccess;

export const getPromoteDownstreamUrl = (project: string, stage: string) => {
  return `/v1beta1/projects/${project}/stages/${stage}/promotions/downstream`;
};

export const promoteDownstream = async (
  project: string,
  stage: string,
  promoteDownstreamRequest: PromoteDownstreamRequest,
  options?: RequestInit
): Promise<promoteDownstreamResponse> => {
  return customFetch<promoteDownstreamResponse>(getPromoteDownstreamUrl(project, stage), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(promoteDownstreamRequest)
  });
};

export const getPromoteDownstreamMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof promoteDownstream>>,
    TError,
    { project: string; stage: string; data: PromoteDownstreamRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof promoteDownstream>>,
  TError,
  { project: string; stage: string; data: PromoteDownstreamRequest },
  TContext
> => {
  const mutationKey = ['promoteDownstream'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof promoteDownstream>>,
    { project: string; stage: string; data: PromoteDownstreamRequest }
  > = (props) => {
    const { project, stage, data } = props ?? {};

    return promoteDownstream(project, stage, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PromoteDownstreamMutationResult = NonNullable<
  Awaited<ReturnType<typeof promoteDownstream>>
>;
export type PromoteDownstreamMutationBody = PromoteDownstreamRequest;
export type PromoteDownstreamMutationError = unknown;

/**
 * @summary Promote downstream
 */
export const usePromoteDownstream = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof promoteDownstream>>,
      TError,
      { project: string; stage: string; data: PromoteDownstreamRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof promoteDownstream>>,
  TError,
  { project: string; stage: string; data: PromoteDownstreamRequest },
  TContext
> => {
  const mutationOptions = getPromoteDownstreamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Refresh a Stage resource in a project's namespace. Refreshing
enqueues the resource for reconciliation by its corresponding
controller.
 * @summary Refresh a Stage
 */
export type refreshStageResponse200 = {
  data: void;
  status: 200;
};

export type refreshStageResponseSuccess = refreshStageResponse200 & {
  headers: Headers;
};
export type refreshStageResponse = refreshStageResponseSuccess;

export const getRefreshStageUrl = (project: string, stage: string) => {
  return `/v1beta1/projects/${project}/stages/${stage}/refresh`;
};

export const refreshStage = async (
  project: string,
  stage: string,
  options?: RequestInit
): Promise<refreshStageResponse> => {
  return customFetch<refreshStageResponse>(getRefreshStageUrl(project, stage), {
    ...options,
    method: 'POST'
  });
};

export const getRefreshStageMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshStage>>,
    TError,
    { project: string; stage: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshStage>>,
  TError,
  { project: string; stage: string },
  TContext
> => {
  const mutationKey = ['refreshStage'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshStage>>,
    { project: string; stage: string }
  > = (props) => {
    const { project, stage } = props ?? {};

    return refreshStage(project, stage, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshStageMutationResult = NonNullable<Awaited<ReturnType<typeof refreshStage>>>;

export type RefreshStageMutationError = unknown;

/**
 * @summary Refresh a Stage
 */
export const useRefreshStage = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshStage>>,
      TError,
      { project: string; stage: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refreshStage>>,
  TError,
  { project: string; stage: string },
  TContext
> => {
  const mutationOptions = getRefreshStageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List Warehouse resources from a project's namespace. Returns a
WarehouseList resource.
 * @summary List Warehouses
 */
export type listWarehousesResponse200 = {
  data: ListWarehouses200;
  status: 200;
};

export type listWarehousesResponseSuccess = listWarehousesResponse200 & {
  headers: Headers;
};
export type listWarehousesResponse = listWarehousesResponseSuccess;

export const getListWarehousesUrl = (project: string) => {
  return `/v1beta1/projects/${project}/warehouses`;
};

export const listWarehouses = async (
  project: string,
  options?: RequestInit
): Promise<listWarehousesResponse> => {
  return customFetch<listWarehousesResponse>(getListWarehousesUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getListWarehousesQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/warehouses`] as const;
};

export const getListWarehousesQueryOptions = <
  TData = Awaited<ReturnType<typeof listWarehouses>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listWarehouses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListWarehousesQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listWarehouses>>> = () =>
    listWarehouses(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listWarehouses>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListWarehousesQueryResult = NonNullable<Awaited<ReturnType<typeof listWarehouses>>>;
export type ListWarehousesQueryError = unknown;

export function useListWarehouses<
  TData = Awaited<ReturnType<typeof listWarehouses>>,
  TError = unknown
>(
  project: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listWarehouses>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWarehouses>>,
          TError,
          Awaited<ReturnType<typeof listWarehouses>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListWarehouses<
  TData = Awaited<ReturnType<typeof listWarehouses>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listWarehouses>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWarehouses>>,
          TError,
          Awaited<ReturnType<typeof listWarehouses>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListWarehouses<
  TData = Awaited<ReturnType<typeof listWarehouses>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listWarehouses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Warehouses
 */

export function useListWarehouses<
  TData = Awaited<ReturnType<typeof listWarehouses>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listWarehouses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListWarehousesQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a Warehouse resource from a project's namespace.
 * @summary Retrieve a Warehouse
 */
export type getWarehouseResponse200 = {
  data: GetWarehouse200;
  status: 200;
};

export type getWarehouseResponseSuccess = getWarehouseResponse200 & {
  headers: Headers;
};
export type getWarehouseResponse = getWarehouseResponseSuccess;

export const getGetWarehouseUrl = (project: string, warehouse: string) => {
  return `/v1beta1/projects/${project}/warehouses/${warehouse}`;
};

export const getWarehouse = async (
  project: string,
  warehouse: string,
  options?: RequestInit
): Promise<getWarehouseResponse> => {
  return customFetch<getWarehouseResponse>(getGetWarehouseUrl(project, warehouse), {
    ...options,
    method: 'GET'
  });
};

export const getGetWarehouseQueryKey = (project?: string, warehouse?: string) => {
  return [`/v1beta1/projects/${project}/warehouses/${warehouse}`] as const;
};

export const getGetWarehouseQueryOptions = <
  TData = Awaited<ReturnType<typeof getWarehouse>>,
  TError = unknown
>(
  project: string,
  warehouse: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWarehouse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWarehouseQueryKey(project, warehouse);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWarehouse>>> = () =>
    getWarehouse(project, warehouse, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && warehouse),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getWarehouse>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetWarehouseQueryResult = NonNullable<Awaited<ReturnType<typeof getWarehouse>>>;
export type GetWarehouseQueryError = unknown;

export function useGetWarehouse<TData = Awaited<ReturnType<typeof getWarehouse>>, TError = unknown>(
  project: string,
  warehouse: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWarehouse>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWarehouse>>,
          TError,
          Awaited<ReturnType<typeof getWarehouse>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWarehouse<TData = Awaited<ReturnType<typeof getWarehouse>>, TError = unknown>(
  project: string,
  warehouse: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWarehouse>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWarehouse>>,
          TError,
          Awaited<ReturnType<typeof getWarehouse>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWarehouse<TData = Awaited<ReturnType<typeof getWarehouse>>, TError = unknown>(
  project: string,
  warehouse: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWarehouse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a Warehouse
 */

export function useGetWarehouse<TData = Awaited<ReturnType<typeof getWarehouse>>, TError = unknown>(
  project: string,
  warehouse: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWarehouse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWarehouseQueryOptions(project, warehouse, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a Warehouse resource from a project's namespace.
 * @summary Delete a Warehouse
 */
export type deleteWarehouseResponse204 = {
  data: void;
  status: 204;
};

export type deleteWarehouseResponseSuccess = deleteWarehouseResponse204 & {
  headers: Headers;
};
export type deleteWarehouseResponse = deleteWarehouseResponseSuccess;

export const getDeleteWarehouseUrl = (project: string, warehouse: string) => {
  return `/v1beta1/projects/${project}/warehouses/${warehouse}`;
};

export const deleteWarehouse = async (
  project: string,
  warehouse: string,
  options?: RequestInit
): Promise<deleteWarehouseResponse> => {
  return customFetch<deleteWarehouseResponse>(getDeleteWarehouseUrl(project, warehouse), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteWarehouseMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteWarehouse>>,
    TError,
    { project: string; warehouse: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteWarehouse>>,
  TError,
  { project: string; warehouse: string },
  TContext
> => {
  const mutationKey = ['deleteWarehouse'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteWarehouse>>,
    { project: string; warehouse: string }
  > = (props) => {
    const { project, warehouse } = props ?? {};

    return deleteWarehouse(project, warehouse, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteWarehouseMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteWarehouse>>
>;

export type DeleteWarehouseMutationError = unknown;

/**
 * @summary Delete a Warehouse
 */
export const useDeleteWarehouse = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteWarehouse>>,
      TError,
      { project: string; warehouse: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteWarehouse>>,
  TError,
  { project: string; warehouse: string },
  TContext
> => {
  const mutationOptions = getDeleteWarehouseMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Refresh a Warehouse resource in a project's namespace.
Refreshing enqueues the resource for reconciliation by its
corresponding controller.
 * @summary Refresh a Warehouse
 */
export type refreshWarehouseResponse200 = {
  data: void;
  status: 200;
};

export type refreshWarehouseResponseSuccess = refreshWarehouseResponse200 & {
  headers: Headers;
};
export type refreshWarehouseResponse = refreshWarehouseResponseSuccess;

export const getRefreshWarehouseUrl = (project: string, warehouse: string) => {
  return `/v1beta1/projects/${project}/warehouses/${warehouse}/refresh`;
};

export const refreshWarehouse = async (
  project: string,
  warehouse: string,
  options?: RequestInit
): Promise<refreshWarehouseResponse> => {
  return customFetch<refreshWarehouseResponse>(getRefreshWarehouseUrl(project, warehouse), {
    ...options,
    method: 'POST'
  });
};

export const getRefreshWarehouseMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshWarehouse>>,
    TError,
    { project: string; warehouse: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshWarehouse>>,
  TError,
  { project: string; warehouse: string },
  TContext
> => {
  const mutationKey = ['refreshWarehouse'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshWarehouse>>,
    { project: string; warehouse: string }
  > = (props) => {
    const { project, warehouse } = props ?? {};

    return refreshWarehouse(project, warehouse, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshWarehouseMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshWarehouse>>
>;

export type RefreshWarehouseMutationError = unknown;

/**
 * @summary Refresh a Warehouse
 */
export const useRefreshWarehouse = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshWarehouse>>,
      TError,
      { project: string; warehouse: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refreshWarehouse>>,
  TError,
  { project: string; warehouse: string },
  TContext
> => {
  const mutationOptions = getRefreshWarehouseMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List ClusterPromotionTask resources. Returns a
ClusterPromotionTaskList resource.
 * @summary List ClusterPromotionTasks
 */
export type listClusterPromotionTasksResponse200 = {
  data: ListClusterPromotionTasks200;
  status: 200;
};

export type listClusterPromotionTasksResponseSuccess = listClusterPromotionTasksResponse200 & {
  headers: Headers;
};
export type listClusterPromotionTasksResponse = listClusterPromotionTasksResponseSuccess;

export const getListClusterPromotionTasksUrl = () => {
  return `/v1beta1/shared/cluster-promotion-tasks`;
};

export const listClusterPromotionTasks = async (
  options?: RequestInit
): Promise<listClusterPromotionTasksResponse> => {
  return customFetch<listClusterPromotionTasksResponse>(getListClusterPromotionTasksUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListClusterPromotionTasksQueryKey = () => {
  return [`/v1beta1/shared/cluster-promotion-tasks`] as const;
};

export const getListClusterPromotionTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof listClusterPromotionTasks>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listClusterPromotionTasks>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListClusterPromotionTasksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listClusterPromotionTasks>>> = () =>
    listClusterPromotionTasks(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listClusterPromotionTasks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListClusterPromotionTasksQueryResult = NonNullable<
  Awaited<ReturnType<typeof listClusterPromotionTasks>>
>;
export type ListClusterPromotionTasksQueryError = unknown;

export function useListClusterPromotionTasks<
  TData = Awaited<ReturnType<typeof listClusterPromotionTasks>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listClusterPromotionTasks>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listClusterPromotionTasks>>,
          TError,
          Awaited<ReturnType<typeof listClusterPromotionTasks>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListClusterPromotionTasks<
  TData = Awaited<ReturnType<typeof listClusterPromotionTasks>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listClusterPromotionTasks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listClusterPromotionTasks>>,
          TError,
          Awaited<ReturnType<typeof listClusterPromotionTasks>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListClusterPromotionTasks<
  TData = Awaited<ReturnType<typeof listClusterPromotionTasks>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listClusterPromotionTasks>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List ClusterPromotionTasks
 */

export function useListClusterPromotionTasks<
  TData = Awaited<ReturnType<typeof listClusterPromotionTasks>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listClusterPromotionTasks>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListClusterPromotionTasksQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a ClusterPromotionTask by name.
 * @summary Retrieve a ClusterPromotionTask
 */
export type getClusterPromotionTaskResponse200 = {
  data: GetClusterPromotionTask200;
  status: 200;
};

export type getClusterPromotionTaskResponseSuccess = getClusterPromotionTaskResponse200 & {
  headers: Headers;
};
export type getClusterPromotionTaskResponse = getClusterPromotionTaskResponseSuccess;

export const getGetClusterPromotionTaskUrl = (clusterPromotionTask: string) => {
  return `/v1beta1/shared/cluster-promotion-tasks/${clusterPromotionTask}`;
};

export const getClusterPromotionTask = async (
  clusterPromotionTask: string,
  options?: RequestInit
): Promise<getClusterPromotionTaskResponse> => {
  return customFetch<getClusterPromotionTaskResponse>(
    getGetClusterPromotionTaskUrl(clusterPromotionTask),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetClusterPromotionTaskQueryKey = (clusterPromotionTask?: string) => {
  return [`/v1beta1/shared/cluster-promotion-tasks/${clusterPromotionTask}`] as const;
};

export const getGetClusterPromotionTaskQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterPromotionTask>>,
  TError = unknown
>(
  clusterPromotionTask: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterPromotionTask>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClusterPromotionTaskQueryKey(clusterPromotionTask);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterPromotionTask>>> = () =>
    getClusterPromotionTask(clusterPromotionTask, requestOptions);

  return { queryKey, queryFn, enabled: !!clusterPromotionTask, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getClusterPromotionTask>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetClusterPromotionTaskQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClusterPromotionTask>>
>;
export type GetClusterPromotionTaskQueryError = unknown;

export function useGetClusterPromotionTask<
  TData = Awaited<ReturnType<typeof getClusterPromotionTask>>,
  TError = unknown
>(
  clusterPromotionTask: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterPromotionTask>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClusterPromotionTask>>,
          TError,
          Awaited<ReturnType<typeof getClusterPromotionTask>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetClusterPromotionTask<
  TData = Awaited<ReturnType<typeof getClusterPromotionTask>>,
  TError = unknown
>(
  clusterPromotionTask: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterPromotionTask>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClusterPromotionTask>>,
          TError,
          Awaited<ReturnType<typeof getClusterPromotionTask>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetClusterPromotionTask<
  TData = Awaited<ReturnType<typeof getClusterPromotionTask>>,
  TError = unknown
>(
  clusterPromotionTask: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterPromotionTask>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a ClusterPromotionTask
 */

export function useGetClusterPromotionTask<
  TData = Awaited<ReturnType<typeof getClusterPromotionTask>>,
  TError = unknown
>(
  clusterPromotionTask: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClusterPromotionTask>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetClusterPromotionTaskQueryOptions(clusterPromotionTask, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * List shared ConfigMap resources referenceable by all projects.
Returns a Kubernetes ConfigMapList resource.
 * @summary List shared ConfigMaps
 */
export type listSharedConfigMapsResponse200 = {
  data: ListSharedConfigMaps200;
  status: 200;
};

export type listSharedConfigMapsResponseSuccess = listSharedConfigMapsResponse200 & {
  headers: Headers;
};
export type listSharedConfigMapsResponse = listSharedConfigMapsResponseSuccess;

export const getListSharedConfigMapsUrl = () => {
  return `/v1beta1/shared/configmaps`;
};

export const listSharedConfigMaps = async (
  options?: RequestInit
): Promise<listSharedConfigMapsResponse> => {
  return customFetch<listSharedConfigMapsResponse>(getListSharedConfigMapsUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListSharedConfigMapsQueryKey = () => {
  return [`/v1beta1/shared/configmaps`] as const;
};

export const getListSharedConfigMapsQueryOptions = <
  TData = Awaited<ReturnType<typeof listSharedConfigMaps>>,
  TError = unknown
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listSharedConfigMaps>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListSharedConfigMapsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSharedConfigMaps>>> = () =>
    listSharedConfigMaps(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSharedConfigMaps>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSharedConfigMapsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSharedConfigMaps>>
>;
export type ListSharedConfigMapsQueryError = unknown;

export function useListSharedConfigMaps<
  TData = Awaited<ReturnType<typeof listSharedConfigMaps>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedConfigMaps>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSharedConfigMaps>>,
          TError,
          Awaited<ReturnType<typeof listSharedConfigMaps>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSharedConfigMaps<
  TData = Awaited<ReturnType<typeof listSharedConfigMaps>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedConfigMaps>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSharedConfigMaps>>,
          TError,
          Awaited<ReturnType<typeof listSharedConfigMaps>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSharedConfigMaps<
  TData = Awaited<ReturnType<typeof listSharedConfigMaps>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedConfigMaps>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List shared ConfigMaps
 */

export function useListSharedConfigMaps<
  TData = Awaited<ReturnType<typeof listSharedConfigMaps>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedConfigMaps>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListSharedConfigMapsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a shared ConfigMap referenceable by all projects. Returns
the created Kubernetes ConfigMap resource.
 * @summary Create a shared ConfigMap
 */
export type createSharedConfigMapResponse201 = {
  data: CreateSharedConfigMap201;
  status: 201;
};

export type createSharedConfigMapResponseSuccess = createSharedConfigMapResponse201 & {
  headers: Headers;
};
export type createSharedConfigMapResponse = createSharedConfigMapResponseSuccess;

export const getCreateSharedConfigMapUrl = () => {
  return `/v1beta1/shared/configmaps`;
};

export const createSharedConfigMap = async (
  createConfigMapRequestBody: CreateConfigMapRequestBody,
  options?: RequestInit
): Promise<createSharedConfigMapResponse> => {
  return customFetch<createSharedConfigMapResponse>(getCreateSharedConfigMapUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createConfigMapRequestBody)
  });
};

export const getCreateSharedConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSharedConfigMap>>,
    TError,
    { data: CreateConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSharedConfigMap>>,
  TError,
  { data: CreateConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['createSharedConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSharedConfigMap>>,
    { data: CreateConfigMapRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return createSharedConfigMap(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSharedConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSharedConfigMap>>
>;
export type CreateSharedConfigMapMutationBody = CreateConfigMapRequestBody;
export type CreateSharedConfigMapMutationError = unknown;

/**
 * @summary Create a shared ConfigMap
 */
export const useCreateSharedConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSharedConfigMap>>,
      TError,
      { data: CreateConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createSharedConfigMap>>,
  TError,
  { data: CreateConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getCreateSharedConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve a shared ConfigMap by name.
 * @summary Retrieve a shared ConfigMap
 */
export type getSharedConfigMapResponse200 = {
  data: GetSharedConfigMap200;
  status: 200;
};

export type getSharedConfigMapResponseSuccess = getSharedConfigMapResponse200 & {
  headers: Headers;
};
export type getSharedConfigMapResponse = getSharedConfigMapResponseSuccess;

export const getGetSharedConfigMapUrl = (configmap: string) => {
  return `/v1beta1/shared/configmaps/${configmap}`;
};

export const getSharedConfigMap = async (
  configmap: string,
  options?: RequestInit
): Promise<getSharedConfigMapResponse> => {
  return customFetch<getSharedConfigMapResponse>(getGetSharedConfigMapUrl(configmap), {
    ...options,
    method: 'GET'
  });
};

export const getGetSharedConfigMapQueryKey = (configmap?: string) => {
  return [`/v1beta1/shared/configmaps/${configmap}`] as const;
};

export const getGetSharedConfigMapQueryOptions = <
  TData = Awaited<ReturnType<typeof getSharedConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharedConfigMap>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSharedConfigMapQueryKey(configmap);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSharedConfigMap>>> = () =>
    getSharedConfigMap(configmap, requestOptions);

  return { queryKey, queryFn, enabled: !!configmap, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSharedConfigMap>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSharedConfigMapQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSharedConfigMap>>
>;
export type GetSharedConfigMapQueryError = unknown;

export function useGetSharedConfigMap<
  TData = Awaited<ReturnType<typeof getSharedConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharedConfigMap>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSharedConfigMap>>,
          TError,
          Awaited<ReturnType<typeof getSharedConfigMap>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSharedConfigMap<
  TData = Awaited<ReturnType<typeof getSharedConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedConfigMap>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSharedConfigMap>>,
          TError,
          Awaited<ReturnType<typeof getSharedConfigMap>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSharedConfigMap<
  TData = Awaited<ReturnType<typeof getSharedConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharedConfigMap>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a shared ConfigMap
 */

export function useGetSharedConfigMap<
  TData = Awaited<ReturnType<typeof getSharedConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSharedConfigMap>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSharedConfigMapQueryOptions(configmap, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replace a shared ConfigMap. All existing data is replaced.
Returns the updated Kubernetes ConfigMap resource.
 * @summary Replace a shared ConfigMap
 */
export type updateSharedConfigMapResponse200 = {
  data: UpdateSharedConfigMap200;
  status: 200;
};

export type updateSharedConfigMapResponseSuccess = updateSharedConfigMapResponse200 & {
  headers: Headers;
};
export type updateSharedConfigMapResponse = updateSharedConfigMapResponseSuccess;

export const getUpdateSharedConfigMapUrl = (configmap: string) => {
  return `/v1beta1/shared/configmaps/${configmap}`;
};

export const updateSharedConfigMap = async (
  configmap: string,
  updateConfigMapRequestBody: UpdateConfigMapRequestBody,
  options?: RequestInit
): Promise<updateSharedConfigMapResponse> => {
  return customFetch<updateSharedConfigMapResponse>(getUpdateSharedConfigMapUrl(configmap), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateConfigMapRequestBody)
  });
};

export const getUpdateSharedConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSharedConfigMap>>,
    TError,
    { configmap: string; data: UpdateConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSharedConfigMap>>,
  TError,
  { configmap: string; data: UpdateConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['updateSharedConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSharedConfigMap>>,
    { configmap: string; data: UpdateConfigMapRequestBody }
  > = (props) => {
    const { configmap, data } = props ?? {};

    return updateSharedConfigMap(configmap, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSharedConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSharedConfigMap>>
>;
export type UpdateSharedConfigMapMutationBody = UpdateConfigMapRequestBody;
export type UpdateSharedConfigMapMutationError = unknown;

/**
 * @summary Replace a shared ConfigMap
 */
export const useUpdateSharedConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSharedConfigMap>>,
      TError,
      { configmap: string; data: UpdateConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSharedConfigMap>>,
  TError,
  { configmap: string; data: UpdateConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateSharedConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a shared ConfigMap.
 * @summary Delete a shared ConfigMap
 */
export type deleteSharedConfigMapResponse204 = {
  data: void;
  status: 204;
};

export type deleteSharedConfigMapResponseSuccess = deleteSharedConfigMapResponse204 & {
  headers: Headers;
};
export type deleteSharedConfigMapResponse = deleteSharedConfigMapResponseSuccess;

export const getDeleteSharedConfigMapUrl = (configmap: string) => {
  return `/v1beta1/shared/configmaps/${configmap}`;
};

export const deleteSharedConfigMap = async (
  configmap: string,
  options?: RequestInit
): Promise<deleteSharedConfigMapResponse> => {
  return customFetch<deleteSharedConfigMapResponse>(getDeleteSharedConfigMapUrl(configmap), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteSharedConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSharedConfigMap>>,
    TError,
    { configmap: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSharedConfigMap>>,
  TError,
  { configmap: string },
  TContext
> => {
  const mutationKey = ['deleteSharedConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSharedConfigMap>>,
    { configmap: string }
  > = (props) => {
    const { configmap } = props ?? {};

    return deleteSharedConfigMap(configmap, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSharedConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSharedConfigMap>>
>;

export type DeleteSharedConfigMapMutationError = unknown;

/**
 * @summary Delete a shared ConfigMap
 */
export const useDeleteSharedConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSharedConfigMap>>,
      TError,
      { configmap: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSharedConfigMap>>,
  TError,
  { configmap: string },
  TContext
> => {
  const mutationOptions = getDeleteSharedConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch a shared ConfigMap. Merges provided data
with existing data. Use removeKeys to delete specific keys.
Returns the updated Kubernetes ConfigMap resource.
 * @summary Patch a shared ConfigMap
 */
export type patchSharedConfigMapResponse200 = {
  data: PatchSharedConfigMap200;
  status: 200;
};

export type patchSharedConfigMapResponseSuccess = patchSharedConfigMapResponse200 & {
  headers: Headers;
};
export type patchSharedConfigMapResponse = patchSharedConfigMapResponseSuccess;

export const getPatchSharedConfigMapUrl = (configmap: string) => {
  return `/v1beta1/shared/configmaps/${configmap}`;
};

export const patchSharedConfigMap = async (
  configmap: string,
  patchConfigMapRequestBody: PatchConfigMapRequestBody,
  options?: RequestInit
): Promise<patchSharedConfigMapResponse> => {
  return customFetch<patchSharedConfigMapResponse>(getPatchSharedConfigMapUrl(configmap), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchConfigMapRequestBody)
  });
};

export const getPatchSharedConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchSharedConfigMap>>,
    TError,
    { configmap: string; data: PatchConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchSharedConfigMap>>,
  TError,
  { configmap: string; data: PatchConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['patchSharedConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchSharedConfigMap>>,
    { configmap: string; data: PatchConfigMapRequestBody }
  > = (props) => {
    const { configmap, data } = props ?? {};

    return patchSharedConfigMap(configmap, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchSharedConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchSharedConfigMap>>
>;
export type PatchSharedConfigMapMutationBody = PatchConfigMapRequestBody;
export type PatchSharedConfigMapMutationError = unknown;

/**
 * @summary Patch a shared ConfigMap
 */
export const usePatchSharedConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchSharedConfigMap>>,
      TError,
      { configmap: string; data: PatchConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchSharedConfigMap>>,
  TError,
  { configmap: string; data: PatchConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getPatchSharedConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List system-level ConfigMap resources. Returns a Kubernetes
ConfigMapList resource.
 * @summary List system-level ConfigMaps
 */
export type listSystemConfigMapsResponse200 = {
  data: ListSystemConfigMaps200;
  status: 200;
};

export type listSystemConfigMapsResponseSuccess = listSystemConfigMapsResponse200 & {
  headers: Headers;
};
export type listSystemConfigMapsResponse = listSystemConfigMapsResponseSuccess;

export const getListSystemConfigMapsUrl = () => {
  return `/v1beta1/system/configmaps`;
};

export const listSystemConfigMaps = async (
  options?: RequestInit
): Promise<listSystemConfigMapsResponse> => {
  return customFetch<listSystemConfigMapsResponse>(getListSystemConfigMapsUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListSystemConfigMapsQueryKey = () => {
  return [`/v1beta1/system/configmaps`] as const;
};

export const getListSystemConfigMapsQueryOptions = <
  TData = Awaited<ReturnType<typeof listSystemConfigMaps>>,
  TError = unknown
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listSystemConfigMaps>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListSystemConfigMapsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSystemConfigMaps>>> = () =>
    listSystemConfigMaps(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSystemConfigMaps>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSystemConfigMapsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSystemConfigMaps>>
>;
export type ListSystemConfigMapsQueryError = unknown;

export function useListSystemConfigMaps<
  TData = Awaited<ReturnType<typeof listSystemConfigMaps>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemConfigMaps>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSystemConfigMaps>>,
          TError,
          Awaited<ReturnType<typeof listSystemConfigMaps>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSystemConfigMaps<
  TData = Awaited<ReturnType<typeof listSystemConfigMaps>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemConfigMaps>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSystemConfigMaps>>,
          TError,
          Awaited<ReturnType<typeof listSystemConfigMaps>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSystemConfigMaps<
  TData = Awaited<ReturnType<typeof listSystemConfigMaps>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemConfigMaps>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List system-level ConfigMaps
 */

export function useListSystemConfigMaps<
  TData = Awaited<ReturnType<typeof listSystemConfigMaps>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemConfigMaps>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListSystemConfigMapsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a system-level ConfigMap. Returns the created Kubernetes
ConfigMap resource.
 * @summary Create a system-level ConfigMap
 */
export type createSystemConfigMapResponse201 = {
  data: CreateSystemConfigMap201;
  status: 201;
};

export type createSystemConfigMapResponseSuccess = createSystemConfigMapResponse201 & {
  headers: Headers;
};
export type createSystemConfigMapResponse = createSystemConfigMapResponseSuccess;

export const getCreateSystemConfigMapUrl = () => {
  return `/v1beta1/system/configmaps`;
};

export const createSystemConfigMap = async (
  createConfigMapRequestBody: CreateConfigMapRequestBody,
  options?: RequestInit
): Promise<createSystemConfigMapResponse> => {
  return customFetch<createSystemConfigMapResponse>(getCreateSystemConfigMapUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createConfigMapRequestBody)
  });
};

export const getCreateSystemConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSystemConfigMap>>,
    TError,
    { data: CreateConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSystemConfigMap>>,
  TError,
  { data: CreateConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['createSystemConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSystemConfigMap>>,
    { data: CreateConfigMapRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return createSystemConfigMap(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSystemConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSystemConfigMap>>
>;
export type CreateSystemConfigMapMutationBody = CreateConfigMapRequestBody;
export type CreateSystemConfigMapMutationError = unknown;

/**
 * @summary Create a system-level ConfigMap
 */
export const useCreateSystemConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSystemConfigMap>>,
      TError,
      { data: CreateConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createSystemConfigMap>>,
  TError,
  { data: CreateConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getCreateSystemConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve a system-level ConfigMap by name.
 * @summary Retrieve a system-level ConfigMap
 */
export type getSystemConfigMapResponse200 = {
  data: GetSystemConfigMap200;
  status: 200;
};

export type getSystemConfigMapResponseSuccess = getSystemConfigMapResponse200 & {
  headers: Headers;
};
export type getSystemConfigMapResponse = getSystemConfigMapResponseSuccess;

export const getGetSystemConfigMapUrl = (configmap: string) => {
  return `/v1beta1/system/configmaps/${configmap}`;
};

export const getSystemConfigMap = async (
  configmap: string,
  options?: RequestInit
): Promise<getSystemConfigMapResponse> => {
  return customFetch<getSystemConfigMapResponse>(getGetSystemConfigMapUrl(configmap), {
    ...options,
    method: 'GET'
  });
};

export const getGetSystemConfigMapQueryKey = (configmap?: string) => {
  return [`/v1beta1/system/configmaps/${configmap}`] as const;
};

export const getGetSystemConfigMapQueryOptions = <
  TData = Awaited<ReturnType<typeof getSystemConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemConfigMap>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSystemConfigMapQueryKey(configmap);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemConfigMap>>> = () =>
    getSystemConfigMap(configmap, requestOptions);

  return { queryKey, queryFn, enabled: !!configmap, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSystemConfigMap>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSystemConfigMapQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSystemConfigMap>>
>;
export type GetSystemConfigMapQueryError = unknown;

export function useGetSystemConfigMap<
  TData = Awaited<ReturnType<typeof getSystemConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemConfigMap>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemConfigMap>>,
          TError,
          Awaited<ReturnType<typeof getSystemConfigMap>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSystemConfigMap<
  TData = Awaited<ReturnType<typeof getSystemConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSystemConfigMap>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemConfigMap>>,
          TError,
          Awaited<ReturnType<typeof getSystemConfigMap>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSystemConfigMap<
  TData = Awaited<ReturnType<typeof getSystemConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemConfigMap>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a system-level ConfigMap
 */

export function useGetSystemConfigMap<
  TData = Awaited<ReturnType<typeof getSystemConfigMap>>,
  TError = unknown
>(
  configmap: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemConfigMap>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSystemConfigMapQueryOptions(configmap, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replace a system-level ConfigMap. All existing data is replaced.
Returns the updated Kubernetes ConfigMap resource.
 * @summary Replace a system-level ConfigMap
 */
export type updateSystemConfigMapResponse200 = {
  data: UpdateSystemConfigMap200;
  status: 200;
};

export type updateSystemConfigMapResponseSuccess = updateSystemConfigMapResponse200 & {
  headers: Headers;
};
export type updateSystemConfigMapResponse = updateSystemConfigMapResponseSuccess;

export const getUpdateSystemConfigMapUrl = (configmap: string) => {
  return `/v1beta1/system/configmaps/${configmap}`;
};

export const updateSystemConfigMap = async (
  configmap: string,
  updateConfigMapRequestBody: UpdateConfigMapRequestBody,
  options?: RequestInit
): Promise<updateSystemConfigMapResponse> => {
  return customFetch<updateSystemConfigMapResponse>(getUpdateSystemConfigMapUrl(configmap), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateConfigMapRequestBody)
  });
};

export const getUpdateSystemConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSystemConfigMap>>,
    TError,
    { configmap: string; data: UpdateConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSystemConfigMap>>,
  TError,
  { configmap: string; data: UpdateConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['updateSystemConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSystemConfigMap>>,
    { configmap: string; data: UpdateConfigMapRequestBody }
  > = (props) => {
    const { configmap, data } = props ?? {};

    return updateSystemConfigMap(configmap, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSystemConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSystemConfigMap>>
>;
export type UpdateSystemConfigMapMutationBody = UpdateConfigMapRequestBody;
export type UpdateSystemConfigMapMutationError = unknown;

/**
 * @summary Replace a system-level ConfigMap
 */
export const useUpdateSystemConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSystemConfigMap>>,
      TError,
      { configmap: string; data: UpdateConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSystemConfigMap>>,
  TError,
  { configmap: string; data: UpdateConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateSystemConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a system-level ConfigMap.
 * @summary Delete a system-level ConfigMap
 */
export type deleteSystemConfigMapResponse204 = {
  data: void;
  status: 204;
};

export type deleteSystemConfigMapResponseSuccess = deleteSystemConfigMapResponse204 & {
  headers: Headers;
};
export type deleteSystemConfigMapResponse = deleteSystemConfigMapResponseSuccess;

export const getDeleteSystemConfigMapUrl = (configmap: string) => {
  return `/v1beta1/system/configmaps/${configmap}`;
};

export const deleteSystemConfigMap = async (
  configmap: string,
  options?: RequestInit
): Promise<deleteSystemConfigMapResponse> => {
  return customFetch<deleteSystemConfigMapResponse>(getDeleteSystemConfigMapUrl(configmap), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteSystemConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSystemConfigMap>>,
    TError,
    { configmap: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSystemConfigMap>>,
  TError,
  { configmap: string },
  TContext
> => {
  const mutationKey = ['deleteSystemConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSystemConfigMap>>,
    { configmap: string }
  > = (props) => {
    const { configmap } = props ?? {};

    return deleteSystemConfigMap(configmap, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSystemConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSystemConfigMap>>
>;

export type DeleteSystemConfigMapMutationError = unknown;

/**
 * @summary Delete a system-level ConfigMap
 */
export const useDeleteSystemConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSystemConfigMap>>,
      TError,
      { configmap: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSystemConfigMap>>,
  TError,
  { configmap: string },
  TContext
> => {
  const mutationOptions = getDeleteSystemConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch a system-level ConfigMap. Merges provided data
with existing data. Use removeKeys to delete specific keys.
Returns the updated Kubernetes ConfigMap resource.
 * @summary Patch a system-level ConfigMap
 */
export type patchSystemConfigMapResponse200 = {
  data: PatchSystemConfigMap200;
  status: 200;
};

export type patchSystemConfigMapResponseSuccess = patchSystemConfigMapResponse200 & {
  headers: Headers;
};
export type patchSystemConfigMapResponse = patchSystemConfigMapResponseSuccess;

export const getPatchSystemConfigMapUrl = (configmap: string) => {
  return `/v1beta1/system/configmaps/${configmap}`;
};

export const patchSystemConfigMap = async (
  configmap: string,
  patchConfigMapRequestBody: PatchConfigMapRequestBody,
  options?: RequestInit
): Promise<patchSystemConfigMapResponse> => {
  return customFetch<patchSystemConfigMapResponse>(getPatchSystemConfigMapUrl(configmap), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(patchConfigMapRequestBody)
  });
};

export const getPatchSystemConfigMapMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchSystemConfigMap>>,
    TError,
    { configmap: string; data: PatchConfigMapRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchSystemConfigMap>>,
  TError,
  { configmap: string; data: PatchConfigMapRequestBody },
  TContext
> => {
  const mutationKey = ['patchSystemConfigMap'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchSystemConfigMap>>,
    { configmap: string; data: PatchConfigMapRequestBody }
  > = (props) => {
    const { configmap, data } = props ?? {};

    return patchSystemConfigMap(configmap, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchSystemConfigMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchSystemConfigMap>>
>;
export type PatchSystemConfigMapMutationBody = PatchConfigMapRequestBody;
export type PatchSystemConfigMapMutationError = unknown;

/**
 * @summary Patch a system-level ConfigMap
 */
export const usePatchSystemConfigMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchSystemConfigMap>>,
      TError,
      { configmap: string; data: PatchConfigMapRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchSystemConfigMap>>,
  TError,
  { configmap: string; data: PatchConfigMapRequestBody },
  TContext
> => {
  const mutationOptions = getPatchSystemConfigMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
