/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * Kargo API
 * REST API for Kargo
 * OpenAPI spec version: v1alpha1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateAPITokenRequestBody,
  CreateProjectAPIToken201,
  CreateProjectRole201,
  CreateProjectRoleBodyBody,
  CreateSystemAPIToken201,
  GetProjectAPIToken200,
  GetProjectRole200,
  GetSystemAPIToken200,
  GetSystemRole200,
  Grant200,
  GrantRequest,
  ListProjectAPITokens200,
  ListProjectAPITokensParams,
  ListProjectRoles200,
  ListSystemAPITokens200,
  ListSystemAPITokensParams,
  ListSystemRoles200,
  Revoke200,
  RevokeRequest,
  UpdateRole200
} from '.././models';

import { customFetch } from '../../../../lib/api/custom-fetch';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * List project-level API tokens. Returns a Kubernetes SecretList
resource containing heavily redacted Secrets.
 * @summary List project-level API tokens
 */
export type listProjectAPITokensResponse200 = {
  data: ListProjectAPITokens200;
  status: 200;
};

export type listProjectAPITokensResponseSuccess = listProjectAPITokensResponse200 & {
  headers: Headers;
};
export type listProjectAPITokensResponse = listProjectAPITokensResponseSuccess;

export const getListProjectAPITokensUrl = (
  project: string,
  params?: ListProjectAPITokensParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1beta1/projects/${project}/api-tokens?${stringifiedParams}`
    : `/v1beta1/projects/${project}/api-tokens`;
};

export const listProjectAPITokens = async (
  project: string,
  params?: ListProjectAPITokensParams,
  options?: RequestInit
): Promise<listProjectAPITokensResponse> => {
  return customFetch<listProjectAPITokensResponse>(getListProjectAPITokensUrl(project, params), {
    ...options,
    method: 'GET'
  });
};

export const getListProjectAPITokensQueryKey = (
  project?: string,
  params?: ListProjectAPITokensParams
) => {
  return [`/v1beta1/projects/${project}/api-tokens`, ...(params ? [params] : [])] as const;
};

export const getListProjectAPITokensQueryOptions = <
  TData = Awaited<ReturnType<typeof listProjectAPITokens>>,
  TError = unknown
>(
  project: string,
  params?: ListProjectAPITokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectAPITokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListProjectAPITokensQueryKey(project, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProjectAPITokens>>> = () =>
    listProjectAPITokens(project, params, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProjectAPITokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListProjectAPITokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof listProjectAPITokens>>
>;
export type ListProjectAPITokensQueryError = unknown;

export function useListProjectAPITokens<
  TData = Awaited<ReturnType<typeof listProjectAPITokens>>,
  TError = unknown
>(
  project: string,
  params: undefined | ListProjectAPITokensParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectAPITokens>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectAPITokens>>,
          TError,
          Awaited<ReturnType<typeof listProjectAPITokens>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectAPITokens<
  TData = Awaited<ReturnType<typeof listProjectAPITokens>>,
  TError = unknown
>(
  project: string,
  params?: ListProjectAPITokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectAPITokens>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectAPITokens>>,
          TError,
          Awaited<ReturnType<typeof listProjectAPITokens>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectAPITokens<
  TData = Awaited<ReturnType<typeof listProjectAPITokens>>,
  TError = unknown
>(
  project: string,
  params?: ListProjectAPITokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectAPITokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List project-level API tokens
 */

export function useListProjectAPITokens<
  TData = Awaited<ReturnType<typeof listProjectAPITokens>>,
  TError = unknown
>(
  project: string,
  params?: ListProjectAPITokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectAPITokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListProjectAPITokensQueryOptions(project, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a project-level API token by name. Returns a heavily
redacted Kubernetes Secret resource.
 * @summary Retrieve a project-level API token
 */
export type getProjectAPITokenResponse200 = {
  data: GetProjectAPIToken200;
  status: 200;
};

export type getProjectAPITokenResponseSuccess = getProjectAPITokenResponse200 & {
  headers: Headers;
};
export type getProjectAPITokenResponse = getProjectAPITokenResponseSuccess;

export const getGetProjectAPITokenUrl = (project: string, apitoken: string) => {
  return `/v1beta1/projects/${project}/api-tokens/${apitoken}`;
};

export const getProjectAPIToken = async (
  project: string,
  apitoken: string,
  options?: RequestInit
): Promise<getProjectAPITokenResponse> => {
  return customFetch<getProjectAPITokenResponse>(getGetProjectAPITokenUrl(project, apitoken), {
    ...options,
    method: 'GET'
  });
};

export const getGetProjectAPITokenQueryKey = (project?: string, apitoken?: string) => {
  return [`/v1beta1/projects/${project}/api-tokens/${apitoken}`] as const;
};

export const getGetProjectAPITokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectAPIToken>>,
  TError = unknown
>(
  project: string,
  apitoken: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectAPIToken>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProjectAPITokenQueryKey(project, apitoken);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectAPIToken>>> = () =>
    getProjectAPIToken(project, apitoken, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && apitoken),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getProjectAPIToken>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetProjectAPITokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectAPIToken>>
>;
export type GetProjectAPITokenQueryError = unknown;

export function useGetProjectAPIToken<
  TData = Awaited<ReturnType<typeof getProjectAPIToken>>,
  TError = unknown
>(
  project: string,
  apitoken: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectAPIToken>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectAPIToken>>,
          TError,
          Awaited<ReturnType<typeof getProjectAPIToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectAPIToken<
  TData = Awaited<ReturnType<typeof getProjectAPIToken>>,
  TError = unknown
>(
  project: string,
  apitoken: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectAPIToken>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectAPIToken>>,
          TError,
          Awaited<ReturnType<typeof getProjectAPIToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectAPIToken<
  TData = Awaited<ReturnType<typeof getProjectAPIToken>>,
  TError = unknown
>(
  project: string,
  apitoken: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectAPIToken>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a project-level API token
 */

export function useGetProjectAPIToken<
  TData = Awaited<ReturnType<typeof getProjectAPIToken>>,
  TError = unknown
>(
  project: string,
  apitoken: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectAPIToken>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProjectAPITokenQueryOptions(project, apitoken, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a project-level API token from a project's namespace.
 * @summary Delete a project-level API token
 */
export type deleteProjectAPITokenResponse204 = {
  data: void;
  status: 204;
};

export type deleteProjectAPITokenResponseSuccess = deleteProjectAPITokenResponse204 & {
  headers: Headers;
};
export type deleteProjectAPITokenResponse = deleteProjectAPITokenResponseSuccess;

export const getDeleteProjectAPITokenUrl = (project: string, apitoken: string) => {
  return `/v1beta1/projects/${project}/api-tokens/${apitoken}`;
};

export const deleteProjectAPIToken = async (
  project: string,
  apitoken: string,
  options?: RequestInit
): Promise<deleteProjectAPITokenResponse> => {
  return customFetch<deleteProjectAPITokenResponse>(
    getDeleteProjectAPITokenUrl(project, apitoken),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteProjectAPITokenMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectAPIToken>>,
    TError,
    { project: string; apitoken: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectAPIToken>>,
  TError,
  { project: string; apitoken: string },
  TContext
> => {
  const mutationKey = ['deleteProjectAPIToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectAPIToken>>,
    { project: string; apitoken: string }
  > = (props) => {
    const { project, apitoken } = props ?? {};

    return deleteProjectAPIToken(project, apitoken, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectAPITokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectAPIToken>>
>;

export type DeleteProjectAPITokenMutationError = unknown;

/**
 * @summary Delete a project-level API token
 */
export const useDeleteProjectAPIToken = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProjectAPIToken>>,
      TError,
      { project: string; apitoken: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectAPIToken>>,
  TError,
  { project: string; apitoken: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectAPITokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List project-level Kargo Role virtual resources. Returns a
RoleList resource.
 * @summary List project-level Kargo Role virtual resources
 */
export type listProjectRolesResponse200 = {
  data: ListProjectRoles200;
  status: 200;
};

export type listProjectRolesResponseSuccess = listProjectRolesResponse200 & {
  headers: Headers;
};
export type listProjectRolesResponse = listProjectRolesResponseSuccess;

export const getListProjectRolesUrl = (project: string) => {
  return `/v1beta1/projects/${project}/roles`;
};

export const listProjectRoles = async (
  project: string,
  options?: RequestInit
): Promise<listProjectRolesResponse> => {
  return customFetch<listProjectRolesResponse>(getListProjectRolesUrl(project), {
    ...options,
    method: 'GET'
  });
};

export const getListProjectRolesQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/roles`] as const;
};

export const getListProjectRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof listProjectRoles>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjectRoles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListProjectRolesQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProjectRoles>>> = () =>
    listProjectRoles(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProjectRoles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListProjectRolesQueryResult = NonNullable<Awaited<ReturnType<typeof listProjectRoles>>>;
export type ListProjectRolesQueryError = unknown;

export function useListProjectRoles<
  TData = Awaited<ReturnType<typeof listProjectRoles>>,
  TError = unknown
>(
  project: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjectRoles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectRoles>>,
          TError,
          Awaited<ReturnType<typeof listProjectRoles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectRoles<
  TData = Awaited<ReturnType<typeof listProjectRoles>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjectRoles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectRoles>>,
          TError,
          Awaited<ReturnType<typeof listProjectRoles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectRoles<
  TData = Awaited<ReturnType<typeof listProjectRoles>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjectRoles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List project-level Kargo Role virtual resources
 */

export function useListProjectRoles<
  TData = Awaited<ReturnType<typeof listProjectRoles>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProjectRoles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListProjectRolesQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a project-level Kargo Role virtual resource by creating
the underlying Kubernetes ServiceAccount, Role, and RoleBinding
resources.
 * @summary Create a project-level Kargo Role virtual resource
 */
export type createProjectRoleResponse201 = {
  data: CreateProjectRole201;
  status: 201;
};

export type createProjectRoleResponseSuccess = createProjectRoleResponse201 & {
  headers: Headers;
};
export type createProjectRoleResponse = createProjectRoleResponseSuccess;

export const getCreateProjectRoleUrl = (project: string) => {
  return `/v1beta1/projects/${project}/roles`;
};

export const createProjectRole = async (
  project: string,
  createProjectRoleBodyBody: CreateProjectRoleBodyBody,
  options?: RequestInit
): Promise<createProjectRoleResponse> => {
  return customFetch<createProjectRoleResponse>(getCreateProjectRoleUrl(project), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createProjectRoleBodyBody)
  });
};

export const getCreateProjectRoleMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectRole>>,
    TError,
    { project: string; data: CreateProjectRoleBodyBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectRole>>,
  TError,
  { project: string; data: CreateProjectRoleBodyBody },
  TContext
> => {
  const mutationKey = ['createProjectRole'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectRole>>,
    { project: string; data: CreateProjectRoleBodyBody }
  > = (props) => {
    const { project, data } = props ?? {};

    return createProjectRole(project, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProjectRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectRole>>
>;
export type CreateProjectRoleMutationBody = CreateProjectRoleBodyBody;
export type CreateProjectRoleMutationError = unknown;

/**
 * @summary Create a project-level Kargo Role virtual resource
 */
export const useCreateProjectRole = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProjectRole>>,
      TError,
      { project: string; data: CreateProjectRoleBodyBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProjectRole>>,
  TError,
  { project: string; data: CreateProjectRoleBodyBody },
  TContext
> => {
  const mutationOptions = getCreateProjectRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Grant a project-level Kargo Role to users or grant permissions
to a project-level Kargo Role.
 * @summary Grant permissions
 */
export type grantResponse200 = {
  data: Grant200;
  status: 200;
};

export type grantResponseSuccess = grantResponse200 & {
  headers: Headers;
};
export type grantResponse = grantResponseSuccess;

export const getGrantUrl = (project: string) => {
  return `/v1beta1/projects/${project}/roles/grants`;
};

export const grant = async (
  project: string,
  grantRequest: GrantRequest,
  options?: RequestInit
): Promise<grantResponse> => {
  return customFetch<grantResponse>(getGrantUrl(project), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(grantRequest)
  });
};

export const getGrantMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof grant>>,
    TError,
    { project: string; data: GrantRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof grant>>,
  TError,
  { project: string; data: GrantRequest },
  TContext
> => {
  const mutationKey = ['grant'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof grant>>,
    { project: string; data: GrantRequest }
  > = (props) => {
    const { project, data } = props ?? {};

    return grant(project, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GrantMutationResult = NonNullable<Awaited<ReturnType<typeof grant>>>;
export type GrantMutationBody = GrantRequest;
export type GrantMutationError = unknown;

/**
 * @summary Grant permissions
 */
export const useGrant = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof grant>>,
      TError,
      { project: string; data: GrantRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof grant>>,
  TError,
  { project: string; data: GrantRequest },
  TContext
> => {
  const mutationOptions = getGrantMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Revoke a project-level Kargo Role from users or revoke
permissions from a project-level Kargo Role.
 * @summary Revoke permissions
 */
export type revokeResponse200 = {
  data: Revoke200;
  status: 200;
};

export type revokeResponseSuccess = revokeResponse200 & {
  headers: Headers;
};
export type revokeResponse = revokeResponseSuccess;

export const getRevokeUrl = (project: string) => {
  return `/v1beta1/projects/${project}/roles/revocations`;
};

export const revoke = async (
  project: string,
  revokeRequest: RevokeRequest,
  options?: RequestInit
): Promise<revokeResponse> => {
  return customFetch<revokeResponse>(getRevokeUrl(project), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(revokeRequest)
  });
};

export const getRevokeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revoke>>,
    TError,
    { project: string; data: RevokeRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof revoke>>,
  TError,
  { project: string; data: RevokeRequest },
  TContext
> => {
  const mutationKey = ['revoke'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revoke>>,
    { project: string; data: RevokeRequest }
  > = (props) => {
    const { project, data } = props ?? {};

    return revoke(project, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RevokeMutationResult = NonNullable<Awaited<ReturnType<typeof revoke>>>;
export type RevokeMutationBody = RevokeRequest;
export type RevokeMutationError = unknown;

/**
 * @summary Revoke permissions
 */
export const useRevoke = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof revoke>>,
      TError,
      { project: string; data: RevokeRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof revoke>>,
  TError,
  { project: string; data: RevokeRequest },
  TContext
> => {
  const mutationOptions = getRevokeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve a project-level Kargo Role virtual resource by name.
Returns a Kargo Role virtual resource or its underlying
Kubernetes resources.
 * @summary Retrieve a project-level Kargo Role virtual resource
 */
export type getProjectRoleResponse200 = {
  data: GetProjectRole200;
  status: 200;
};

export type getProjectRoleResponseSuccess = getProjectRoleResponse200 & {
  headers: Headers;
};
export type getProjectRoleResponse = getProjectRoleResponseSuccess;

export const getGetProjectRoleUrl = (project: string, role: string) => {
  return `/v1beta1/projects/${project}/roles/${role}`;
};

export const getProjectRole = async (
  project: string,
  role: string,
  options?: RequestInit
): Promise<getProjectRoleResponse> => {
  return customFetch<getProjectRoleResponse>(getGetProjectRoleUrl(project, role), {
    ...options,
    method: 'GET'
  });
};

export const getGetProjectRoleQueryKey = (project?: string, role?: string) => {
  return [`/v1beta1/projects/${project}/roles/${role}`] as const;
};

export const getGetProjectRoleQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectRole>>,
  TError = unknown
>(
  project: string,
  role: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectRole>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProjectRoleQueryKey(project, role);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectRole>>> = () =>
    getProjectRole(project, role, requestOptions);

  return { queryKey, queryFn, enabled: !!(project && role), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectRole>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectRole>>>;
export type GetProjectRoleQueryError = unknown;

export function useGetProjectRole<
  TData = Awaited<ReturnType<typeof getProjectRole>>,
  TError = unknown
>(
  project: string,
  role: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectRole>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectRole>>,
          TError,
          Awaited<ReturnType<typeof getProjectRole>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectRole<
  TData = Awaited<ReturnType<typeof getProjectRole>>,
  TError = unknown
>(
  project: string,
  role: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectRole>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectRole>>,
          TError,
          Awaited<ReturnType<typeof getProjectRole>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectRole<
  TData = Awaited<ReturnType<typeof getProjectRole>>,
  TError = unknown
>(
  project: string,
  role: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectRole>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a project-level Kargo Role virtual resource
 */

export function useGetProjectRole<
  TData = Awaited<ReturnType<typeof getProjectRole>>,
  TError = unknown
>(
  project: string,
  role: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectRole>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProjectRoleQueryOptions(project, role, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update a project-level Kargo Role virtual resource by updating
the underlying Kubernetes ServiceAccount, Role, and RoleBinding
resources.
 * @summary Update a project-level Kargo Role virtual resource
 */
export type updateRoleResponse200 = {
  data: UpdateRole200;
  status: 200;
};

export type updateRoleResponseSuccess = updateRoleResponse200 & {
  headers: Headers;
};
export type updateRoleResponse = updateRoleResponseSuccess;

export const getUpdateRoleUrl = (project: string, role: string) => {
  return `/v1beta1/projects/${project}/roles/${role}`;
};

export const updateRole = async (
  project: string,
  role: string,
  createProjectRoleBodyBody: CreateProjectRoleBodyBody,
  options?: RequestInit
): Promise<updateRoleResponse> => {
  return customFetch<updateRoleResponse>(getUpdateRoleUrl(project, role), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createProjectRoleBodyBody)
  });
};

export const getUpdateRoleMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRole>>,
    TError,
    { project: string; role: string; data: CreateProjectRoleBodyBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRole>>,
  TError,
  { project: string; role: string; data: CreateProjectRoleBodyBody },
  TContext
> => {
  const mutationKey = ['updateRole'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRole>>,
    { project: string; role: string; data: CreateProjectRoleBodyBody }
  > = (props) => {
    const { project, role, data } = props ?? {};

    return updateRole(project, role, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>;
export type UpdateRoleMutationBody = CreateProjectRoleBodyBody;
export type UpdateRoleMutationError = unknown;

/**
 * @summary Update a project-level Kargo Role virtual resource
 */
export const useUpdateRole = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRole>>,
      TError,
      { project: string; role: string; data: CreateProjectRoleBodyBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateRole>>,
  TError,
  { project: string; role: string; data: CreateProjectRoleBodyBody },
  TContext
> => {
  const mutationOptions = getUpdateRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a project-level Kargo Role virtual resource by deleting
the underlying Kubernetes ServiceAccount, Role, and RoleBinding
resources from the project's namespace.
 * @summary Delete a project-level Kargo Role virtual resource
 */
export type deleteProjectRoleResponse204 = {
  data: void;
  status: 204;
};

export type deleteProjectRoleResponseSuccess = deleteProjectRoleResponse204 & {
  headers: Headers;
};
export type deleteProjectRoleResponse = deleteProjectRoleResponseSuccess;

export const getDeleteProjectRoleUrl = (project: string, role: string) => {
  return `/v1beta1/projects/${project}/roles/${role}`;
};

export const deleteProjectRole = async (
  project: string,
  role: string,
  options?: RequestInit
): Promise<deleteProjectRoleResponse> => {
  return customFetch<deleteProjectRoleResponse>(getDeleteProjectRoleUrl(project, role), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteProjectRoleMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectRole>>,
    TError,
    { project: string; role: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectRole>>,
  TError,
  { project: string; role: string },
  TContext
> => {
  const mutationKey = ['deleteProjectRole'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectRole>>,
    { project: string; role: string }
  > = (props) => {
    const { project, role } = props ?? {};

    return deleteProjectRole(project, role, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectRole>>
>;

export type DeleteProjectRoleMutationError = unknown;

/**
 * @summary Delete a project-level Kargo Role virtual resource
 */
export const useDeleteProjectRole = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProjectRole>>,
      TError,
      { project: string; role: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectRole>>,
  TError,
  { project: string; role: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a project-level API token associated with a Kargo Role
virtual resource. Returns a Kubernetes Secret resource
representing the token. Store it securely. The token is not
retrievable via the Kargo API after creation except in a
redacted form.
 * @summary Create a project-level API token
 */
export type createProjectAPITokenResponse201 = {
  data: CreateProjectAPIToken201;
  status: 201;
};

export type createProjectAPITokenResponseSuccess = createProjectAPITokenResponse201 & {
  headers: Headers;
};
export type createProjectAPITokenResponse = createProjectAPITokenResponseSuccess;

export const getCreateProjectAPITokenUrl = (project: string, role: string) => {
  return `/v1beta1/projects/${project}/roles/${role}/api-tokens`;
};

export const createProjectAPIToken = async (
  project: string,
  role: string,
  createAPITokenRequestBody: CreateAPITokenRequestBody,
  options?: RequestInit
): Promise<createProjectAPITokenResponse> => {
  return customFetch<createProjectAPITokenResponse>(getCreateProjectAPITokenUrl(project, role), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createAPITokenRequestBody)
  });
};

export const getCreateProjectAPITokenMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectAPIToken>>,
    TError,
    { project: string; role: string; data: CreateAPITokenRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectAPIToken>>,
  TError,
  { project: string; role: string; data: CreateAPITokenRequestBody },
  TContext
> => {
  const mutationKey = ['createProjectAPIToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectAPIToken>>,
    { project: string; role: string; data: CreateAPITokenRequestBody }
  > = (props) => {
    const { project, role, data } = props ?? {};

    return createProjectAPIToken(project, role, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProjectAPITokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectAPIToken>>
>;
export type CreateProjectAPITokenMutationBody = CreateAPITokenRequestBody;
export type CreateProjectAPITokenMutationError = unknown;

/**
 * @summary Create a project-level API token
 */
export const useCreateProjectAPIToken = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProjectAPIToken>>,
      TError,
      { project: string; role: string; data: CreateAPITokenRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProjectAPIToken>>,
  TError,
  { project: string; role: string; data: CreateAPITokenRequestBody },
  TContext
> => {
  const mutationOptions = getCreateProjectAPITokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List system-level API tokens. Returns a Kubernetes SecretList
resource containing heavily redacted Secrets.
 * @summary List system-level API tokens
 */
export type listSystemAPITokensResponse200 = {
  data: ListSystemAPITokens200;
  status: 200;
};

export type listSystemAPITokensResponseSuccess = listSystemAPITokensResponse200 & {
  headers: Headers;
};
export type listSystemAPITokensResponse = listSystemAPITokensResponseSuccess;

export const getListSystemAPITokensUrl = (params?: ListSystemAPITokensParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1beta1/system/api-tokens?${stringifiedParams}`
    : `/v1beta1/system/api-tokens`;
};

export const listSystemAPITokens = async (
  params?: ListSystemAPITokensParams,
  options?: RequestInit
): Promise<listSystemAPITokensResponse> => {
  return customFetch<listSystemAPITokensResponse>(getListSystemAPITokensUrl(params), {
    ...options,
    method: 'GET'
  });
};

export const getListSystemAPITokensQueryKey = (params?: ListSystemAPITokensParams) => {
  return [`/v1beta1/system/api-tokens`, ...(params ? [params] : [])] as const;
};

export const getListSystemAPITokensQueryOptions = <
  TData = Awaited<ReturnType<typeof listSystemAPITokens>>,
  TError = unknown
>(
  params?: ListSystemAPITokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemAPITokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListSystemAPITokensQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSystemAPITokens>>> = () =>
    listSystemAPITokens(params, requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSystemAPITokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSystemAPITokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSystemAPITokens>>
>;
export type ListSystemAPITokensQueryError = unknown;

export function useListSystemAPITokens<
  TData = Awaited<ReturnType<typeof listSystemAPITokens>>,
  TError = unknown
>(
  params: undefined | ListSystemAPITokensParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemAPITokens>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSystemAPITokens>>,
          TError,
          Awaited<ReturnType<typeof listSystemAPITokens>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSystemAPITokens<
  TData = Awaited<ReturnType<typeof listSystemAPITokens>>,
  TError = unknown
>(
  params?: ListSystemAPITokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemAPITokens>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSystemAPITokens>>,
          TError,
          Awaited<ReturnType<typeof listSystemAPITokens>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSystemAPITokens<
  TData = Awaited<ReturnType<typeof listSystemAPITokens>>,
  TError = unknown
>(
  params?: ListSystemAPITokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemAPITokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List system-level API tokens
 */

export function useListSystemAPITokens<
  TData = Awaited<ReturnType<typeof listSystemAPITokens>>,
  TError = unknown
>(
  params?: ListSystemAPITokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemAPITokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListSystemAPITokensQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a system-level API token by name. Returns a heavily
redacted Kubernetes Secret resource.
 * @summary Retrieve a system-level API token
 */
export type getSystemAPITokenResponse200 = {
  data: GetSystemAPIToken200;
  status: 200;
};

export type getSystemAPITokenResponseSuccess = getSystemAPITokenResponse200 & {
  headers: Headers;
};
export type getSystemAPITokenResponse = getSystemAPITokenResponseSuccess;

export const getGetSystemAPITokenUrl = (apitoken: string) => {
  return `/v1beta1/system/api-tokens/${apitoken}`;
};

export const getSystemAPIToken = async (
  apitoken: string,
  options?: RequestInit
): Promise<getSystemAPITokenResponse> => {
  return customFetch<getSystemAPITokenResponse>(getGetSystemAPITokenUrl(apitoken), {
    ...options,
    method: 'GET'
  });
};

export const getGetSystemAPITokenQueryKey = (apitoken?: string) => {
  return [`/v1beta1/system/api-tokens/${apitoken}`] as const;
};

export const getGetSystemAPITokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getSystemAPIToken>>,
  TError = unknown
>(
  apitoken: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemAPIToken>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSystemAPITokenQueryKey(apitoken);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemAPIToken>>> = () =>
    getSystemAPIToken(apitoken, requestOptions);

  return { queryKey, queryFn, enabled: !!apitoken, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSystemAPIToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSystemAPITokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSystemAPIToken>>
>;
export type GetSystemAPITokenQueryError = unknown;

export function useGetSystemAPIToken<
  TData = Awaited<ReturnType<typeof getSystemAPIToken>>,
  TError = unknown
>(
  apitoken: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemAPIToken>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemAPIToken>>,
          TError,
          Awaited<ReturnType<typeof getSystemAPIToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSystemAPIToken<
  TData = Awaited<ReturnType<typeof getSystemAPIToken>>,
  TError = unknown
>(
  apitoken: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemAPIToken>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemAPIToken>>,
          TError,
          Awaited<ReturnType<typeof getSystemAPIToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSystemAPIToken<
  TData = Awaited<ReturnType<typeof getSystemAPIToken>>,
  TError = unknown
>(
  apitoken: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemAPIToken>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a system-level API token
 */

export function useGetSystemAPIToken<
  TData = Awaited<ReturnType<typeof getSystemAPIToken>>,
  TError = unknown
>(
  apitoken: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemAPIToken>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSystemAPITokenQueryOptions(apitoken, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a system-level API token.
 * @summary Delete a system-level API token
 */
export type deleteSystemAPITokenResponse204 = {
  data: void;
  status: 204;
};

export type deleteSystemAPITokenResponseSuccess = deleteSystemAPITokenResponse204 & {
  headers: Headers;
};
export type deleteSystemAPITokenResponse = deleteSystemAPITokenResponseSuccess;

export const getDeleteSystemAPITokenUrl = (apitoken: string) => {
  return `/v1beta1/system/api-tokens/${apitoken}`;
};

export const deleteSystemAPIToken = async (
  apitoken: string,
  options?: RequestInit
): Promise<deleteSystemAPITokenResponse> => {
  return customFetch<deleteSystemAPITokenResponse>(getDeleteSystemAPITokenUrl(apitoken), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteSystemAPITokenMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSystemAPIToken>>,
    TError,
    { apitoken: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSystemAPIToken>>,
  TError,
  { apitoken: string },
  TContext
> => {
  const mutationKey = ['deleteSystemAPIToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSystemAPIToken>>,
    { apitoken: string }
  > = (props) => {
    const { apitoken } = props ?? {};

    return deleteSystemAPIToken(apitoken, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSystemAPITokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSystemAPIToken>>
>;

export type DeleteSystemAPITokenMutationError = unknown;

/**
 * @summary Delete a system-level API token
 */
export const useDeleteSystemAPIToken = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSystemAPIToken>>,
      TError,
      { apitoken: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSystemAPIToken>>,
  TError,
  { apitoken: string },
  TContext
> => {
  const mutationOptions = getDeleteSystemAPITokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List system-level Kargo Role virtual resources. Returns a
RoleList resource.
 * @summary List system-level Kargo Role virtual resources
 */
export type listSystemRolesResponse200 = {
  data: ListSystemRoles200;
  status: 200;
};

export type listSystemRolesResponseSuccess = listSystemRolesResponse200 & {
  headers: Headers;
};
export type listSystemRolesResponse = listSystemRolesResponseSuccess;

export const getListSystemRolesUrl = () => {
  return `/v1beta1/system/roles`;
};

export const listSystemRoles = async (options?: RequestInit): Promise<listSystemRolesResponse> => {
  return customFetch<listSystemRolesResponse>(getListSystemRolesUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListSystemRolesQueryKey = () => {
  return [`/v1beta1/system/roles`] as const;
};

export const getListSystemRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof listSystemRoles>>,
  TError = unknown
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listSystemRoles>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListSystemRolesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSystemRoles>>> = () =>
    listSystemRoles(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSystemRoles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSystemRolesQueryResult = NonNullable<Awaited<ReturnType<typeof listSystemRoles>>>;
export type ListSystemRolesQueryError = unknown;

export function useListSystemRoles<
  TData = Awaited<ReturnType<typeof listSystemRoles>>,
  TError = unknown
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listSystemRoles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSystemRoles>>,
          TError,
          Awaited<ReturnType<typeof listSystemRoles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSystemRoles<
  TData = Awaited<ReturnType<typeof listSystemRoles>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listSystemRoles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSystemRoles>>,
          TError,
          Awaited<ReturnType<typeof listSystemRoles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSystemRoles<
  TData = Awaited<ReturnType<typeof listSystemRoles>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listSystemRoles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List system-level Kargo Role virtual resources
 */

export function useListSystemRoles<
  TData = Awaited<ReturnType<typeof listSystemRoles>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listSystemRoles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListSystemRolesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a system-level Kargo Role virtual resource by name.
Returns a Kargo Role virtual resource or its underlying
Kubernetes resources.
 * @summary Retrieve a system-level Kargo Role virtual resource
 */
export type getSystemRoleResponse200 = {
  data: GetSystemRole200;
  status: 200;
};

export type getSystemRoleResponseSuccess = getSystemRoleResponse200 & {
  headers: Headers;
};
export type getSystemRoleResponse = getSystemRoleResponseSuccess;

export const getGetSystemRoleUrl = (role: string) => {
  return `/v1beta1/system/roles/${role}`;
};

export const getSystemRole = async (
  role: string,
  options?: RequestInit
): Promise<getSystemRoleResponse> => {
  return customFetch<getSystemRoleResponse>(getGetSystemRoleUrl(role), {
    ...options,
    method: 'GET'
  });
};

export const getGetSystemRoleQueryKey = (role?: string) => {
  return [`/v1beta1/system/roles/${role}`] as const;
};

export const getGetSystemRoleQueryOptions = <
  TData = Awaited<ReturnType<typeof getSystemRole>>,
  TError = unknown
>(
  role: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemRole>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSystemRoleQueryKey(role);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemRole>>> = () =>
    getSystemRole(role, requestOptions);

  return { queryKey, queryFn, enabled: !!role, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSystemRole>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSystemRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getSystemRole>>>;
export type GetSystemRoleQueryError = unknown;

export function useGetSystemRole<
  TData = Awaited<ReturnType<typeof getSystemRole>>,
  TError = unknown
>(
  role: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemRole>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemRole>>,
          TError,
          Awaited<ReturnType<typeof getSystemRole>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSystemRole<
  TData = Awaited<ReturnType<typeof getSystemRole>>,
  TError = unknown
>(
  role: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemRole>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemRole>>,
          TError,
          Awaited<ReturnType<typeof getSystemRole>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSystemRole<
  TData = Awaited<ReturnType<typeof getSystemRole>>,
  TError = unknown
>(
  role: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemRole>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve a system-level Kargo Role virtual resource
 */

export function useGetSystemRole<
  TData = Awaited<ReturnType<typeof getSystemRole>>,
  TError = unknown
>(
  role: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSystemRole>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSystemRoleQueryOptions(role, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a system-level API token associated with a system-level
Kargo Role virtual resource. Returns a Kubernetes Secret
resource representing the token. Store it securely. The token
is not retrievable via the Kargo API after creation except in
a redacted form.
 * @summary Create a system-level API token
 */
export type createSystemAPITokenResponse201 = {
  data: CreateSystemAPIToken201;
  status: 201;
};

export type createSystemAPITokenResponseSuccess = createSystemAPITokenResponse201 & {
  headers: Headers;
};
export type createSystemAPITokenResponse = createSystemAPITokenResponseSuccess;

export const getCreateSystemAPITokenUrl = (role: string) => {
  return `/v1beta1/system/roles/${role}/api-tokens`;
};

export const createSystemAPIToken = async (
  role: string,
  createAPITokenRequestBody: CreateAPITokenRequestBody,
  options?: RequestInit
): Promise<createSystemAPITokenResponse> => {
  return customFetch<createSystemAPITokenResponse>(getCreateSystemAPITokenUrl(role), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createAPITokenRequestBody)
  });
};

export const getCreateSystemAPITokenMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSystemAPIToken>>,
    TError,
    { role: string; data: CreateAPITokenRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSystemAPIToken>>,
  TError,
  { role: string; data: CreateAPITokenRequestBody },
  TContext
> => {
  const mutationKey = ['createSystemAPIToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSystemAPIToken>>,
    { role: string; data: CreateAPITokenRequestBody }
  > = (props) => {
    const { role, data } = props ?? {};

    return createSystemAPIToken(role, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSystemAPITokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSystemAPIToken>>
>;
export type CreateSystemAPITokenMutationBody = CreateAPITokenRequestBody;
export type CreateSystemAPITokenMutationError = unknown;

/**
 * @summary Create a system-level API token
 */
export const useCreateSystemAPIToken = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSystemAPIToken>>,
      TError,
      { role: string; data: CreateAPITokenRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createSystemAPIToken>>,
  TError,
  { role: string; data: CreateAPITokenRequestBody },
  TContext
> => {
  const mutationOptions = getCreateSystemAPITokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
