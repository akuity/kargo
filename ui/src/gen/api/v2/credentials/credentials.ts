/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * Kargo API
 * REST API for Kargo
 * OpenAPI spec version: v1alpha1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateGenericCredentialsRequestBody,
  CreateProjectGenericCredentials201,
  CreateProjectRepoCredentials201,
  CreateRepoCredentialsRequestBody,
  CreateSharedGenericCredentials201,
  CreateSharedRepoCredentials201,
  CreateSystemGenericCredentials201,
  GetProjectGenericCredentials200,
  GetProjectRepoCredentials200,
  GetSharedGenericCredentials200,
  GetSharedRepoCredentials200,
  GetSystemGenericCredentials200,
  ListProjectGenericCredentials200,
  ListProjectRepoCredentials200,
  ListSharedGenericCredentials200,
  ListSharedRepoCredentials200,
  ListSystemGenericCredentials200,
  PatchGenericCredentialsRequestBody,
  PatchProjectGenericCredentials200,
  PatchProjectRepoCredentials200,
  PatchRepoCredentialsRequestBody,
  PatchSharedGenericCredentials200,
  PatchSharedRepoCredentials200,
  PatchSystemGenericCredentials200,
  UpdateGenericCredentialsRequestBody,
  UpdateProjectGenericCredentials200,
  UpdateProjectRepoCredentials200,
  UpdateRepoCredentialsRequestBody,
  UpdateSharedGenericCredentials200,
  UpdateSharedRepoCredentials200,
  UpdateSystemGenericCredentials200
} from '.././models';

import { customFetch } from '../../../../lib/api/custom-fetch';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * List project-level generic credentials. Returns a Kubernetes
SecretList resource containing heavily redacted Secrets.
 * @summary List project-level generic credentials
 */
export type listProjectGenericCredentialsResponse200 = {
  data: ListProjectGenericCredentials200;
  status: 200;
};

export type listProjectGenericCredentialsResponseSuccess =
  listProjectGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type listProjectGenericCredentialsResponse = listProjectGenericCredentialsResponseSuccess;

export const getListProjectGenericCredentialsUrl = (project: string) => {
  return `/v1beta1/projects/${project}/generic-credentials`;
};

export const listProjectGenericCredentials = async (
  project: string,
  options?: RequestInit
): Promise<listProjectGenericCredentialsResponse> => {
  return customFetch<listProjectGenericCredentialsResponse>(
    getListProjectGenericCredentialsUrl(project),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getListProjectGenericCredentialsQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/generic-credentials`] as const;
};

export const getListProjectGenericCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListProjectGenericCredentialsQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProjectGenericCredentials>>> = () =>
    listProjectGenericCredentials(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProjectGenericCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListProjectGenericCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listProjectGenericCredentials>>
>;
export type ListProjectGenericCredentialsQueryError = unknown;

export function useListProjectGenericCredentials<
  TData = Awaited<ReturnType<typeof listProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectGenericCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof listProjectGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectGenericCredentials<
  TData = Awaited<ReturnType<typeof listProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectGenericCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof listProjectGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectGenericCredentials<
  TData = Awaited<ReturnType<typeof listProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List project-level generic credentials
 */

export function useListProjectGenericCredentials<
  TData = Awaited<ReturnType<typeof listProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListProjectGenericCredentialsQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create project-level generic credentials. Returns a heavily
redacted Kubernetes Secret resource.
 * @summary Create project-level generic credentials
 */
export type createProjectGenericCredentialsResponse201 = {
  data: CreateProjectGenericCredentials201;
  status: 201;
};

export type createProjectGenericCredentialsResponseSuccess =
  createProjectGenericCredentialsResponse201 & {
    headers: Headers;
  };
export type createProjectGenericCredentialsResponse =
  createProjectGenericCredentialsResponseSuccess;

export const getCreateProjectGenericCredentialsUrl = (project: string) => {
  return `/v1beta1/projects/${project}/generic-credentials`;
};

export const createProjectGenericCredentials = async (
  project: string,
  createGenericCredentialsRequestBody: CreateGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<createProjectGenericCredentialsResponse> => {
  return customFetch<createProjectGenericCredentialsResponse>(
    getCreateProjectGenericCredentialsUrl(project),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(createGenericCredentialsRequestBody)
    }
  );
};

export const getCreateProjectGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectGenericCredentials>>,
    TError,
    { project: string; data: CreateGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectGenericCredentials>>,
  TError,
  { project: string; data: CreateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['createProjectGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectGenericCredentials>>,
    { project: string; data: CreateGenericCredentialsRequestBody }
  > = (props) => {
    const { project, data } = props ?? {};

    return createProjectGenericCredentials(project, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProjectGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectGenericCredentials>>
>;
export type CreateProjectGenericCredentialsMutationBody = CreateGenericCredentialsRequestBody;
export type CreateProjectGenericCredentialsMutationError = unknown;

/**
 * @summary Create project-level generic credentials
 */
export const useCreateProjectGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProjectGenericCredentials>>,
      TError,
      { project: string; data: CreateGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProjectGenericCredentials>>,
  TError,
  { project: string; data: CreateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getCreateProjectGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve project-level generic credentials by name. Returns a
heavily redacted Kubernetes Secret resource.
 * @summary Retrieve project-level generic credentials
 */
export type getProjectGenericCredentialsResponse200 = {
  data: GetProjectGenericCredentials200;
  status: 200;
};

export type getProjectGenericCredentialsResponseSuccess =
  getProjectGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type getProjectGenericCredentialsResponse = getProjectGenericCredentialsResponseSuccess;

export const getGetProjectGenericCredentialsUrl = (project: string, genericCredentials: string) => {
  return `/v1beta1/projects/${project}/generic-credentials/${genericCredentials}`;
};

export const getProjectGenericCredentials = async (
  project: string,
  genericCredentials: string,
  options?: RequestInit
): Promise<getProjectGenericCredentialsResponse> => {
  return customFetch<getProjectGenericCredentialsResponse>(
    getGetProjectGenericCredentialsUrl(project, genericCredentials),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetProjectGenericCredentialsQueryKey = (
  project?: string,
  genericCredentials?: string
) => {
  return [`/v1beta1/projects/${project}/generic-credentials/${genericCredentials}`] as const;
};

export const getGetProjectGenericCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProjectGenericCredentialsQueryKey(project, genericCredentials);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectGenericCredentials>>> = () =>
    getProjectGenericCredentials(project, genericCredentials, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && genericCredentials),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getProjectGenericCredentials>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetProjectGenericCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectGenericCredentials>>
>;
export type GetProjectGenericCredentialsQueryError = unknown;

export function useGetProjectGenericCredentials<
  TData = Awaited<ReturnType<typeof getProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  genericCredentials: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectGenericCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof getProjectGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectGenericCredentials<
  TData = Awaited<ReturnType<typeof getProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectGenericCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof getProjectGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectGenericCredentials<
  TData = Awaited<ReturnType<typeof getProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve project-level generic credentials
 */

export function useGetProjectGenericCredentials<
  TData = Awaited<ReturnType<typeof getProjectGenericCredentials>>,
  TError = unknown
>(
  project: string,
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProjectGenericCredentialsQueryOptions(
    project,
    genericCredentials,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replace project-level generic credentials. All existing data is
replaced. Returns a heavily redacted Kubernetes Secret resource.
 * @summary Replace project-level generic credentials
 */
export type updateProjectGenericCredentialsResponse200 = {
  data: UpdateProjectGenericCredentials200;
  status: 200;
};

export type updateProjectGenericCredentialsResponseSuccess =
  updateProjectGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type updateProjectGenericCredentialsResponse =
  updateProjectGenericCredentialsResponseSuccess;

export const getUpdateProjectGenericCredentialsUrl = (
  project: string,
  genericCredentials: string
) => {
  return `/v1beta1/projects/${project}/generic-credentials/${genericCredentials}`;
};

export const updateProjectGenericCredentials = async (
  project: string,
  genericCredentials: string,
  updateGenericCredentialsRequestBody: UpdateGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<updateProjectGenericCredentialsResponse> => {
  return customFetch<updateProjectGenericCredentialsResponse>(
    getUpdateProjectGenericCredentialsUrl(project, genericCredentials),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(updateGenericCredentialsRequestBody)
    }
  );
};

export const getUpdateProjectGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectGenericCredentials>>,
    TError,
    { project: string; genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProjectGenericCredentials>>,
  TError,
  { project: string; genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['updateProjectGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProjectGenericCredentials>>,
    { project: string; genericCredentials: string; data: UpdateGenericCredentialsRequestBody }
  > = (props) => {
    const { project, genericCredentials, data } = props ?? {};

    return updateProjectGenericCredentials(project, genericCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProjectGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProjectGenericCredentials>>
>;
export type UpdateProjectGenericCredentialsMutationBody = UpdateGenericCredentialsRequestBody;
export type UpdateProjectGenericCredentialsMutationError = unknown;

/**
 * @summary Replace project-level generic credentials
 */
export const useUpdateProjectGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProjectGenericCredentials>>,
      TError,
      { project: string; genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProjectGenericCredentials>>,
  TError,
  { project: string; genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateProjectGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete generic credentials from a project's namespace.
 * @summary Delete project-level generic credentials
 */
export type deleteProjectGenericCredentialsResponse204 = {
  data: void;
  status: 204;
};

export type deleteProjectGenericCredentialsResponseSuccess =
  deleteProjectGenericCredentialsResponse204 & {
    headers: Headers;
  };
export type deleteProjectGenericCredentialsResponse =
  deleteProjectGenericCredentialsResponseSuccess;

export const getDeleteProjectGenericCredentialsUrl = (
  project: string,
  genericCredentials: string
) => {
  return `/v1beta1/projects/${project}/generic-credentials/${genericCredentials}`;
};

export const deleteProjectGenericCredentials = async (
  project: string,
  genericCredentials: string,
  options?: RequestInit
): Promise<deleteProjectGenericCredentialsResponse> => {
  return customFetch<deleteProjectGenericCredentialsResponse>(
    getDeleteProjectGenericCredentialsUrl(project, genericCredentials),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteProjectGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectGenericCredentials>>,
    TError,
    { project: string; genericCredentials: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectGenericCredentials>>,
  TError,
  { project: string; genericCredentials: string },
  TContext
> => {
  const mutationKey = ['deleteProjectGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectGenericCredentials>>,
    { project: string; genericCredentials: string }
  > = (props) => {
    const { project, genericCredentials } = props ?? {};

    return deleteProjectGenericCredentials(project, genericCredentials, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectGenericCredentials>>
>;

export type DeleteProjectGenericCredentialsMutationError = unknown;

/**
 * @summary Delete project-level generic credentials
 */
export const useDeleteProjectGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProjectGenericCredentials>>,
      TError,
      { project: string; genericCredentials: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectGenericCredentials>>,
  TError,
  { project: string; genericCredentials: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch project-level generic credentials. Merges provided data
with existing data. Use removeKeys to delete specific keys.
Returns a heavily redacted Kubernetes Secret resource.
 * @summary Patch project-level generic credentials
 */
export type patchProjectGenericCredentialsResponse200 = {
  data: PatchProjectGenericCredentials200;
  status: 200;
};

export type patchProjectGenericCredentialsResponseSuccess =
  patchProjectGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type patchProjectGenericCredentialsResponse = patchProjectGenericCredentialsResponseSuccess;

export const getPatchProjectGenericCredentialsUrl = (
  project: string,
  genericCredentials: string
) => {
  return `/v1beta1/projects/${project}/generic-credentials/${genericCredentials}`;
};

export const patchProjectGenericCredentials = async (
  project: string,
  genericCredentials: string,
  patchGenericCredentialsRequestBody: PatchGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<patchProjectGenericCredentialsResponse> => {
  return customFetch<patchProjectGenericCredentialsResponse>(
    getPatchProjectGenericCredentialsUrl(project, genericCredentials),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchGenericCredentialsRequestBody)
    }
  );
};

export const getPatchProjectGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchProjectGenericCredentials>>,
    TError,
    { project: string; genericCredentials: string; data: PatchGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchProjectGenericCredentials>>,
  TError,
  { project: string; genericCredentials: string; data: PatchGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['patchProjectGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchProjectGenericCredentials>>,
    { project: string; genericCredentials: string; data: PatchGenericCredentialsRequestBody }
  > = (props) => {
    const { project, genericCredentials, data } = props ?? {};

    return patchProjectGenericCredentials(project, genericCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchProjectGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchProjectGenericCredentials>>
>;
export type PatchProjectGenericCredentialsMutationBody = PatchGenericCredentialsRequestBody;
export type PatchProjectGenericCredentialsMutationError = unknown;

/**
 * @summary Patch project-level generic credentials
 */
export const usePatchProjectGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchProjectGenericCredentials>>,
      TError,
      { project: string; genericCredentials: string; data: PatchGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchProjectGenericCredentials>>,
  TError,
  { project: string; genericCredentials: string; data: PatchGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getPatchProjectGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List project-level repository credentials. Returns a SecretList
resource containing heavily redacted Secrets.
 * @summary List project-level repository credentials
 */
export type listProjectRepoCredentialsResponse200 = {
  data: ListProjectRepoCredentials200;
  status: 200;
};

export type listProjectRepoCredentialsResponseSuccess = listProjectRepoCredentialsResponse200 & {
  headers: Headers;
};
export type listProjectRepoCredentialsResponse = listProjectRepoCredentialsResponseSuccess;

export const getListProjectRepoCredentialsUrl = (project: string) => {
  return `/v1beta1/projects/${project}/repo-credentials`;
};

export const listProjectRepoCredentials = async (
  project: string,
  options?: RequestInit
): Promise<listProjectRepoCredentialsResponse> => {
  return customFetch<listProjectRepoCredentialsResponse>(
    getListProjectRepoCredentialsUrl(project),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getListProjectRepoCredentialsQueryKey = (project?: string) => {
  return [`/v1beta1/projects/${project}/repo-credentials`] as const;
};

export const getListProjectRepoCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListProjectRepoCredentialsQueryKey(project);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProjectRepoCredentials>>> = () =>
    listProjectRepoCredentials(project, requestOptions);

  return { queryKey, queryFn, enabled: !!project, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProjectRepoCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListProjectRepoCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listProjectRepoCredentials>>
>;
export type ListProjectRepoCredentialsQueryError = unknown;

export function useListProjectRepoCredentials<
  TData = Awaited<ReturnType<typeof listProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectRepoCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectRepoCredentials>>,
          TError,
          Awaited<ReturnType<typeof listProjectRepoCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectRepoCredentials<
  TData = Awaited<ReturnType<typeof listProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectRepoCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProjectRepoCredentials>>,
          TError,
          Awaited<ReturnType<typeof listProjectRepoCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListProjectRepoCredentials<
  TData = Awaited<ReturnType<typeof listProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List project-level repository credentials
 */

export function useListProjectRepoCredentials<
  TData = Awaited<ReturnType<typeof listProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProjectRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListProjectRepoCredentialsQueryOptions(project, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create project-level repository credentials. Returns a heavily
redacted Kubernetes Secret resource.
 * @summary Create project-level repository credentials
 */
export type createProjectRepoCredentialsResponse201 = {
  data: CreateProjectRepoCredentials201;
  status: 201;
};

export type createProjectRepoCredentialsResponseSuccess =
  createProjectRepoCredentialsResponse201 & {
    headers: Headers;
  };
export type createProjectRepoCredentialsResponse = createProjectRepoCredentialsResponseSuccess;

export const getCreateProjectRepoCredentialsUrl = (project: string) => {
  return `/v1beta1/projects/${project}/repo-credentials`;
};

export const createProjectRepoCredentials = async (
  project: string,
  createRepoCredentialsRequestBody: CreateRepoCredentialsRequestBody,
  options?: RequestInit
): Promise<createProjectRepoCredentialsResponse> => {
  return customFetch<createProjectRepoCredentialsResponse>(
    getCreateProjectRepoCredentialsUrl(project),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(createRepoCredentialsRequestBody)
    }
  );
};

export const getCreateProjectRepoCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectRepoCredentials>>,
    TError,
    { project: string; data: CreateRepoCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectRepoCredentials>>,
  TError,
  { project: string; data: CreateRepoCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['createProjectRepoCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectRepoCredentials>>,
    { project: string; data: CreateRepoCredentialsRequestBody }
  > = (props) => {
    const { project, data } = props ?? {};

    return createProjectRepoCredentials(project, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProjectRepoCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectRepoCredentials>>
>;
export type CreateProjectRepoCredentialsMutationBody = CreateRepoCredentialsRequestBody;
export type CreateProjectRepoCredentialsMutationError = unknown;

/**
 * @summary Create project-level repository credentials
 */
export const useCreateProjectRepoCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProjectRepoCredentials>>,
      TError,
      { project: string; data: CreateRepoCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProjectRepoCredentials>>,
  TError,
  { project: string; data: CreateRepoCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getCreateProjectRepoCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve project-level repository credentials by name. Returns a
heavily redacted Kubernetes Secret resource.
 * @summary Retrieve project-level repository credentials
 */
export type getProjectRepoCredentialsResponse200 = {
  data: GetProjectRepoCredentials200;
  status: 200;
};

export type getProjectRepoCredentialsResponseSuccess = getProjectRepoCredentialsResponse200 & {
  headers: Headers;
};
export type getProjectRepoCredentialsResponse = getProjectRepoCredentialsResponseSuccess;

export const getGetProjectRepoCredentialsUrl = (project: string, repoCredentials: string) => {
  return `/v1beta1/projects/${project}/repo-credentials/${repoCredentials}`;
};

export const getProjectRepoCredentials = async (
  project: string,
  repoCredentials: string,
  options?: RequestInit
): Promise<getProjectRepoCredentialsResponse> => {
  return customFetch<getProjectRepoCredentialsResponse>(
    getGetProjectRepoCredentialsUrl(project, repoCredentials),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetProjectRepoCredentialsQueryKey = (
  project?: string,
  repoCredentials?: string
) => {
  return [`/v1beta1/projects/${project}/repo-credentials/${repoCredentials}`] as const;
};

export const getGetProjectRepoCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  repoCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProjectRepoCredentialsQueryKey(project, repoCredentials);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectRepoCredentials>>> = () =>
    getProjectRepoCredentials(project, repoCredentials, requestOptions);

  return {
    queryKey,
    queryFn,
    enabled: !!(project && repoCredentials),
    ...queryOptions
  } as UseQueryOptions<Awaited<ReturnType<typeof getProjectRepoCredentials>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetProjectRepoCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectRepoCredentials>>
>;
export type GetProjectRepoCredentialsQueryError = unknown;

export function useGetProjectRepoCredentials<
  TData = Awaited<ReturnType<typeof getProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  repoCredentials: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectRepoCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectRepoCredentials>>,
          TError,
          Awaited<ReturnType<typeof getProjectRepoCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectRepoCredentials<
  TData = Awaited<ReturnType<typeof getProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  repoCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectRepoCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectRepoCredentials>>,
          TError,
          Awaited<ReturnType<typeof getProjectRepoCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProjectRepoCredentials<
  TData = Awaited<ReturnType<typeof getProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  repoCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve project-level repository credentials
 */

export function useGetProjectRepoCredentials<
  TData = Awaited<ReturnType<typeof getProjectRepoCredentials>>,
  TError = unknown
>(
  project: string,
  repoCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProjectRepoCredentialsQueryOptions(project, repoCredentials, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replace project-level repository credentials. All fields are replaced.
Returns a heavily redacted Kubernetes Secret resource.
 * @summary Replace project-level repository credentials
 */
export type updateProjectRepoCredentialsResponse200 = {
  data: UpdateProjectRepoCredentials200;
  status: 200;
};

export type updateProjectRepoCredentialsResponseSuccess =
  updateProjectRepoCredentialsResponse200 & {
    headers: Headers;
  };
export type updateProjectRepoCredentialsResponse = updateProjectRepoCredentialsResponseSuccess;

export const getUpdateProjectRepoCredentialsUrl = (project: string, repoCredentials: string) => {
  return `/v1beta1/projects/${project}/repo-credentials/${repoCredentials}`;
};

export const updateProjectRepoCredentials = async (
  project: string,
  repoCredentials: string,
  updateRepoCredentialsRequestBody: UpdateRepoCredentialsRequestBody,
  options?: RequestInit
): Promise<updateProjectRepoCredentialsResponse> => {
  return customFetch<updateProjectRepoCredentialsResponse>(
    getUpdateProjectRepoCredentialsUrl(project, repoCredentials),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(updateRepoCredentialsRequestBody)
    }
  );
};

export const getUpdateProjectRepoCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectRepoCredentials>>,
    TError,
    { project: string; repoCredentials: string; data: UpdateRepoCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProjectRepoCredentials>>,
  TError,
  { project: string; repoCredentials: string; data: UpdateRepoCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['updateProjectRepoCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProjectRepoCredentials>>,
    { project: string; repoCredentials: string; data: UpdateRepoCredentialsRequestBody }
  > = (props) => {
    const { project, repoCredentials, data } = props ?? {};

    return updateProjectRepoCredentials(project, repoCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProjectRepoCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProjectRepoCredentials>>
>;
export type UpdateProjectRepoCredentialsMutationBody = UpdateRepoCredentialsRequestBody;
export type UpdateProjectRepoCredentialsMutationError = unknown;

/**
 * @summary Replace project-level repository credentials
 */
export const useUpdateProjectRepoCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProjectRepoCredentials>>,
      TError,
      { project: string; repoCredentials: string; data: UpdateRepoCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProjectRepoCredentials>>,
  TError,
  { project: string; repoCredentials: string; data: UpdateRepoCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateProjectRepoCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete repository credentials from a project's namespace.
 * @summary Delete project-level repository credentials
 */
export type deleteProjectRepoCredentialsResponse204 = {
  data: void;
  status: 204;
};

export type deleteProjectRepoCredentialsResponseSuccess =
  deleteProjectRepoCredentialsResponse204 & {
    headers: Headers;
  };
export type deleteProjectRepoCredentialsResponse = deleteProjectRepoCredentialsResponseSuccess;

export const getDeleteProjectRepoCredentialsUrl = (project: string, repoCredentials: string) => {
  return `/v1beta1/projects/${project}/repo-credentials/${repoCredentials}`;
};

export const deleteProjectRepoCredentials = async (
  project: string,
  repoCredentials: string,
  options?: RequestInit
): Promise<deleteProjectRepoCredentialsResponse> => {
  return customFetch<deleteProjectRepoCredentialsResponse>(
    getDeleteProjectRepoCredentialsUrl(project, repoCredentials),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteProjectRepoCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectRepoCredentials>>,
    TError,
    { project: string; repoCredentials: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectRepoCredentials>>,
  TError,
  { project: string; repoCredentials: string },
  TContext
> => {
  const mutationKey = ['deleteProjectRepoCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectRepoCredentials>>,
    { project: string; repoCredentials: string }
  > = (props) => {
    const { project, repoCredentials } = props ?? {};

    return deleteProjectRepoCredentials(project, repoCredentials, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectRepoCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectRepoCredentials>>
>;

export type DeleteProjectRepoCredentialsMutationError = unknown;

/**
 * @summary Delete project-level repository credentials
 */
export const useDeleteProjectRepoCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProjectRepoCredentials>>,
      TError,
      { project: string; repoCredentials: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectRepoCredentials>>,
  TError,
  { project: string; repoCredentials: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectRepoCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch project-level repository credentials. Only provided fields
are updated. Returns a heavily redacted Kubernetes Secret resource.
 * @summary Patch project-level repository credentials
 */
export type patchProjectRepoCredentialsResponse200 = {
  data: PatchProjectRepoCredentials200;
  status: 200;
};

export type patchProjectRepoCredentialsResponseSuccess = patchProjectRepoCredentialsResponse200 & {
  headers: Headers;
};
export type patchProjectRepoCredentialsResponse = patchProjectRepoCredentialsResponseSuccess;

export const getPatchProjectRepoCredentialsUrl = (project: string, repoCredentials: string) => {
  return `/v1beta1/projects/${project}/repo-credentials/${repoCredentials}`;
};

export const patchProjectRepoCredentials = async (
  project: string,
  repoCredentials: string,
  patchRepoCredentialsRequestBody: PatchRepoCredentialsRequestBody,
  options?: RequestInit
): Promise<patchProjectRepoCredentialsResponse> => {
  return customFetch<patchProjectRepoCredentialsResponse>(
    getPatchProjectRepoCredentialsUrl(project, repoCredentials),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchRepoCredentialsRequestBody)
    }
  );
};

export const getPatchProjectRepoCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchProjectRepoCredentials>>,
    TError,
    { project: string; repoCredentials: string; data: PatchRepoCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchProjectRepoCredentials>>,
  TError,
  { project: string; repoCredentials: string; data: PatchRepoCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['patchProjectRepoCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchProjectRepoCredentials>>,
    { project: string; repoCredentials: string; data: PatchRepoCredentialsRequestBody }
  > = (props) => {
    const { project, repoCredentials, data } = props ?? {};

    return patchProjectRepoCredentials(project, repoCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchProjectRepoCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchProjectRepoCredentials>>
>;
export type PatchProjectRepoCredentialsMutationBody = PatchRepoCredentialsRequestBody;
export type PatchProjectRepoCredentialsMutationError = unknown;

/**
 * @summary Patch project-level repository credentials
 */
export const usePatchProjectRepoCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchProjectRepoCredentials>>,
      TError,
      { project: string; repoCredentials: string; data: PatchRepoCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchProjectRepoCredentials>>,
  TError,
  { project: string; repoCredentials: string; data: PatchRepoCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getPatchProjectRepoCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List shared generic credentials. Returns a Kubernetes SecretList
resource containing heavily redacted Secrets.
 * @summary List shared generic credentials
 */
export type listSharedGenericCredentialsResponse200 = {
  data: ListSharedGenericCredentials200;
  status: 200;
};

export type listSharedGenericCredentialsResponseSuccess =
  listSharedGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type listSharedGenericCredentialsResponse = listSharedGenericCredentialsResponseSuccess;

export const getListSharedGenericCredentialsUrl = () => {
  return `/v1beta1/shared/generic-credentials`;
};

export const listSharedGenericCredentials = async (
  options?: RequestInit
): Promise<listSharedGenericCredentialsResponse> => {
  return customFetch<listSharedGenericCredentialsResponse>(getListSharedGenericCredentialsUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListSharedGenericCredentialsQueryKey = () => {
  return [`/v1beta1/shared/generic-credentials`] as const;
};

export const getListSharedGenericCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof listSharedGenericCredentials>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listSharedGenericCredentials>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListSharedGenericCredentialsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSharedGenericCredentials>>> = () =>
    listSharedGenericCredentials(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSharedGenericCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSharedGenericCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSharedGenericCredentials>>
>;
export type ListSharedGenericCredentialsQueryError = unknown;

export function useListSharedGenericCredentials<
  TData = Awaited<ReturnType<typeof listSharedGenericCredentials>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedGenericCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSharedGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof listSharedGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSharedGenericCredentials<
  TData = Awaited<ReturnType<typeof listSharedGenericCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedGenericCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSharedGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof listSharedGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSharedGenericCredentials<
  TData = Awaited<ReturnType<typeof listSharedGenericCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List shared generic credentials
 */

export function useListSharedGenericCredentials<
  TData = Awaited<ReturnType<typeof listSharedGenericCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListSharedGenericCredentialsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create shared generic credentials referenceable by all
projects. Returns a heavily redacted Kubernetes Secret resource.
 * @summary Create shared generic credentials
 */
export type createSharedGenericCredentialsResponse201 = {
  data: CreateSharedGenericCredentials201;
  status: 201;
};

export type createSharedGenericCredentialsResponseSuccess =
  createSharedGenericCredentialsResponse201 & {
    headers: Headers;
  };
export type createSharedGenericCredentialsResponse = createSharedGenericCredentialsResponseSuccess;

export const getCreateSharedGenericCredentialsUrl = () => {
  return `/v1beta1/shared/generic-credentials`;
};

export const createSharedGenericCredentials = async (
  createGenericCredentialsRequestBody: CreateGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<createSharedGenericCredentialsResponse> => {
  return customFetch<createSharedGenericCredentialsResponse>(
    getCreateSharedGenericCredentialsUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(createGenericCredentialsRequestBody)
    }
  );
};

export const getCreateSharedGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSharedGenericCredentials>>,
    TError,
    { data: CreateGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSharedGenericCredentials>>,
  TError,
  { data: CreateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['createSharedGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSharedGenericCredentials>>,
    { data: CreateGenericCredentialsRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return createSharedGenericCredentials(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSharedGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSharedGenericCredentials>>
>;
export type CreateSharedGenericCredentialsMutationBody = CreateGenericCredentialsRequestBody;
export type CreateSharedGenericCredentialsMutationError = unknown;

/**
 * @summary Create shared generic credentials
 */
export const useCreateSharedGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSharedGenericCredentials>>,
      TError,
      { data: CreateGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createSharedGenericCredentials>>,
  TError,
  { data: CreateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getCreateSharedGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve shared generic credentials by name. Returns a
heavily redacted Kubernetes Secret resource.
 * @summary Retrieve shared generic credentials
 */
export type getSharedGenericCredentialsResponse200 = {
  data: GetSharedGenericCredentials200;
  status: 200;
};

export type getSharedGenericCredentialsResponseSuccess = getSharedGenericCredentialsResponse200 & {
  headers: Headers;
};
export type getSharedGenericCredentialsResponse = getSharedGenericCredentialsResponseSuccess;

export const getGetSharedGenericCredentialsUrl = (genericCredentials: string) => {
  return `/v1beta1/shared/generic-credentials/${genericCredentials}`;
};

export const getSharedGenericCredentials = async (
  genericCredentials: string,
  options?: RequestInit
): Promise<getSharedGenericCredentialsResponse> => {
  return customFetch<getSharedGenericCredentialsResponse>(
    getGetSharedGenericCredentialsUrl(genericCredentials),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetSharedGenericCredentialsQueryKey = (genericCredentials?: string) => {
  return [`/v1beta1/shared/generic-credentials/${genericCredentials}`] as const;
};

export const getGetSharedGenericCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSharedGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSharedGenericCredentialsQueryKey(genericCredentials);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSharedGenericCredentials>>> = () =>
    getSharedGenericCredentials(genericCredentials, requestOptions);

  return { queryKey, queryFn, enabled: !!genericCredentials, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSharedGenericCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSharedGenericCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSharedGenericCredentials>>
>;
export type GetSharedGenericCredentialsQueryError = unknown;

export function useGetSharedGenericCredentials<
  TData = Awaited<ReturnType<typeof getSharedGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedGenericCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSharedGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof getSharedGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSharedGenericCredentials<
  TData = Awaited<ReturnType<typeof getSharedGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedGenericCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSharedGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof getSharedGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSharedGenericCredentials<
  TData = Awaited<ReturnType<typeof getSharedGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve shared generic credentials
 */

export function useGetSharedGenericCredentials<
  TData = Awaited<ReturnType<typeof getSharedGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSharedGenericCredentialsQueryOptions(genericCredentials, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replace shared generic credentials. All existing data is replaced.
Returns a heavily redacted Kubernetes Secret resource.
 * @summary Replace shared generic credentials
 */
export type updateSharedGenericCredentialsResponse200 = {
  data: UpdateSharedGenericCredentials200;
  status: 200;
};

export type updateSharedGenericCredentialsResponseSuccess =
  updateSharedGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type updateSharedGenericCredentialsResponse = updateSharedGenericCredentialsResponseSuccess;

export const getUpdateSharedGenericCredentialsUrl = (genericCredentials: string) => {
  return `/v1beta1/shared/generic-credentials/${genericCredentials}`;
};

export const updateSharedGenericCredentials = async (
  genericCredentials: string,
  updateGenericCredentialsRequestBody: UpdateGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<updateSharedGenericCredentialsResponse> => {
  return customFetch<updateSharedGenericCredentialsResponse>(
    getUpdateSharedGenericCredentialsUrl(genericCredentials),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(updateGenericCredentialsRequestBody)
    }
  );
};

export const getUpdateSharedGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSharedGenericCredentials>>,
    TError,
    { genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSharedGenericCredentials>>,
  TError,
  { genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['updateSharedGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSharedGenericCredentials>>,
    { genericCredentials: string; data: UpdateGenericCredentialsRequestBody }
  > = (props) => {
    const { genericCredentials, data } = props ?? {};

    return updateSharedGenericCredentials(genericCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSharedGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSharedGenericCredentials>>
>;
export type UpdateSharedGenericCredentialsMutationBody = UpdateGenericCredentialsRequestBody;
export type UpdateSharedGenericCredentialsMutationError = unknown;

/**
 * @summary Replace shared generic credentials
 */
export const useUpdateSharedGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSharedGenericCredentials>>,
      TError,
      { genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSharedGenericCredentials>>,
  TError,
  { genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateSharedGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete shared generic credentials.
 * @summary Delete shared generic credentials
 */
export type deleteSharedGenericCredentialsResponse204 = {
  data: void;
  status: 204;
};

export type deleteSharedGenericCredentialsResponseSuccess =
  deleteSharedGenericCredentialsResponse204 & {
    headers: Headers;
  };
export type deleteSharedGenericCredentialsResponse = deleteSharedGenericCredentialsResponseSuccess;

export const getDeleteSharedGenericCredentialsUrl = (genericCredentials: string) => {
  return `/v1beta1/shared/generic-credentials/${genericCredentials}`;
};

export const deleteSharedGenericCredentials = async (
  genericCredentials: string,
  options?: RequestInit
): Promise<deleteSharedGenericCredentialsResponse> => {
  return customFetch<deleteSharedGenericCredentialsResponse>(
    getDeleteSharedGenericCredentialsUrl(genericCredentials),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteSharedGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSharedGenericCredentials>>,
    TError,
    { genericCredentials: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSharedGenericCredentials>>,
  TError,
  { genericCredentials: string },
  TContext
> => {
  const mutationKey = ['deleteSharedGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSharedGenericCredentials>>,
    { genericCredentials: string }
  > = (props) => {
    const { genericCredentials } = props ?? {};

    return deleteSharedGenericCredentials(genericCredentials, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSharedGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSharedGenericCredentials>>
>;

export type DeleteSharedGenericCredentialsMutationError = unknown;

/**
 * @summary Delete shared generic credentials
 */
export const useDeleteSharedGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSharedGenericCredentials>>,
      TError,
      { genericCredentials: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSharedGenericCredentials>>,
  TError,
  { genericCredentials: string },
  TContext
> => {
  const mutationOptions = getDeleteSharedGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch shared generic credentials. Merges provided data
with existing data. Use removeKeys to delete specific keys.
Returns a heavily redacted Kubernetes Secret resource.
 * @summary Patch shared generic credentials
 */
export type patchSharedGenericCredentialsResponse200 = {
  data: PatchSharedGenericCredentials200;
  status: 200;
};

export type patchSharedGenericCredentialsResponseSuccess =
  patchSharedGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type patchSharedGenericCredentialsResponse = patchSharedGenericCredentialsResponseSuccess;

export const getPatchSharedGenericCredentialsUrl = (genericCredentials: string) => {
  return `/v1beta1/shared/generic-credentials/${genericCredentials}`;
};

export const patchSharedGenericCredentials = async (
  genericCredentials: string,
  patchGenericCredentialsRequestBody: PatchGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<patchSharedGenericCredentialsResponse> => {
  return customFetch<patchSharedGenericCredentialsResponse>(
    getPatchSharedGenericCredentialsUrl(genericCredentials),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchGenericCredentialsRequestBody)
    }
  );
};

export const getPatchSharedGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchSharedGenericCredentials>>,
    TError,
    { genericCredentials: string; data: PatchGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchSharedGenericCredentials>>,
  TError,
  { genericCredentials: string; data: PatchGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['patchSharedGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchSharedGenericCredentials>>,
    { genericCredentials: string; data: PatchGenericCredentialsRequestBody }
  > = (props) => {
    const { genericCredentials, data } = props ?? {};

    return patchSharedGenericCredentials(genericCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchSharedGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchSharedGenericCredentials>>
>;
export type PatchSharedGenericCredentialsMutationBody = PatchGenericCredentialsRequestBody;
export type PatchSharedGenericCredentialsMutationError = unknown;

/**
 * @summary Patch shared generic credentials
 */
export const usePatchSharedGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchSharedGenericCredentials>>,
      TError,
      { genericCredentials: string; data: PatchGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchSharedGenericCredentials>>,
  TError,
  { genericCredentials: string; data: PatchGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getPatchSharedGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List shared repository credentials. Returns a SecretList
resource containing heavily redacted Secrets.
 * @summary List shared repository credentials
 */
export type listSharedRepoCredentialsResponse200 = {
  data: ListSharedRepoCredentials200;
  status: 200;
};

export type listSharedRepoCredentialsResponseSuccess = listSharedRepoCredentialsResponse200 & {
  headers: Headers;
};
export type listSharedRepoCredentialsResponse = listSharedRepoCredentialsResponseSuccess;

export const getListSharedRepoCredentialsUrl = () => {
  return `/v1beta1/shared/repo-credentials`;
};

export const listSharedRepoCredentials = async (
  options?: RequestInit
): Promise<listSharedRepoCredentialsResponse> => {
  return customFetch<listSharedRepoCredentialsResponse>(getListSharedRepoCredentialsUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListSharedRepoCredentialsQueryKey = () => {
  return [`/v1beta1/shared/repo-credentials`] as const;
};

export const getListSharedRepoCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof listSharedRepoCredentials>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listSharedRepoCredentials>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListSharedRepoCredentialsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSharedRepoCredentials>>> = () =>
    listSharedRepoCredentials(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSharedRepoCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSharedRepoCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSharedRepoCredentials>>
>;
export type ListSharedRepoCredentialsQueryError = unknown;

export function useListSharedRepoCredentials<
  TData = Awaited<ReturnType<typeof listSharedRepoCredentials>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedRepoCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSharedRepoCredentials>>,
          TError,
          Awaited<ReturnType<typeof listSharedRepoCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSharedRepoCredentials<
  TData = Awaited<ReturnType<typeof listSharedRepoCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedRepoCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSharedRepoCredentials>>,
          TError,
          Awaited<ReturnType<typeof listSharedRepoCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSharedRepoCredentials<
  TData = Awaited<ReturnType<typeof listSharedRepoCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List shared repository credentials
 */

export function useListSharedRepoCredentials<
  TData = Awaited<ReturnType<typeof listSharedRepoCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSharedRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListSharedRepoCredentialsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create shared repository credentials. Returns a heavily
redacted Kubernetes Secret resource.
 * @summary Create shared repository credentials
 */
export type createSharedRepoCredentialsResponse201 = {
  data: CreateSharedRepoCredentials201;
  status: 201;
};

export type createSharedRepoCredentialsResponseSuccess = createSharedRepoCredentialsResponse201 & {
  headers: Headers;
};
export type createSharedRepoCredentialsResponse = createSharedRepoCredentialsResponseSuccess;

export const getCreateSharedRepoCredentialsUrl = () => {
  return `/v1beta1/shared/repo-credentials`;
};

export const createSharedRepoCredentials = async (
  createRepoCredentialsRequestBody: CreateRepoCredentialsRequestBody,
  options?: RequestInit
): Promise<createSharedRepoCredentialsResponse> => {
  return customFetch<createSharedRepoCredentialsResponse>(getCreateSharedRepoCredentialsUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createRepoCredentialsRequestBody)
  });
};

export const getCreateSharedRepoCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSharedRepoCredentials>>,
    TError,
    { data: CreateRepoCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSharedRepoCredentials>>,
  TError,
  { data: CreateRepoCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['createSharedRepoCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSharedRepoCredentials>>,
    { data: CreateRepoCredentialsRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return createSharedRepoCredentials(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSharedRepoCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSharedRepoCredentials>>
>;
export type CreateSharedRepoCredentialsMutationBody = CreateRepoCredentialsRequestBody;
export type CreateSharedRepoCredentialsMutationError = unknown;

/**
 * @summary Create shared repository credentials
 */
export const useCreateSharedRepoCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSharedRepoCredentials>>,
      TError,
      { data: CreateRepoCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createSharedRepoCredentials>>,
  TError,
  { data: CreateRepoCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getCreateSharedRepoCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve shared repository credentials by name. Returns a
heavily redacted Kubernetes Secret resource.
 * @summary Retrieve shared repository credentials
 */
export type getSharedRepoCredentialsResponse200 = {
  data: GetSharedRepoCredentials200;
  status: 200;
};

export type getSharedRepoCredentialsResponseSuccess = getSharedRepoCredentialsResponse200 & {
  headers: Headers;
};
export type getSharedRepoCredentialsResponse = getSharedRepoCredentialsResponseSuccess;

export const getGetSharedRepoCredentialsUrl = (repoCredentials: string) => {
  return `/v1beta1/shared/repo-credentials/${repoCredentials}`;
};

export const getSharedRepoCredentials = async (
  repoCredentials: string,
  options?: RequestInit
): Promise<getSharedRepoCredentialsResponse> => {
  return customFetch<getSharedRepoCredentialsResponse>(
    getGetSharedRepoCredentialsUrl(repoCredentials),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetSharedRepoCredentialsQueryKey = (repoCredentials?: string) => {
  return [`/v1beta1/shared/repo-credentials/${repoCredentials}`] as const;
};

export const getGetSharedRepoCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSharedRepoCredentials>>,
  TError = unknown
>(
  repoCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSharedRepoCredentialsQueryKey(repoCredentials);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSharedRepoCredentials>>> = () =>
    getSharedRepoCredentials(repoCredentials, requestOptions);

  return { queryKey, queryFn, enabled: !!repoCredentials, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSharedRepoCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSharedRepoCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSharedRepoCredentials>>
>;
export type GetSharedRepoCredentialsQueryError = unknown;

export function useGetSharedRepoCredentials<
  TData = Awaited<ReturnType<typeof getSharedRepoCredentials>>,
  TError = unknown
>(
  repoCredentials: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedRepoCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSharedRepoCredentials>>,
          TError,
          Awaited<ReturnType<typeof getSharedRepoCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSharedRepoCredentials<
  TData = Awaited<ReturnType<typeof getSharedRepoCredentials>>,
  TError = unknown
>(
  repoCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedRepoCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSharedRepoCredentials>>,
          TError,
          Awaited<ReturnType<typeof getSharedRepoCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSharedRepoCredentials<
  TData = Awaited<ReturnType<typeof getSharedRepoCredentials>>,
  TError = unknown
>(
  repoCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve shared repository credentials
 */

export function useGetSharedRepoCredentials<
  TData = Awaited<ReturnType<typeof getSharedRepoCredentials>>,
  TError = unknown
>(
  repoCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSharedRepoCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSharedRepoCredentialsQueryOptions(repoCredentials, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replace shared repository credentials. All fields are replaced.
Returns a heavily redacted Kubernetes Secret resource.
 * @summary Replace shared repository credentials
 */
export type updateSharedRepoCredentialsResponse200 = {
  data: UpdateSharedRepoCredentials200;
  status: 200;
};

export type updateSharedRepoCredentialsResponseSuccess = updateSharedRepoCredentialsResponse200 & {
  headers: Headers;
};
export type updateSharedRepoCredentialsResponse = updateSharedRepoCredentialsResponseSuccess;

export const getUpdateSharedRepoCredentialsUrl = (repoCredentials: string) => {
  return `/v1beta1/shared/repo-credentials/${repoCredentials}`;
};

export const updateSharedRepoCredentials = async (
  repoCredentials: string,
  updateRepoCredentialsRequestBody: UpdateRepoCredentialsRequestBody,
  options?: RequestInit
): Promise<updateSharedRepoCredentialsResponse> => {
  return customFetch<updateSharedRepoCredentialsResponse>(
    getUpdateSharedRepoCredentialsUrl(repoCredentials),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(updateRepoCredentialsRequestBody)
    }
  );
};

export const getUpdateSharedRepoCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSharedRepoCredentials>>,
    TError,
    { repoCredentials: string; data: UpdateRepoCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSharedRepoCredentials>>,
  TError,
  { repoCredentials: string; data: UpdateRepoCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['updateSharedRepoCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSharedRepoCredentials>>,
    { repoCredentials: string; data: UpdateRepoCredentialsRequestBody }
  > = (props) => {
    const { repoCredentials, data } = props ?? {};

    return updateSharedRepoCredentials(repoCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSharedRepoCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSharedRepoCredentials>>
>;
export type UpdateSharedRepoCredentialsMutationBody = UpdateRepoCredentialsRequestBody;
export type UpdateSharedRepoCredentialsMutationError = unknown;

/**
 * @summary Replace shared repository credentials
 */
export const useUpdateSharedRepoCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSharedRepoCredentials>>,
      TError,
      { repoCredentials: string; data: UpdateRepoCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSharedRepoCredentials>>,
  TError,
  { repoCredentials: string; data: UpdateRepoCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateSharedRepoCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete shared repository credentials.
 * @summary Delete shared repository credentials
 */
export type deleteSharedRepoCredentialsResponse204 = {
  data: void;
  status: 204;
};

export type deleteSharedRepoCredentialsResponseSuccess = deleteSharedRepoCredentialsResponse204 & {
  headers: Headers;
};
export type deleteSharedRepoCredentialsResponse = deleteSharedRepoCredentialsResponseSuccess;

export const getDeleteSharedRepoCredentialsUrl = (repoCredentials: string) => {
  return `/v1beta1/shared/repo-credentials/${repoCredentials}`;
};

export const deleteSharedRepoCredentials = async (
  repoCredentials: string,
  options?: RequestInit
): Promise<deleteSharedRepoCredentialsResponse> => {
  return customFetch<deleteSharedRepoCredentialsResponse>(
    getDeleteSharedRepoCredentialsUrl(repoCredentials),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteSharedRepoCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSharedRepoCredentials>>,
    TError,
    { repoCredentials: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSharedRepoCredentials>>,
  TError,
  { repoCredentials: string },
  TContext
> => {
  const mutationKey = ['deleteSharedRepoCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSharedRepoCredentials>>,
    { repoCredentials: string }
  > = (props) => {
    const { repoCredentials } = props ?? {};

    return deleteSharedRepoCredentials(repoCredentials, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSharedRepoCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSharedRepoCredentials>>
>;

export type DeleteSharedRepoCredentialsMutationError = unknown;

/**
 * @summary Delete shared repository credentials
 */
export const useDeleteSharedRepoCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSharedRepoCredentials>>,
      TError,
      { repoCredentials: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSharedRepoCredentials>>,
  TError,
  { repoCredentials: string },
  TContext
> => {
  const mutationOptions = getDeleteSharedRepoCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch shared repository credentials. Only provided fields
are updated. Returns a heavily redacted Kubernetes Secret resource.
 * @summary Patch shared repository credentials
 */
export type patchSharedRepoCredentialsResponse200 = {
  data: PatchSharedRepoCredentials200;
  status: 200;
};

export type patchSharedRepoCredentialsResponseSuccess = patchSharedRepoCredentialsResponse200 & {
  headers: Headers;
};
export type patchSharedRepoCredentialsResponse = patchSharedRepoCredentialsResponseSuccess;

export const getPatchSharedRepoCredentialsUrl = (repoCredentials: string) => {
  return `/v1beta1/shared/repo-credentials/${repoCredentials}`;
};

export const patchSharedRepoCredentials = async (
  repoCredentials: string,
  patchRepoCredentialsRequestBody: PatchRepoCredentialsRequestBody,
  options?: RequestInit
): Promise<patchSharedRepoCredentialsResponse> => {
  return customFetch<patchSharedRepoCredentialsResponse>(
    getPatchSharedRepoCredentialsUrl(repoCredentials),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchRepoCredentialsRequestBody)
    }
  );
};

export const getPatchSharedRepoCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchSharedRepoCredentials>>,
    TError,
    { repoCredentials: string; data: PatchRepoCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchSharedRepoCredentials>>,
  TError,
  { repoCredentials: string; data: PatchRepoCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['patchSharedRepoCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchSharedRepoCredentials>>,
    { repoCredentials: string; data: PatchRepoCredentialsRequestBody }
  > = (props) => {
    const { repoCredentials, data } = props ?? {};

    return patchSharedRepoCredentials(repoCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchSharedRepoCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchSharedRepoCredentials>>
>;
export type PatchSharedRepoCredentialsMutationBody = PatchRepoCredentialsRequestBody;
export type PatchSharedRepoCredentialsMutationError = unknown;

/**
 * @summary Patch shared repository credentials
 */
export const usePatchSharedRepoCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchSharedRepoCredentials>>,
      TError,
      { repoCredentials: string; data: PatchRepoCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchSharedRepoCredentials>>,
  TError,
  { repoCredentials: string; data: PatchRepoCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getPatchSharedRepoCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List system-level generic credentials. Returns a Kubernetes
SecretList resource containing heavily redacted Secrets.
 * @summary List system-level generic credentials
 */
export type listSystemGenericCredentialsResponse200 = {
  data: ListSystemGenericCredentials200;
  status: 200;
};

export type listSystemGenericCredentialsResponseSuccess =
  listSystemGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type listSystemGenericCredentialsResponse = listSystemGenericCredentialsResponseSuccess;

export const getListSystemGenericCredentialsUrl = () => {
  return `/v1beta1/system/generic-credentials`;
};

export const listSystemGenericCredentials = async (
  options?: RequestInit
): Promise<listSystemGenericCredentialsResponse> => {
  return customFetch<listSystemGenericCredentialsResponse>(getListSystemGenericCredentialsUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getListSystemGenericCredentialsQueryKey = () => {
  return [`/v1beta1/system/generic-credentials`] as const;
};

export const getListSystemGenericCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof listSystemGenericCredentials>>,
  TError = unknown
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listSystemGenericCredentials>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListSystemGenericCredentialsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSystemGenericCredentials>>> = () =>
    listSystemGenericCredentials(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSystemGenericCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSystemGenericCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSystemGenericCredentials>>
>;
export type ListSystemGenericCredentialsQueryError = unknown;

export function useListSystemGenericCredentials<
  TData = Awaited<ReturnType<typeof listSystemGenericCredentials>>,
  TError = unknown
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemGenericCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSystemGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof listSystemGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSystemGenericCredentials<
  TData = Awaited<ReturnType<typeof listSystemGenericCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemGenericCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSystemGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof listSystemGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListSystemGenericCredentials<
  TData = Awaited<ReturnType<typeof listSystemGenericCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List system-level generic credentials
 */

export function useListSystemGenericCredentials<
  TData = Awaited<ReturnType<typeof listSystemGenericCredentials>>,
  TError = unknown
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSystemGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListSystemGenericCredentialsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create system-level generic credentials. Returns a heavily
redacted Kubernetes Secret resource.
 * @summary Create system-level generic credentials
 */
export type createSystemGenericCredentialsResponse201 = {
  data: CreateSystemGenericCredentials201;
  status: 201;
};

export type createSystemGenericCredentialsResponseSuccess =
  createSystemGenericCredentialsResponse201 & {
    headers: Headers;
  };
export type createSystemGenericCredentialsResponse = createSystemGenericCredentialsResponseSuccess;

export const getCreateSystemGenericCredentialsUrl = () => {
  return `/v1beta1/system/generic-credentials`;
};

export const createSystemGenericCredentials = async (
  createGenericCredentialsRequestBody: CreateGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<createSystemGenericCredentialsResponse> => {
  return customFetch<createSystemGenericCredentialsResponse>(
    getCreateSystemGenericCredentialsUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(createGenericCredentialsRequestBody)
    }
  );
};

export const getCreateSystemGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSystemGenericCredentials>>,
    TError,
    { data: CreateGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSystemGenericCredentials>>,
  TError,
  { data: CreateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['createSystemGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSystemGenericCredentials>>,
    { data: CreateGenericCredentialsRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return createSystemGenericCredentials(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSystemGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSystemGenericCredentials>>
>;
export type CreateSystemGenericCredentialsMutationBody = CreateGenericCredentialsRequestBody;
export type CreateSystemGenericCredentialsMutationError = unknown;

/**
 * @summary Create system-level generic credentials
 */
export const useCreateSystemGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSystemGenericCredentials>>,
      TError,
      { data: CreateGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createSystemGenericCredentials>>,
  TError,
  { data: CreateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getCreateSystemGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve system-level generic credentials by name. Returns a
heavily redacted Kubernetes Secret resource.
 * @summary Retrieve system-level generic credentials
 */
export type getSystemGenericCredentialsResponse200 = {
  data: GetSystemGenericCredentials200;
  status: 200;
};

export type getSystemGenericCredentialsResponseSuccess = getSystemGenericCredentialsResponse200 & {
  headers: Headers;
};
export type getSystemGenericCredentialsResponse = getSystemGenericCredentialsResponseSuccess;

export const getGetSystemGenericCredentialsUrl = (genericCredentials: string) => {
  return `/v1beta1/system/generic-credentials/${genericCredentials}`;
};

export const getSystemGenericCredentials = async (
  genericCredentials: string,
  options?: RequestInit
): Promise<getSystemGenericCredentialsResponse> => {
  return customFetch<getSystemGenericCredentialsResponse>(
    getGetSystemGenericCredentialsUrl(genericCredentials),
    {
      ...options,
      method: 'GET'
    }
  );
};

export const getGetSystemGenericCredentialsQueryKey = (genericCredentials?: string) => {
  return [`/v1beta1/system/generic-credentials/${genericCredentials}`] as const;
};

export const getGetSystemGenericCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSystemGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSystemGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSystemGenericCredentialsQueryKey(genericCredentials);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemGenericCredentials>>> = () =>
    getSystemGenericCredentials(genericCredentials, requestOptions);

  return { queryKey, queryFn, enabled: !!genericCredentials, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSystemGenericCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSystemGenericCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSystemGenericCredentials>>
>;
export type GetSystemGenericCredentialsQueryError = unknown;

export function useGetSystemGenericCredentials<
  TData = Awaited<ReturnType<typeof getSystemGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSystemGenericCredentials>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof getSystemGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSystemGenericCredentials<
  TData = Awaited<ReturnType<typeof getSystemGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSystemGenericCredentials>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSystemGenericCredentials>>,
          TError,
          Awaited<ReturnType<typeof getSystemGenericCredentials>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSystemGenericCredentials<
  TData = Awaited<ReturnType<typeof getSystemGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSystemGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve system-level generic credentials
 */

export function useGetSystemGenericCredentials<
  TData = Awaited<ReturnType<typeof getSystemGenericCredentials>>,
  TError = unknown
>(
  genericCredentials: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSystemGenericCredentials>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSystemGenericCredentialsQueryOptions(genericCredentials, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replace system-level generic credentials. All existing data is
replaced. Returns a heavily redacted Kubernetes Secret resource.
 * @summary Replace system-level generic credentials
 */
export type updateSystemGenericCredentialsResponse200 = {
  data: UpdateSystemGenericCredentials200;
  status: 200;
};

export type updateSystemGenericCredentialsResponseSuccess =
  updateSystemGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type updateSystemGenericCredentialsResponse = updateSystemGenericCredentialsResponseSuccess;

export const getUpdateSystemGenericCredentialsUrl = (genericCredentials: string) => {
  return `/v1beta1/system/generic-credentials/${genericCredentials}`;
};

export const updateSystemGenericCredentials = async (
  genericCredentials: string,
  updateGenericCredentialsRequestBody: UpdateGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<updateSystemGenericCredentialsResponse> => {
  return customFetch<updateSystemGenericCredentialsResponse>(
    getUpdateSystemGenericCredentialsUrl(genericCredentials),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(updateGenericCredentialsRequestBody)
    }
  );
};

export const getUpdateSystemGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSystemGenericCredentials>>,
    TError,
    { genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSystemGenericCredentials>>,
  TError,
  { genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['updateSystemGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSystemGenericCredentials>>,
    { genericCredentials: string; data: UpdateGenericCredentialsRequestBody }
  > = (props) => {
    const { genericCredentials, data } = props ?? {};

    return updateSystemGenericCredentials(genericCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSystemGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSystemGenericCredentials>>
>;
export type UpdateSystemGenericCredentialsMutationBody = UpdateGenericCredentialsRequestBody;
export type UpdateSystemGenericCredentialsMutationError = unknown;

/**
 * @summary Replace system-level generic credentials
 */
export const useUpdateSystemGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSystemGenericCredentials>>,
      TError,
      { genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSystemGenericCredentials>>,
  TError,
  { genericCredentials: string; data: UpdateGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getUpdateSystemGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete system-level generic credentials.
 * @summary Delete system-level generic credentials
 */
export type deleteSystemGenericCredentialsResponse204 = {
  data: void;
  status: 204;
};

export type deleteSystemGenericCredentialsResponseSuccess =
  deleteSystemGenericCredentialsResponse204 & {
    headers: Headers;
  };
export type deleteSystemGenericCredentialsResponse = deleteSystemGenericCredentialsResponseSuccess;

export const getDeleteSystemGenericCredentialsUrl = (genericCredentials: string) => {
  return `/v1beta1/system/generic-credentials/${genericCredentials}`;
};

export const deleteSystemGenericCredentials = async (
  genericCredentials: string,
  options?: RequestInit
): Promise<deleteSystemGenericCredentialsResponse> => {
  return customFetch<deleteSystemGenericCredentialsResponse>(
    getDeleteSystemGenericCredentialsUrl(genericCredentials),
    {
      ...options,
      method: 'DELETE'
    }
  );
};

export const getDeleteSystemGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSystemGenericCredentials>>,
    TError,
    { genericCredentials: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSystemGenericCredentials>>,
  TError,
  { genericCredentials: string },
  TContext
> => {
  const mutationKey = ['deleteSystemGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSystemGenericCredentials>>,
    { genericCredentials: string }
  > = (props) => {
    const { genericCredentials } = props ?? {};

    return deleteSystemGenericCredentials(genericCredentials, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSystemGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSystemGenericCredentials>>
>;

export type DeleteSystemGenericCredentialsMutationError = unknown;

/**
 * @summary Delete system-level generic credentials
 */
export const useDeleteSystemGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSystemGenericCredentials>>,
      TError,
      { genericCredentials: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSystemGenericCredentials>>,
  TError,
  { genericCredentials: string },
  TContext
> => {
  const mutationOptions = getDeleteSystemGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Patch system-level generic credentials. Merges provided data
with existing data. Use removeKeys to delete specific keys.
Returns a heavily redacted Kubernetes Secret resource.
 * @summary Patch system-level generic credentials
 */
export type patchSystemGenericCredentialsResponse200 = {
  data: PatchSystemGenericCredentials200;
  status: 200;
};

export type patchSystemGenericCredentialsResponseSuccess =
  patchSystemGenericCredentialsResponse200 & {
    headers: Headers;
  };
export type patchSystemGenericCredentialsResponse = patchSystemGenericCredentialsResponseSuccess;

export const getPatchSystemGenericCredentialsUrl = (genericCredentials: string) => {
  return `/v1beta1/system/generic-credentials/${genericCredentials}`;
};

export const patchSystemGenericCredentials = async (
  genericCredentials: string,
  patchGenericCredentialsRequestBody: PatchGenericCredentialsRequestBody,
  options?: RequestInit
): Promise<patchSystemGenericCredentialsResponse> => {
  return customFetch<patchSystemGenericCredentialsResponse>(
    getPatchSystemGenericCredentialsUrl(genericCredentials),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(patchGenericCredentialsRequestBody)
    }
  );
};

export const getPatchSystemGenericCredentialsMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchSystemGenericCredentials>>,
    TError,
    { genericCredentials: string; data: PatchGenericCredentialsRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchSystemGenericCredentials>>,
  TError,
  { genericCredentials: string; data: PatchGenericCredentialsRequestBody },
  TContext
> => {
  const mutationKey = ['patchSystemGenericCredentials'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchSystemGenericCredentials>>,
    { genericCredentials: string; data: PatchGenericCredentialsRequestBody }
  > = (props) => {
    const { genericCredentials, data } = props ?? {};

    return patchSystemGenericCredentials(genericCredentials, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchSystemGenericCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchSystemGenericCredentials>>
>;
export type PatchSystemGenericCredentialsMutationBody = PatchGenericCredentialsRequestBody;
export type PatchSystemGenericCredentialsMutationError = unknown;

/**
 * @summary Patch system-level generic credentials
 */
export const usePatchSystemGenericCredentials = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchSystemGenericCredentials>>,
      TError,
      { genericCredentials: string; data: PatchGenericCredentialsRequestBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchSystemGenericCredentials>>,
  TError,
  { genericCredentials: string; data: PatchGenericCredentialsRequestBody },
  TContext
> => {
  const mutationOptions = getPatchSystemGenericCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
