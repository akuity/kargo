/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * Kargo API
 * REST API for Kargo
 * OpenAPI spec version: v1alpha1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdminLoginResponse,
  GetClusterConfig200,
  GetConfigResponse,
  PublicConfig,
  VersionInfo
} from '.././models';

import { customFetch } from '../../../../lib/api/custom-fetch';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Authenticate as the admin user if enabled.
 * @summary Admin login
 */
export type adminLoginResponse200 = {
  data: AdminLoginResponse;
  status: 200;
};

export type adminLoginResponseSuccess = adminLoginResponse200 & {
  headers: Headers;
};
export type adminLoginResponse = adminLoginResponseSuccess;

export const getAdminLoginUrl = () => {
  return `/v1beta1/login`;
};

export const adminLogin = async (options?: RequestInit): Promise<adminLoginResponse> => {
  return customFetch<adminLoginResponse>(getAdminLoginUrl(), {
    ...options,
    method: 'POST'
  });
};

export const getAdminLoginMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError, void, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError, void, TContext> => {
  const mutationKey = ['adminLogin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminLogin>>, void> = () => {
    return adminLogin(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminLoginMutationResult = NonNullable<Awaited<ReturnType<typeof adminLogin>>>;

export type AdminLoginMutationError = unknown;

/**
 * @summary Admin login
 */
export const useAdminLogin = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof adminLogin>>, TError, void, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof adminLogin>>, TError, void, TContext> => {
  const mutationOptions = getAdminLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve the single ClusterConfig resource.
 * @summary Retrieve the ClusterConfig
 */
export type getClusterConfigResponse200 = {
  data: GetClusterConfig200;
  status: 200;
};

export type getClusterConfigResponseSuccess = getClusterConfigResponse200 & {
  headers: Headers;
};
export type getClusterConfigResponse = getClusterConfigResponseSuccess;

export const getGetClusterConfigUrl = () => {
  return `/v1beta1/system/cluster-config`;
};

export const getClusterConfig = async (
  options?: RequestInit
): Promise<getClusterConfigResponse> => {
  return customFetch<getClusterConfigResponse>(getGetClusterConfigUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetClusterConfigQueryKey = () => {
  return [`/v1beta1/system/cluster-config`] as const;
};

export const getGetClusterConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getClusterConfig>>,
  TError = unknown
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getClusterConfig>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetClusterConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClusterConfig>>> = () =>
    getClusterConfig(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getClusterConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetClusterConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getClusterConfig>>>;
export type GetClusterConfigQueryError = unknown;

export function useGetClusterConfig<
  TData = Awaited<ReturnType<typeof getClusterConfig>>,
  TError = unknown
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getClusterConfig>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClusterConfig>>,
          TError,
          Awaited<ReturnType<typeof getClusterConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetClusterConfig<
  TData = Awaited<ReturnType<typeof getClusterConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getClusterConfig>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClusterConfig>>,
          TError,
          Awaited<ReturnType<typeof getClusterConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetClusterConfig<
  TData = Awaited<ReturnType<typeof getClusterConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getClusterConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve the ClusterConfig
 */

export function useGetClusterConfig<
  TData = Awaited<ReturnType<typeof getClusterConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getClusterConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetClusterConfigQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Deletes the single ClusterConfig resource.
 * @summary Delete the ClusterConfig
 */
export type deleteClusterConfigResponse204 = {
  data: void;
  status: 204;
};

export type deleteClusterConfigResponseSuccess = deleteClusterConfigResponse204 & {
  headers: Headers;
};
export type deleteClusterConfigResponse = deleteClusterConfigResponseSuccess;

export const getDeleteClusterConfigUrl = () => {
  return `/v1beta1/system/cluster-config`;
};

export const deleteClusterConfig = async (
  options?: RequestInit
): Promise<deleteClusterConfigResponse> => {
  return customFetch<deleteClusterConfigResponse>(getDeleteClusterConfigUrl(), {
    ...options,
    method: 'DELETE'
  });
};

export const getDeleteClusterConfigMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClusterConfig>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteClusterConfig>>, TError, void, TContext> => {
  const mutationKey = ['deleteClusterConfig'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClusterConfig>>,
    void
  > = () => {
    return deleteClusterConfig(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClusterConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClusterConfig>>
>;

export type DeleteClusterConfigMutationError = unknown;

/**
 * @summary Delete the ClusterConfig
 */
export const useDeleteClusterConfig = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteClusterConfig>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteClusterConfig>>, TError, void, TContext> => {
  const mutationOptions = getDeleteClusterConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Refresh the single ClusterConfig resource. Refreshing enqueues
the resource for reconciliation by its corresponding controller.
 * @summary Refresh the ClusterConfig
 */
export type refreshClusterConfigResponse200 = {
  data: void;
  status: 200;
};

export type refreshClusterConfigResponseSuccess = refreshClusterConfigResponse200 & {
  headers: Headers;
};
export type refreshClusterConfigResponse = refreshClusterConfigResponseSuccess;

export const getRefreshClusterConfigUrl = () => {
  return `/v1beta1/system/cluster-config/refresh`;
};

export const refreshClusterConfig = async (
  options?: RequestInit
): Promise<refreshClusterConfigResponse> => {
  return customFetch<refreshClusterConfigResponse>(getRefreshClusterConfigUrl(), {
    ...options,
    method: 'POST'
  });
};

export const getRefreshClusterConfigMutationOptions = <
  TError = unknown,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshClusterConfig>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshClusterConfig>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['refreshClusterConfig'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshClusterConfig>>,
    void
  > = () => {
    return refreshClusterConfig(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshClusterConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshClusterConfig>>
>;

export type RefreshClusterConfigMutationError = unknown;

/**
 * @summary Refresh the ClusterConfig
 */
export const useRefreshClusterConfig = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshClusterConfig>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof refreshClusterConfig>>, TError, void, TContext> => {
  const mutationOptions = getRefreshClusterConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve information a client may need to know about how the
Kargo API server is configured in order to proceed with
authentication.
 * @summary Retrieve public server configuration
 */
export type getPublicConfigResponse200 = {
  data: PublicConfig;
  status: 200;
};

export type getPublicConfigResponseSuccess = getPublicConfigResponse200 & {
  headers: Headers;
};
export type getPublicConfigResponse = getPublicConfigResponseSuccess;

export const getGetPublicConfigUrl = () => {
  return `/v1beta1/system/public-server-config`;
};

export const getPublicConfig = async (options?: RequestInit): Promise<getPublicConfigResponse> => {
  return customFetch<getPublicConfigResponse>(getGetPublicConfigUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetPublicConfigQueryKey = () => {
  return [`/v1beta1/system/public-server-config`] as const;
};

export const getGetPublicConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicConfig>>,
  TError = unknown
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicConfig>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicConfig>>> = () =>
    getPublicConfig(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPublicConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicConfig>>>;
export type GetPublicConfigQueryError = unknown;

export function useGetPublicConfig<
  TData = Awaited<ReturnType<typeof getPublicConfig>>,
  TError = unknown
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicConfig>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicConfig>>,
          TError,
          Awaited<ReturnType<typeof getPublicConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPublicConfig<
  TData = Awaited<ReturnType<typeof getPublicConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicConfig>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublicConfig>>,
          TError,
          Awaited<ReturnType<typeof getPublicConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPublicConfig<
  TData = Awaited<ReturnType<typeof getPublicConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve public server configuration
 */

export function useGetPublicConfig<
  TData = Awaited<ReturnType<typeof getPublicConfig>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPublicConfigQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve information a client may need to know about how the
Kargo API server is configured.
 * @summary Retrieve server configuration
 */
export type getConfigResponse200 = {
  data: GetConfigResponse;
  status: 200;
};

export type getConfigResponseSuccess = getConfigResponse200 & {
  headers: Headers;
};
export type getConfigResponse = getConfigResponseSuccess;

export const getGetConfigUrl = () => {
  return `/v1beta1/system/server-config`;
};

export const getConfig = async (options?: RequestInit): Promise<getConfigResponse> => {
  return customFetch<getConfigResponse>(getGetConfigUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetConfigQueryKey = () => {
  return [`/v1beta1/system/server-config`] as const;
};

export const getGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = unknown
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfig>>> = () =>
    getConfig(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getConfig>>>;
export type GetConfigQueryError = unknown;

export function useGetConfig<TData = Awaited<ReturnType<typeof getConfig>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConfig<TData = Awaited<ReturnType<typeof getConfig>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConfig<TData = Awaited<ReturnType<typeof getConfig>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve server configuration
 */

export function useGetConfig<TData = Awaited<ReturnType<typeof getConfig>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetConfigQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve API Server version information.
 * @summary Retrieve API Server version information
 */
export type getVersionInfoResponse200 = {
  data: VersionInfo;
  status: 200;
};

export type getVersionInfoResponseSuccess = getVersionInfoResponse200 & {
  headers: Headers;
};
export type getVersionInfoResponse = getVersionInfoResponseSuccess;

export const getGetVersionInfoUrl = () => {
  return `/v1beta1/system/server-version`;
};

export const getVersionInfo = async (options?: RequestInit): Promise<getVersionInfoResponse> => {
  return customFetch<getVersionInfoResponse>(getGetVersionInfoUrl(), {
    ...options,
    method: 'GET'
  });
};

export const getGetVersionInfoQueryKey = () => {
  return [`/v1beta1/system/server-version`] as const;
};

export const getGetVersionInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getVersionInfo>>,
  TError = unknown
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionInfo>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVersionInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionInfo>>> = () =>
    getVersionInfo(requestOptions);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getVersionInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVersionInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionInfo>>>;
export type GetVersionInfoQueryError = unknown;

export function useGetVersionInfo<
  TData = Awaited<ReturnType<typeof getVersionInfo>>,
  TError = unknown
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersionInfo>>,
          TError,
          Awaited<ReturnType<typeof getVersionInfo>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetVersionInfo<
  TData = Awaited<ReturnType<typeof getVersionInfo>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersionInfo>>,
          TError,
          Awaited<ReturnType<typeof getVersionInfo>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetVersionInfo<
  TData = Awaited<ReturnType<typeof getVersionInfo>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Retrieve API Server version information
 */

export function useGetVersionInfo<
  TData = Awaited<ReturnType<typeof getVersionInfo>>,
  TError = unknown
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetVersionInfoQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
