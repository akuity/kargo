//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file k8s.io/apimachinery/pkg/runtime/generated.proto (package k8s.io.apimachinery.pkg.runtime, syntax proto2)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file k8s.io/apimachinery/pkg/runtime/generated.proto.
 */
export const file_k8s_io_apimachinery_pkg_runtime_generated: GenFile = /*@__PURE__*/
  fileDesc("Ci9rOHMuaW8vYXBpbWFjaGluZXJ5L3BrZy9ydW50aW1lL2dlbmVyYXRlZC5wcm90bxIfazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cucnVudGltZSIbCgxSYXdFeHRlbnNpb24SCwoDcmF3GAEgASgMIiwKCFR5cGVNZXRhEhIKCmFwaVZlcnNpb24YASABKAkSDAoEa2luZBgCIAEoCSKBAQoHVW5rbm93bhI7Cgh0eXBlTWV0YRgBIAEoCzIpLms4cy5pby5hcGltYWNoaW5lcnkucGtnLnJ1bnRpbWUuVHlwZU1ldGESCwoDcmF3GAIgASgMEhcKD2NvbnRlbnRFbmNvZGluZxgDIAEoCRITCgtjb250ZW50VHlwZRgEIAEoCUL4AQojY29tLms4cy5pby5hcGltYWNoaW5lcnkucGtnLnJ1bnRpbWVCDkdlbmVyYXRlZFByb3RvUAFaH2s4cy5pby9hcGltYWNoaW5lcnkvcGtnL3J1bnRpbWWiAgVLSUFQUqoCH0s4cy5Jby5BcGltYWNoaW5lcnkuUGtnLlJ1bnRpbWXKAh9LOHNcSW9cQXBpbWFjaGluZXJ5XFBrZ1xSdW50aW1l4gIrSzhzXElvXEFwaW1hY2hpbmVyeVxQa2dcUnVudGltZVxHUEJNZXRhZGF0YeoCI0s4czo6SW86OkFwaW1hY2hpbmVyeTo6UGtnOjpSdW50aW1l");

/**
 * RawExtension is used to hold extensions in external versions.
 *
 * To use this, make a field which has RawExtension as its type in your external, versioned
 * struct, and Object in your internal struct. You also need to register your
 * various plugin types.
 *
 * // Internal package:
 *
 * 	type MyAPIObject struct {
 * 		runtime.TypeMeta `json:",inline"`
 * 		MyPlugin runtime.Object `json:"myPlugin"`
 * 	}
 *
 * 	type PluginA struct {
 * 		AOption string `json:"aOption"`
 * 	}
 *
 * // External package:
 *
 * 	type MyAPIObject struct {
 * 		runtime.TypeMeta `json:",inline"`
 * 		MyPlugin runtime.RawExtension `json:"myPlugin"`
 * 	}
 *
 * 	type PluginA struct {
 * 		AOption string `json:"aOption"`
 * 	}
 *
 * // On the wire, the JSON will look something like this:
 *
 * 	{
 * 		"kind":"MyAPIObject",
 * 		"apiVersion":"v1",
 * 		"myPlugin": {
 * 			"kind":"PluginA",
 * 			"aOption":"foo",
 * 		},
 * 	}
 *
 * So what happens? Decode first uses json or yaml to unmarshal the serialized data into
 * your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked.
 * The next step is to copy (using pkg/conversion) into the internal struct. The runtime
 * package's DefaultScheme has conversion functions installed which will unpack the
 * JSON stored in RawExtension, turning it into the correct object type, and storing it
 * in the Object. (TODO: In the case where the object is of an unknown type, a
 * runtime.Unknown object will be created and stored.)
 *
 * +k8s:deepcopy-gen=true
 * +protobuf=true
 * +k8s:openapi-gen=true
 *
 * @generated from message k8s.io.apimachinery.pkg.runtime.RawExtension
 */
export type RawExtension = Message<"k8s.io.apimachinery.pkg.runtime.RawExtension"> & {
  /**
   * Raw is the underlying serialization of this object.
   *
   * TODO: Determine how to detect ContentType and ContentEncoding of 'Raw' data.
   *
   * @generated from field: optional bytes raw = 1;
   */
  raw: Uint8Array;
};

/**
 * Describes the message k8s.io.apimachinery.pkg.runtime.RawExtension.
 * Use `create(RawExtensionSchema)` to create a new message.
 */
export const RawExtensionSchema: GenMessage<RawExtension> = /*@__PURE__*/
  messageDesc(file_k8s_io_apimachinery_pkg_runtime_generated, 0);

/**
 * TypeMeta is shared by all top level objects. The proper way to use it is to inline it in your type,
 * like this:
 *
 * 	type MyAwesomeAPIObject struct {
 * 	     runtime.TypeMeta    `json:",inline"`
 * 	     ... // other fields
 * 	}
 *
 * func (obj *MyAwesomeAPIObject) SetGroupVersionKind(gvk *metav1.GroupVersionKind) { metav1.UpdateTypeMeta(obj,gvk) }; GroupVersionKind() *GroupVersionKind
 *
 * TypeMeta is provided here for convenience. You may use it directly from this package or define
 * your own with the same fields.
 *
 * +k8s:deepcopy-gen=false
 * +protobuf=true
 * +k8s:openapi-gen=true
 *
 * @generated from message k8s.io.apimachinery.pkg.runtime.TypeMeta
 */
export type TypeMeta = Message<"k8s.io.apimachinery.pkg.runtime.TypeMeta"> & {
  /**
   * +optional
   *
   * @generated from field: optional string apiVersion = 1;
   */
  apiVersion: string;

  /**
   * +optional
   *
   * @generated from field: optional string kind = 2;
   */
  kind: string;
};

/**
 * Describes the message k8s.io.apimachinery.pkg.runtime.TypeMeta.
 * Use `create(TypeMetaSchema)` to create a new message.
 */
export const TypeMetaSchema: GenMessage<TypeMeta> = /*@__PURE__*/
  messageDesc(file_k8s_io_apimachinery_pkg_runtime_generated, 1);

/**
 * Unknown allows api objects with unknown types to be passed-through. This can be used
 * to deal with the API objects from a plug-in. Unknown objects still have functioning
 * TypeMeta features-- kind, version, etc.
 * TODO: Make this object have easy access to field based accessors and settors for
 * metadata and field mutatation.
 *
 * +k8s:deepcopy-gen=true
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 * +protobuf=true
 * +k8s:openapi-gen=true
 *
 * @generated from message k8s.io.apimachinery.pkg.runtime.Unknown
 */
export type Unknown = Message<"k8s.io.apimachinery.pkg.runtime.Unknown"> & {
  /**
   * @generated from field: optional k8s.io.apimachinery.pkg.runtime.TypeMeta typeMeta = 1;
   */
  typeMeta?: TypeMeta;

  /**
   * Raw will hold the complete serialized object which couldn't be matched
   * with a registered type. Most likely, nothing should be done with this
   * except for passing it through the system.
   *
   * @generated from field: optional bytes raw = 2;
   */
  raw: Uint8Array;

  /**
   * ContentEncoding is encoding used to encode 'Raw' data.
   * Unspecified means no encoding.
   *
   * @generated from field: optional string contentEncoding = 3;
   */
  contentEncoding: string;

  /**
   * ContentType  is serialization method used to serialize 'Raw'.
   * Unspecified means ContentTypeJSON.
   *
   * @generated from field: optional string contentType = 4;
   */
  contentType: string;
};

/**
 * Describes the message k8s.io.apimachinery.pkg.runtime.Unknown.
 * Use `create(UnknownSchema)` to create a new message.
 */
export const UnknownSchema: GenMessage<Unknown> = /*@__PURE__*/
  messageDesc(file_k8s_io_apimachinery_pkg_runtime_generated, 2);

